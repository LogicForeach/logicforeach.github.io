<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>YOLO3 数据处理与数据加载 Keras源码分析 - LogicForeach</title><meta description="刘之帅的个人博客"><meta property="og:type" content="blog"><meta property="og:title" content="LogicForeach"><meta property="og:url" content="http://yoursite.com/"><meta property="og:site_name" content="LogicForeach"><meta property="og:description" content="刘之帅的个人博客"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2020-04-04T11:00:08.811Z"><meta property="article:modified_time" content="2020-04-04T11:32:01.308Z"><meta property="article:author" content="刘之帅"><meta property="article:tag" content="YOLO3"><meta property="article:tag" content="Keras"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://yoursite.com/img/logo.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2020/04/04/YOLO3%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},"headline":"LogicForeach","image":["http://yoursite.com/2020/04/04/YOLO3%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/YOLO3%20数据处理与数据加载%20Keras源码分析.assets/20200322031027706.png"],"datePublished":"2020-04-04T11:00:08.811Z","dateModified":"2020-04-04T11:32:01.308Z","author":{"@type":"Person","name":"刘之帅"},"description":"YOLO3 Keras 源码：https:&#x2F;&#x2F;github.com&#x2F;qqwweee&#x2F;keras-yolo3 前言本文从主要是从源码层面对 YOLO3 的数据处理相关内容进行分析与讲解。通常，一个功能的实现需要多个函数配合，所以我将每个功能的实现函数分为两部分，基础函数 和 实现函数 ：  基础函数：被实现函数所依赖，是实现函数的一部分 实现函数：通过调用基础函数实现功能  源码内容比较多，通过目录"}</script><link rel="canonical" href="http://yoursite.com/2020/04/04/YOLO3%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/LOGO.jpg" alt="LogicForeach" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">与我相关</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/LogicForeach"><i class="fab fa-github"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Web" href="https://logicforeach.net"><i class="fab fa-internet-explorer"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-04-04T11:00:08.811Z" title="2020-04-04T11:00:08.811Z">2020-04-04</time><span class="level-item"><a class="link-muted" href="/categories/YOLO3-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">YOLO3 源码分析</a></span><span class="level-item">1 小时 读完 (大约 7150 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">YOLO3 数据处理与数据加载 Keras源码分析</h1><div class="content"><p>YOLO3 Keras 源码：<a href="https://github.com/qqwweee/keras-yolo3">https://github.com/qqwweee/keras-yolo3</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文从主要是从源码层面对 YOLO3 的数据处理相关内容进行分析与讲解。通常，一个功能的实现需要多个函数配合，所以我将每个功能的实现函数分为两部分，<strong>基础函数</strong> 和 <strong>实现函数</strong> ：</p>
<ul>
<li>基础函数：被实现函数所依赖，是实现函数的一部分</li>
<li>实现函数：通过调用基础函数实现功能</li>
</ul>
<p>源码内容比较多，通过目录索引看感兴趣的地方即可。</p>
<h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><h3 id="数据集转换"><a href="#数据集转换" class="headerlink" title="数据集转换"></a>数据集转换</h3><p>YOLO3 Keras 源码所需要的数据集应该在一个<code>.txt</code> ( 文本文件 )内，文件中的一行代表一个张图片和它的标签，其中每行的格式为：</p>
<pre><code>image_file_path box1 box2 ... boxN
</code></pre><p><code>box*</code> 是该图片的标签，即真实框，不同box之间用空格隔开，其中每个box的格式为</p>
<pre><code>x_min,y_min,x_max,y_max,class_id
</code></pre><p>所以总的来说，训练用的数据集应该大体是这个样子的：</p>
<a id="more"></a>
<pre><code>path/to/img1.jpg 50,100,150,200,0 30,50,200,120,3
path/to/img2.jpg 120,300,250,600,2
...
</code></pre><p>对于 VOC 数据集，Keras 源码的作者给出了脚本 <code>voc_annotation.py</code> 可以将 VOC 数据集转化成上述格式。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><pre><code class="lang-python">import xml.etree.ElementTree as ET
from os import getcwd

sets=[(&#39;2007&#39;, &#39;train&#39;), (&#39;2007&#39;, &#39;val&#39;), (&#39;2007&#39;, &#39;test&#39;)]

classes = [&quot;aeroplane&quot;, &quot;bicycle&quot;, &quot;bird&quot;, &quot;boat&quot;, &quot;bottle&quot;, &quot;bus&quot;, &quot;car&quot;, &quot;cat&quot;, &quot;chair&quot;, &quot;cow&quot;, &quot;diningtable&quot;, &quot;dog&quot;, &quot;horse&quot;, &quot;motorbike&quot;, &quot;person&quot;, &quot;pottedplant&quot;, &quot;sheep&quot;, &quot;sofa&quot;, &quot;train&quot;, &quot;tvmonitor&quot;]


def convert_annotation(year, image_id, list_file):
    in_file = open(&#39;VOCdevkit/VOC%s/Annotations/%s.xml&#39;%(year, image_id))
    tree=ET.parse(in_file)
    root = tree.getroot()

    for obj in root.iter(&#39;object&#39;):
        difficult = obj.find(&#39;difficult&#39;).text
        cls = obj.find(&#39;name&#39;).text
        if cls not in classes or int(difficult)==1:
            continue
        cls_id = classes.index(cls)
        xmlbox = obj.find(&#39;bndbox&#39;)
        b = (int(xmlbox.find(&#39;xmin&#39;).text), int(xmlbox.find(&#39;ymin&#39;).text), int(xmlbox.find(&#39;xmax&#39;).text), int(xmlbox.find(&#39;ymax&#39;).text))
        list_file.write(&quot; &quot; + &quot;,&quot;.join([str(a) for a in b]) + &#39;,&#39; + str(cls_id))

wd = getcwd()

for year, image_set in sets:
    image_ids = open(&#39;VOCdevkit/VOC%s/ImageSets/Main/%s.txt&#39;%(year, image_set)).read().strip().split()
    list_file = open(&#39;%s_%s.txt&#39;%(year, image_set), &#39;w&#39;)
    for image_id in image_ids:
        list_file.write(&#39;%s/VOCdevkit/VOC%s/JPEGImages/%s.jpg&#39;%(wd, year, image_id))
        convert_annotation(year, image_id, list_file)
        list_file.write(&#39;\n&#39;)
    list_file.close()
</code></pre>
<h4 id="基础函数："><a href="#基础函数：" class="headerlink" title="基础函数："></a>基础函数：</h4><h5 id="convert-annotation-year-image-id-list-file"><a href="#convert-annotation-year-image-id-list-file" class="headerlink" title="convert_annotation(year, image_id, list_file)"></a><code>convert_annotation(year, image_id, list_file)</code></h5><p>参数：</p>
<ul>
<li><strong>year</strong>：整型，年代 , VOC2007 的 2007 </li>
<li><strong>image_id</strong> ：图像序号</li>
<li><strong>list_file</strong> ： 文件对象</li>
</ul>
<p>功能：</p>
<ul>
<li>通过 <code>year</code> 和 <code>image_id</code>找到 VOC 数据集里的 xml 文件，通过 ElementTree 找到这个 XML 里的每一个 <code>object</code> 标签，获取该标签内的 <code>xmin,ymin,xmax,ymax</code>，和列表序号<code>class_id</code> ，把它们写入到 list_file 所打开的文件对象中。</li>
<li>总之，这个函数是在将 <code>.xml</code> 中的标注信息转化为 YOLO3 所需要标注格式，并写入文件。</li>
</ul>
<h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><h5 id="脚本主内容"><a href="#脚本主内容" class="headerlink" title="脚本主内容"></a>脚本主内容</h5><pre><code class="lang-python">for year, image_set in sets:
    image_ids = open(&#39;VOCdevkit/VOC%s/ImageSets/Main/%s.txt&#39;%(year, image_set)).read().strip().split()
    list_file = open(&#39;%s_%s.txt&#39;%(year, image_set), &#39;w&#39;)
    for image_id in image_ids:
        list_file.write(&#39;%s/VOCdevkit/VOC%s/JPEGImages/%s.jpg&#39;%(wd, year, image_id))
        convert_annotation(year, image_id, list_file)
        list_file.write(&#39;\n&#39;)
    list_file.close()
</code></pre>
<p><code>year, image_set</code> 是从 <code>sets</code> 提取而来，这个 for 循环的目的是操作 <code>sets</code> 中对应的每一个文件。</p>
<p>即打开<code>train.txt</code> 、<code>val.txt</code> 、<code>test.txt</code> ，它们里面内容长这个样：</p>
<pre><code>0
1
10
100
1000
....
</code></pre><p>这其中每一行都是图片的序号。</p>
<p>如打开<code>train.txt</code> ，脚本通过 <code>.read().strip().split()</code> ，把 <code>train.txt</code> 中一行一行的图片序号变成一个列表 <code>image_ids</code> ，创建一个文件对象 <code>list_file</code> 随后对列表内每一个元素进行操作：</p>
<ul>
<li>根据文件路径和图片序号的映射关系，把图片路劲写入到 <code>list_file</code>  文件对象对应的文件中。</li>
<li>通过 <code>convert_annotation</code> 把图片的标注信息（已转化为 YOLO3 所需格式），紧接着路径信息写在后面</li>
<li>写入换行符</li>
</ul>
<p>所以元素操作完事，关闭文件对象。</p>
<p>通过上述流程对 <code>train.txt</code> 、<code>val.txt</code> 、<code>test.txt</code> 都操作完，就把 VOC 数据集转化为 YOLO3 所需要的格式了。</p>
<h3 id="使用-K-means-生成锚框"><a href="#使用-K-means-生成锚框" class="headerlink" title="使用 K-means 生成锚框"></a>使用 K-means 生成锚框</h3><p>YOLO2 开始，锚框的生成使用 K-means 算法，这种倚靠训练数据自动生成的锚框，比人为设定的锚框更加符合特定场景的业务需求，所以会提高模型的准确度。</p>
<p>介绍 K-means 之前，需要先了解它是用于什么学习任务的，K-means 是解决聚类问题的一个算法。</p>
<h4 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h4><p><strong>聚类和簇</strong></p>
<p>聚类任务是一种无监督学习任务，聚类试图将样本划分为若干个不相交的子集，每个子集成为<strong>簇</strong>，通过这样的划分，每个簇对应一个潜在类别，具体是什么类别，对于聚类算法而言是未知，都是在聚类结束后，人为的判断一个簇对应的什么类别。聚类常用于寻找数据内部的分布结构，或用于对其他分类学习任务进行粗略的预先处理。比如自从 YOLO2 后，聚类算法就被用于预先为图像划定锚框。</p>
<p><strong>距离计算</strong></p>
<p>聚类任务说到底是让”簇内相似度高“且”簇间相似度低“，那么就需要一个衡量相似度的指标，两个样本间的距离可以反映样本之间的相似度，所以定义 $dist(\cdot,\cdot)$ 为两个样本的距离。距离的计算有诸多算法，比如“闵可夫斯基距离”</p>
<script type="math/tex; mode=display">
dist_{mk}(x_i,x_j)=(\sum_{u=1}^n|x_{i,u}-x_{j,x}|^p)^{\frac{1}{p}}</script><p>在 YOLO2 和 YOLO3 中，距离计算是借助两个 box 的 IOU：</p>
<script type="math/tex; mode=display">
dist(b_i,b_j)=1-IOU(b_i,b_j)</script><p><strong>K-means 算法</strong></p>
<p>K-means 的思想是，对所划分的所有簇 $C={C_1,C_2,\dots,C_k}$ 使</p>
<script type="math/tex; mode=display">
E=\sum_{i=1}^k\sum_{x\in C_i}dist(x,\mu_i)</script><p>最小，其中 $\mu<em>i=\frac{1}{|C_i|}\sum</em>{x\in C_i}x$ ，即 $\mu_i$ 是 $C_i$ 的均指向量。</p>
<p>为了达到这个目的，K-means 采用贪心策略，最开始随机指定 K 个向量作为 $(\mu_1,\dots,\mu_k)$ 对于每一个 $\mu_i$ ，计算每一个向量 $x$ 与 $\mu_i$ 的距离，即 $dist(x,\mu_i)$ 将距离值最小的向量，归到 $C_i$ 然后更新  $\mu_i$ ，重复这个过程，直到 $(\mu_1,\dots,\mu_k)$ 都不再更新。</p>
<p><img src="YOLO3 数据处理与数据加载 Keras源码分析.assets/20200322031027706.png" alt=""></p>
<h4 id="基础函数"><a href="#基础函数" class="headerlink" title="基础函数"></a>基础函数</h4><h5 id="YOLO-Kmeans-init"><a href="#YOLO-Kmeans-init" class="headerlink" title="YOLO_Kmeans.__init__"></a><code>YOLO_Kmeans.__init__</code></h5><p><code>YOLO_Kmeans</code> 是一个类，它的初始化函数如下：</p>
<pre><code class="lang-python">def __init__(self, cluster_number, filename):
    self.cluster_number = cluster_number
    self.filename = filename
</code></pre>
<p>其作用仅是将参数保留到类内</p>
<h5 id="YOLO-Kmeans-txt2boxes"><a href="#YOLO-Kmeans-txt2boxes" class="headerlink" title="YOLO_Kmeans.txt2boxes"></a><code>YOLO_Kmeans.txt2boxes</code></h5><pre><code class="lang-python">def txt2boxes(self):
    f = open(self.filename, &#39;r&#39;)
    dataSet = []
    for line in f:
        infos = line.split(&quot; &quot;)
        length = len(infos)
        for i in range(1, length):
            width = int(infos[i].split(&quot;,&quot;)[2]) - \
                int(infos[i].split(&quot;,&quot;)[0])
            height = int(infos[i].split(&quot;,&quot;)[3]) - \
                int(infos[i].split(&quot;,&quot;)[1])
            dataSet.append([width, height])
    result = np.array(dataSet)
    f.close()
    return result
</code></pre>
<p>该方法的作用是将 YOLO 标注文件内的 box 信息转化为列表</p>
<p>YOLO 标注文件格式如下：</p>
<pre><code>path/to/img1.jpg 50,100,150,200,0 30,50,200,120,3
path/to/img2.jpg 120,300,250,600,2
...
</code></pre><p><code>f</code> 是一个文件对象，文件对象可迭代，每次读取文件的一行，最外层的 for 是指对文件内的每一行操作。</p>
<p>对文件内的每一行，以空格为分隔符，将其划分为列表 <code>infos</code> ：</p>
<p>对 <code>infos[1]</code> 到 <code>infors[length-1]</code> 中的每一个元素 <code>infos[i]</code> 而言，每一个 <code>infos[i]</code> 代表一组 box 信息。<code>infos[i].split(&quot;,&quot;)[0]</code> 、<code>infos[i].split(&quot;,&quot;)[1]</code> 、<code>infos[i].split(&quot;,&quot;)[2]</code> 、<code>infos[i].split(&quot;,&quot;)[3]</code>   、<code>infos[i].split(&quot;,&quot;)[4]</code>分别对应 box 信息里的 <code>x_min,y_min,x_max,y_max,class_id</code> ，由这些信息就可以计算出 box 的宽和高，记为<code>[width, height]</code> ，将每组 box 的 <code>[width, height]</code> 追加到 <code>dataSet</code> 列表内，将 <code>dataSet</code>  转化为 <code>np.array</code> 并返回。</p>
<h5 id="YOLO-Kmeans-iou"><a href="#YOLO-Kmeans-iou" class="headerlink" title="YOLO_Kmeans.iou"></a><code>YOLO_Kmeans.iou</code></h5><pre><code class="lang-python">def iou(self, boxes, clusters):  # 1 box -&gt; k clusters
    n = boxes.shape[0]
    k = self.cluster_number

    box_area = boxes[:, 0] * boxes[:, 1]
    box_area = box_area.repeat(k)
    box_area = np.reshape(box_area, (n, k))

    cluster_area = clusters[:, 0] * clusters[:, 1]
    cluster_area = np.tile(cluster_area, [1, n])
    cluster_area = np.reshape(cluster_area, (n, k))

    box_w_matrix = np.reshape(boxes[:, 0].repeat(k), (n, k))
    cluster_w_matrix = np.reshape(np.tile(clusters[:, 0], (1, n)), (n, k))
    min_w_matrix = np.minimum(cluster_w_matrix, box_w_matrix)

    box_h_matrix = np.reshape(boxes[:, 1].repeat(k), (n, k))
    cluster_h_matrix = np.reshape(np.tile(clusters[:, 1], (1, n)), (n, k))
    min_h_matrix = np.minimum(cluster_h_matrix, box_h_matrix)
    inter_area = np.multiply(min_w_matrix, min_h_matrix)

    result = inter_area / (box_area + cluster_area - inter_area)
    return result
</code></pre>
<p>参数：</p>
<ul>
<li>boxes ： 盒子信息，结构为<code>[[w1,h1],[w2,h2]...]</code></li>
<li>clusters：簇点信息，内含 k 个 <code>[w,h]</code> 结构为 <code>[[w1,h1],...,[wk,hk]]</code></li>
</ul>
<p>执行过程：</p>
<ul>
<li>求每个盒子的面积，重复 k 次，得到 n*k 矩阵 <code>box_area</code> , n 是总盒子数，k 是簇数</li>
<li>求每个簇点的面积，所有簇点面积集合记为 <code>cluster_area</code> , 一开始，<code>cluster_area</code> 是 <code>shape=(1,k)</code> 的 np 数组，经过 <code>np.tile</code> 变成 <code>shape=(1,k*n)</code>，<code>np.reshape</code> 成 <code>shape=(n,k)</code></li>
<li>用相似的维度变化，求盒子的 w 矩阵 <code>box_w_matrix</code>，与簇点的 w 矩阵 <code>cluster_w_matrix</code> ，用 <code>np.minimum</code> 取宽最小矩阵 <code>min_w_matrix</code></li>
<li>同理求高最小矩阵 <code>min_h_matrix</code></li>
<li>盒子与簇在假设左上角对齐的情况下，最小的宽*最小的高就是他们相交的区域的面积，相交面积 <code>inter_area = np.multiply(min_w_matrix, min_h_matrix)</code></li>
<li>最终返回 IOU 值 IOU = 相交面积/相并面积 = 相交面积/( 盒子面积 + 簇点面积 - 相交面积 )，最红返回的 result 的形状 <code>shape=(n,k)</code></li>
</ul>
<h5 id="YOLO-Kmeans-kmeans"><a href="#YOLO-Kmeans-kmeans" class="headerlink" title="YOLO_Kmeans.kmeans"></a><code>YOLO_Kmeans.kmeans</code></h5><pre><code class="lang-python">def kmeans(self, boxes, k, dist=np.median):
    box_number = boxes.shape[0]
    distances = np.empty((box_number, k))
    last_nearest = np.zeros((box_number,))
    np.random.seed()
    clusters = boxes[np.random.choice(
        box_number, k, replace=False)]  # init k clusters
    while True:

        distances = 1 - self.iou(boxes, clusters)

        current_nearest = np.argmin(distances, axis=1)
        if (last_nearest == current_nearest).all():
            break  # clusters won&#39;t change
        for cluster in range(k):
            clusters[cluster] = dist(  # update clusters
                boxes[current_nearest == cluster], axis=0)

        last_nearest = current_nearest

    return clusters
</code></pre>
<p>参数 :</p>
<ul>
<li>boxes : 前面通过 <code>txt2boxes</code> 处理后得到的 np 数组，结构为<code>[[w1,h1],[w2,h2]...]</code></li>
<li>k : 整型，簇数</li>
<li>dist : 均值向量生成策略，这里用的中位数（那应该叫中位数向量hhhh）</li>
</ul>
<p>执行过程：</p>
<ul>
<li><p>得到 <code>boxes</code> 中的盒子数 <code>box_number</code>，用 <code>np.empty</code> 创建一个 <code>shape=(box_number, k)</code> 的空 np 数组 <code>distances</code>，用储存 boxes 中的每个盒子和每个簇的距离；用 <code>np.zeros</code> 创建一个长度为 <code>box_number</code> 的一维全零 np 数组，用于存储每个盒子距离最近的簇的索引值。</p>
</li>
<li><p>通过 <code>clusters = boxes[np.random.choice(box_number, k, replace=False)]</code> 从 <code>boxes</code>  中随机进行不放回抽样，选出 k 个 盒子信息作为初始的簇点。</p>
<p>  这里采用的是高级索引，<code>boxes[[1,2,3]]==[boxes[1],boxes[2],boxes[3]]</code> ，<code>numpy.random.choice(a, size=None, replace=True, p=None)</code> 它的参数从左到右依次表示候选列表、抽烟个数、是否放回、列表中各元素被抽中的概率。</p>
</li>
<li><p>进行循环直到 break 才终止：</p>
<ul>
<li><p>计算boxes 中的每个盒子和每个簇的距离，结果存放入 <code>distances</code>， <code>self.iou(boxes, clusters)</code> 后面讲解。</p>
</li>
<li><p>通过 <code>np.argmin(distances, axis=1)</code> 返回每个盒子距离最近的簇的索引值，结果存入<code>current_nearest</code>；<code>np.argmin(a, axis=None, out=None)</code> 可以沿 <code>axis</code>轴，在数组 <code>a</code> 中寻找最小值，并返回该值在 <code>axis</code> 轴内的索引。</p>
</li>
<li><p>如果上一轮循环中每个盒子距离最近的簇的索引 <code>last_nearest</code> 和这一轮的 <code>current_nearest</code>  中每一个元素都相同，那么说明算法已经收敛，跳出循环。</p>
<p>  其中 <code>last_nearest == current_nearest</code> 由于双等号两边都是同型 np 数组，所以这个表达式返回的也是同型 np 数组，数组内元素类型是布尔型，表示对应元素是否相同，<code>np.np.array.all()</code> 表示若数组内元素都为 True 则返回 True，否则返回 False</p>
</li>
<li><p>如果存在不同元素，就对 K 个簇点进行遍历， 让每个簇点等于该簇内向量的中位数。</p>
<p>  通过<code>boxes[current_nearest == cluster]</code> 找出所有”相对于其他簇点，与第<code>cluster</code> 个簇距离最近”的盒子，得到一个列表，列表结构为<code>[[w1,h1],[w2,h2]...]</code></p>
<p>  通过 <code>dist</code> 即 <code>np.median</code> 对上述列表，沿第一个轴求中位数，最终得到结构为<code>[w,h]</code>的一维二元列表。</p>
</li>
<li><p>更新结束，把当前状态 <code>current_nearest</code>  赋值给 <code>last_nearest</code> 开始下一轮循环。</p>
</li>
</ul>
</li>
<li><p>循环结束，将簇点列表 <code>clusters</code> 返回，在 YOLO3 中，各簇点就是预设的锚框信息。</p>
</li>
</ul>
<h5 id="YOLO-Kmeans-txt2clusters"><a href="#YOLO-Kmeans-txt2clusters" class="headerlink" title="YOLO_Kmeans.txt2clusters"></a><code>YOLO_Kmeans.txt2clusters</code></h5><pre><code class="lang-python">def txt2clusters(self):
      = self.txt2boxes()
    result = self.kmeans(all_boxes, k=self.cluster_number)
    result = result[np.lexsort(result.T[0, None])]
    self.result2txt(result)
    print(&quot;K anchors:\n {}&quot;.format(result))
    print(&quot;Accuracy: {:.2f}%&quot;.format(
    self.avg_iou(all_boxes, result) * 100))
</code></pre>
<p><code>txt2clusters</code> 是脚本的执行函数，求kmeans就是从这个函数入手，这个函数主要过程就是：</p>
<ul>
<li><p><code>txt2boxes</code> 将文本信息划分并提取成列表信息 <code>all_boxes</code> , <code>all_boxes</code> 内各个盒子的信息，结构为 <code>[[w1,h1],[w2,h2]...]</code></p>
</li>
<li><p>使用 <code>kmeans</code> 求盒子列表的聚类，返回的是 k 个簇点，结构也为 <code>[[w1,h1],[w2,h2]...]</code> j结果保存到 <code>result</code></p>
</li>
<li><p>通过 <code>result[np.lexsort(result.T[0, None])]</code> 对 <code>result</code> 进行排序，排序规则是宽度小的在前面</p>
<p>  <code>result.T</code> 会对 <code>result</code> 转置，转置后结构为 <code>[[w1,...,wk],[h1...hk]]</code></p>
<p>  <code>result.T[0,None]</code> 是只取宽度数据，并且扩充一维，变成<code>[[w1,...,wk]]</code></p>
<p>  <code>lexsort(keys, axis=None)</code> ：返回一个整数数组（返回数组的元素是索引值）。<code>keys</code> 是一个序列的序列，要求内部序列形状相同，默认情况外部序列 <code>keys</code> 中的最后一个序列元素将作为主排序序列，倒数第二个序列元素作为第二排序序列….当主排序序列中元素大小相同时，就依照第二排序系列进行排序。</p>
<p>  <code>np.lexsort(result.T[0, None])</code> 输出结果是 <code>w1,...,wk</code> 依照升序排序后的顺序输出原索引值，是有 K 个元素的一维数组</p>
</li>
<li><p>使用 <code>result2txt</code> 将结果输出为文本文件</p>
</li>
<li><p>使用 <code>avg_iou</code> 评价聚类的结果</p>
</li>
</ul>
<h5 id="YOLO-Kmeans-result2txt"><a href="#YOLO-Kmeans-result2txt" class="headerlink" title="YOLO_Kmeans.result2txt"></a><code>YOLO_Kmeans.result2txt</code></h5><pre><code class="lang-python">def result2txt(self, data):
    f = open(&quot;yolo_anchors.txt&quot;, &#39;w&#39;)
    row = np.shape(data)[0]
    for i in range(row):
        if i == 0:
            x_y = &quot;%d,%d&quot; % (data[i][0], data[i][1])
        else:
            x_y = &quot;, %d,%d&quot; % (data[i][0], data[i][1])
        f.write(x_y)
    f.close()
</code></pre>
<p>将每一个簇点信息，写入 <code>yolo_anchors.txt</code> 文件，文件格式是：</p>
<pre><code>w1,h1 w2,h2 ... wk,hk
</code></pre><h5 id="YOLO-Kmeans-avg-iou"><a href="#YOLO-Kmeans-avg-iou" class="headerlink" title="YOLO_Kmeans.avg_iou"></a><code>YOLO_Kmeans.avg_iou</code></h5><pre><code class="lang-python">def avg_iou(self, boxes, clusters):
    accuracy = np.mean([np.max(self.iou(boxes, clusters), axis=1)])
    return accuracy
</code></pre>
<p>用于评价聚类效果，这里的准确率是 n 个盒子的平均最大交并比。对于每个盒子来说，与盒子 IOU 最大的簇，一定是这个盒子所属的簇，所以 acc 可以理解为是 n 个盒子和它所属的簇的 IOU 的均值。acc 越大，说明簇分布的越好。</p>
<p>具体算法是</p>
<script type="math/tex; mode=display">
Accuracy=\frac{\sum_{i=1}^n IOU_{max}(Box_i)}{n}</script><p>其中，</p>
<script type="math/tex; mode=display">
IOU_{max}(Box_i)=\max_{i}\{ IOU(Box_i,C_j) \}</script><p>即 n 个盒子和 k 个簇进行 IOU 运算，对于每个盒子选择 IOU 最大的值作为代表，最终求 n 个 IOU 的均值作为准确率。</p>
<h4 id="实现函数"><a href="#实现函数" class="headerlink" title="实现函数"></a>实现函数</h4><p>在 <code>\kmeans.py</code> 文件中：</p>
<pre><code class="lang-python">if __name__ == &quot;__main__&quot;:
    cluster_number = 9
    filename = &quot;2007_train.txt&quot;
    kmeans = YOLO_Kmeans(cluster_number, filename)
    kmeans.txt2clusters()
</code></pre>
<p>整体来说，这个脚本干了两件事，一个是求符合 YOLO 要求的 Kmeans，一个是把这个结果保存成文本。</p>
<h2 id="读入数据"><a href="#读入数据" class="headerlink" title="读入数据"></a>读入数据</h2><p>YOLO3 需要将训练数据载入后进行一些处理才能用于训练，这部分代码主要位于 <code>train.py</code> 文件。</p>
<h4 id="基础函数-1"><a href="#基础函数-1" class="headerlink" title="基础函数"></a>基础函数</h4><h5 id="get-random-data"><a href="#get-random-data" class="headerlink" title="get_random_data"></a><code>get_random_data</code></h5><p>在<code>yolo3\utils.py</code></p>
<pre><code class="lang-python">def get_random_data(annotation_line, input_shape, random=True, max_boxes=20, jitter=.3, hue=.1, sat=1.5, val=1.5, proc_img=True):
    &#39;&#39;&#39;为实现实时数据增强的随机预处理&#39;&#39;&#39;
    line = annotation_line.split()
    # 打开图片
    image = Image.open(line[0])
    iw, ih = image.size
    h, w = input_shape
    box = np.array([np.array(list(map(int,box.split(&#39;,&#39;)))) for box in line[1:]]) #box = [[x_min,y_min,x_max,y_max,class_id],..]


    if not random:
        # 调整图像尺寸,使其与input_shape一致
        scale = min(w/iw, h/ih)
        nw = int(iw*scale)
        nh = int(ih*scale)
        dx = (w-nw)//2
        dy = (h-nh)//2
        image_data=0
        if proc_img:
            image = image.resize((nw,nh), Image.BICUBIC)
            new_image = Image.new(&#39;RGB&#39;, (w,h), (128,128,128))
            new_image.paste(image, (dx, dy))
            image_data = np.array(new_image)/255.

        # 修正 boxes
        box_data = np.zeros((max_boxes,5))
        if len(box)&gt;0:
            np.random.shuffle(box)
            if len(box)&gt;max_boxes: box = box[:max_boxes]
            box[:, [0,2]] = box[:, [0,2]]*scale + dx
            box[:, [1,3]] = box[:, [1,3]]*scale + dy
            box_data[:len(box)] = box

        return image_data, box_data

    # 随机调整图像长宽比，长宽比改变范围由 jitter 参数控制
    new_ar = w/h * rand(1-jitter,1+jitter)/rand(1-jitter,1+jitter)
    #随机缩放图像，缩放范围为（0.25，2）
    scale = rand(.25, 2)
    if new_ar &lt; 1:
        nh = int(scale*h)
        nw = int(nh*new_ar)
    else:
        nw = int(scale*w)
        nh = int(nw/new_ar)
    image = image.resize((nw,nh), Image.BICUBIC)


    # 图像随机平移
    # 调整图像尺寸,使其与input_shape一致，多的裁掉，少的用灰色填空
    dx = int(rand(0, w-nw))
    dy = int(rand(0, h-nh))
    new_image = Image.new(&#39;RGB&#39;, (w,h), (128,128,128))
    new_image.paste(image, (dx, dy))
    image = new_image

    # 随机左右翻转，翻转概率 0.5
    flip = rand()&lt;.5
    if flip: image = image.transpose(Image.FLIP_LEFT_RIGHT)

    # 对图像的色调、饱和度、明度进行随机调整   
    hue = rand(-hue, hue)
    sat = rand(1, sat) if rand()&lt;.5 else 1/rand(1, sat) 
    val = rand(1, val) if rand()&lt;.5 else 1/rand(1, val)
    # HUE 色调; Saturation 饱和度; Value 明度
    x = rgb_to_hsv(np.array(image)/255.)
    x[..., 0] += hue
    x[..., 0][x[..., 0]&gt;1] -= 1
    x[..., 0][x[..., 0]&lt;0] += 1
    x[..., 1] *= sat
    x[..., 2] *= val
    x[x&gt;1] = 1
    x[x&lt;0] = 0
    image_data = hsv_to_rgb(x) # numpy array, 0 to 1

    # 修正盒子信息
    box_data = np.zeros((max_boxes,5))
    if len(box)&gt;0:
        np.random.shuffle(box)
        # box 缩放与位移
        box[:, [0,2]] = box[:, [0,2]]*nw/iw + dx
        box[:, [1,3]] = box[:, [1,3]]*nh/ih + dy
        # box 反转
        if flip: box[:, [0,2]] = w - box[:, [2,0]]
        # box 截掉超出边界的
        box[:, 0:2][box[:, 0:2]&lt;0] = 0
        box[:, 2][box[:, 2]&gt;w] = w
        box[:, 3][box[:, 3]&gt;h] = h
        # box 丢弃过小的
        box_w = box[:, 2] - box[:, 0]
        box_h = box[:, 3] - box[:, 1]
        box = box[np.logical_and(box_w&gt;1, box_h&gt;1)] # discard invalid box
        if len(box)&gt;max_boxes: box = box[:max_boxes]
        box_data[:len(box)] = box

    return image_data, box_data
</code></pre>
<p><code>get_random_data</code> 函数用于从 YOLO3 的标注文件生成训练所需的图像信息，同时还提供了对图像的随机数据增强。具体实现看注释吧。</p>
<p>参数：</p>
<ul>
<li><strong>annotation_line</strong>：标注文件中某一行的文本信息，通过这一行文本来获取图片路径和盒子信息。</li>
<li><strong>input_shape</strong>：指网络的输入尺寸，最终图像会被调整到这个尺寸</li>
<li><strong>random=True</strong>：是否开启随机数据增强，默认开启，如果不开启就是单纯的缩放个尺寸</li>
<li><strong>max_boxes=20</strong>：最大盒子数，默认20</li>
<li><strong>jitter=.3</strong>：开启随机数据增强时，这个参数影响长宽比变化范围</li>
<li><strong>hue=.1</strong>：开启随机数据增强时，这个参数影响色调变化范围</li>
<li><strong>sat=1.5</strong>：开启随机数据增强时，这个参数影响饱和度变化范围</li>
<li><strong>val=1.5</strong>：开启随机数据增强时，这个参数影响明度变化范围</li>
<li><strong>proc_img=True</strong>：没整明白存在的意义，True 就完事了</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回一个元组，<code>(image_data, box_data)</code></li>
<li><code>image_data</code> 形如 <code>(h,w,3)</code>，值域 0 到 1</li>
<li><code>box_data</code> 二维数组，结构类似 <code>[[x_min,y_min,x_max,y_max,class_id],..]</code>，它的形状为 <code>shape=(max_boxes,5)</code>，5 是指相对于输入尺寸的绝对坐标 <code>x_min, y_min, x_max, y_max,</code> 和类别号  <code>class_id</code></li>
</ul>
<h5 id="preprocess-true-boxes"><a href="#preprocess-true-boxes" class="headerlink" title="preprocess_true_boxes"></a><code>preprocess_true_boxes</code></h5><p>在<code>yolo3\model.py</code></p>
<pre><code class="lang-python">def preprocess_true_boxes(true_boxes, input_shape, anchors, num_classes):
    assert (true_boxes[..., 4]&lt;num_classes).all(), &#39;class id must be less than num_classes&#39;
    num_layers = len(anchors)//3 # default setting
    anchor_mask = [[6,7,8], [3,4,5], [0,1,2]] if num_layers==3 else [[3,4,5], [1,2,3]]

    true_boxes = np.array(true_boxes, dtype=&#39;float32&#39;)
    input_shape = np.array(input_shape, dtype=&#39;int32&#39;)
    boxes_xy = (true_boxes[..., 0:2] + true_boxes[..., 2:4]) // 2
    boxes_wh = true_boxes[..., 2:4] - true_boxes[..., 0:2]
    true_boxes[..., 0:2] = boxes_xy/input_shape[::-1]
    true_boxes[..., 2:4] = boxes_wh/input_shape[::-1]

    m = true_boxes.shape[0]
    grid_shapes = [input_shape//{0:32, 1:16, 2:8}[l] for l in range(num_layers)]
    y_true = [np.zeros((m,grid_shapes[l][0],grid_shapes[l][1],len(anchor_mask[l]),5+num_classes),
        dtype=&#39;float32&#39;) for l in range(num_layers)]

    # Expand dim to apply broadcasting.
    anchors = np.expand_dims(anchors, 0)
    anchor_maxes = anchors / 2.
    anchor_mins = -anchor_maxes
    valid_mask = boxes_wh[..., 0]&gt;0

    for b in range(m):
        # Discard zero rows.
        wh = boxes_wh[b, valid_mask[b]]
        if len(wh)==0: continue
        # Expand dim to apply broadcasting.
        wh = np.expand_dims(wh, -2)
        box_maxes = wh / 2.
        box_mins = -box_maxes

        intersect_mins = np.maximum(box_mins, anchor_mins)
        intersect_maxes = np.minimum(box_maxes, anchor_maxes)
        intersect_wh = np.maximum(intersect_maxes - intersect_mins, 0.)
        intersect_area = intersect_wh[..., 0] * intersect_wh[..., 1]
        box_area = wh[..., 0] * wh[..., 1]
        anchor_area = anchors[..., 0] * anchors[..., 1]
        iou = intersect_area / (box_area + anchor_area - intersect_area)

        # Find best anchor for each true box
        best_anchor = np.argmax(iou, axis=-1)

        for t, n in enumerate(best_anchor):
            for l in range(num_layers):
                if n in anchor_mask[l]:
                    i = np.floor(true_boxes[b,t,0]*grid_shapes[l][1]).astype(&#39;int32&#39;)
                    j = np.floor(true_boxes[b,t,1]*grid_shapes[l][0]).astype(&#39;int32&#39;)
                    k = anchor_mask[l].index(n)
                    c = true_boxes[b,t, 4].astype(&#39;int32&#39;)
                    y_true[l][b, j, i, k, 0:4] = true_boxes[b,t, 0:4]
                    y_true[l][b, j, i, k, 4] = 1
                    y_true[l][b, j, i, k, 5+c] = 1

    return y_true
</code></pre>
<p>该函数用于将真实盒子信息转化成训练所需要的格式。</p>
<p>参数：</p>
<ul>
<li><strong>true_boxes</strong>: 多维数组，要求形状为 <code>(batch_size,boxes_number,5)</code> 由 <code>get_random_data</code> 生成</li>
<li><strong>input_shape</strong>: 网络的输入尺寸应该是32的倍数，注意这里的尺寸是 <strong>高在前、宽在后</strong></li>
<li><strong>anchors</strong>: 锚框，形状为<code>(k,2)</code> k是锚框个数; 2 是<code>(w,h)</code></li>
<li><strong>num_classes</strong>: 整型,总类别数</li>
</ul>
<p>返回：</p>
<ul>
<li><strong>y_true</strong> ：和 yolo3 网络输出的数据同型的数组，此时的 wxyh 已经换为相对路径</li>
</ul>
<p>执行过程：</p>
<ul>
<li><p>计算 YOLO3 网络输出的特征图数目，这里认为输出的特征图数目与锚框数目有关，经典 YOLO3 输出三个特征图，每个特征图 3 个锚框，共 9 个。tiny-YOLO 则输出 2 个特征图，每个特征图 3 个锚框，所以可由锚框数目求 YOLO3 输出的特征图数目，并分辨网络类型。其中：</p>
<ul>
<li><code>num_layers</code> 表示输出特征图数目</li>
<li><p><code>anchor_mask</code> 是锚框掩码，用于规定每个特征图用哪几个锚框</p>
<p>之后均以 <strong>YOLO3 输出三个特征图，每个特征图 3 个锚框</strong> 为例。</p>
</li>
</ul>
</li>
<li><p>对于参数 <code>true_boxes</code> 和 <code>input_shape</code> 进行类型转换</p>
</li>
<li><p>求出每个盒子的中心点坐标 <code>boxes_xy</code> 与宽高信息 <code>boxes_wh</code> 这两个参数形状为 <code>(batch_size,boxes_number,2)</code> </p>
</li>
<li><p>对  <code>true_boxes</code>  中的位置和宽高进行修改，将其改为相对于原图的比例数值，称新的 <code>true_boxes[..., 0:4]</code> 为<strong>最小横坐标比例、最小纵坐标比例、最大横坐标比例、最大纵坐标比例</strong></p>
</li>
<li><p>求 <code>grid_shapes</code> ,  <code>grid_shapes</code> 表示每个输出的特征图的两个方向各自分布多少网格。对于最终输出的特诊图而言，特征图上的一个点对应原图的一个区域，这个区域被称为网格，所以可以理解为这个变量表示的是输出的每个特征图的宽和高，经典 YOLO3 输出三个特征图，每个特征图大小别为原图宽高分别除 32、原图宽高分别除 16 、原图宽高分别除 8，最终 <code>grid_shapes</code> 的结构是 np 数组的列表：<br>  <code>[np.array([f1_w,f1_h]),np.array([f2_w,f2_h]),np.array([f3_w,f3_h])]</code> ，其中 <code>f1_w,f1_h</code> 表示最终输出的特征图里第一个特征图的宽和高。</p>
</li>
<li><p>创建 <code>y_true</code> ，此时只是先把 <code>y_true</code> 的结构定下来，其值用 0 填充，具体数值后面再填，<code>y_true</code> 的结构也是 np 数组的列表 ，它的结构为 <code>[y_true_1,y_true_2,y_true_3]</code> 。其中 <code>y_true_*</code> 是 np 数组，表示一个特征图中包含的真实信息，它的<code>shape=(批数,特征图高,特征图宽,3,5+类别数)</code></p>
</li>
<li><p>之后的代码是针对每批数据而言，故之后的代码 <strong>假设处理下标为 <code>b</code> 的一批数据</strong></p>
</li>
<li><p>对 <code>b</code>  批数据的对每个盒子对预设的锚框进行 IOU 运算，这里是假设中心点重合的 IOU，最终目的是求 <code>best_anchor</code> 。<code>best_anchor</code> 表示对于每个盒子而言，参数 <code>anchors</code> 里的哪个锚框和这个盒子重合度最高，它的 <code>shape=(valid_boxes_number,)</code> ，即长度为<code>valid_boxes_number</code> 的向量，其中 <code>valid_boxes_number</code> 为有效盒子数，有效盒子被定义为宽度大于 0 的盒子。</p>
<blockquote>
<p>这里的实现有个细节，就是 <code>anchors</code> 被扩充维度成 <code>shape=(1,k,2)</code> 而<code>wh</code>被扩充维度为 <code>shape=(boxes_number,1,2)</code> 所以最终他们的运算结果由 <code>broadcasting</code> 变成 <code>shape=(boxes_number,k,2)</code></p>
</blockquote>
</li>
<li><p>之后是一个二层循环，分别表示遍历<code>best_anchor</code>，遍历每个输出特征图，变量 <code>b,t,n,l</code>  都是索引号，分别表示：<strong>第 b 号批  、第 t 号盒子 、第t 号盒子的最大重合 anchor 索引号为 n 、第 l 号特征图</strong></p>
</li>
<li><p>如果第 t 号盒子的最大索引号 n，在第 l 号特征图的锚框掩码中，则说明，第l 号特征图内有锚框负责这个盒子，此时：</p>
<ul>
<li><p>令 <code>i</code> 等于第 b 号批里第 t 号盒子的最大横坐标比例*第 l 号特征图的宽，并向下取整</p>
</li>
<li><p>令 <code>j</code> 等于第 b 号批里第 t 号盒子的最小纵坐标比例*第 l 号特征图的高，并向下取整</p>
<blockquote>
<p>此时 <code>j,i</code> 表示第 l 号特征图中，负责这个物体的网格坐标。</p>
</blockquote>
</li>
<li><p>令 <code>k</code> 等于第 n 号锚框在第 l 号特征的索引号，<code>k</code> 只能取 0,1,2</p>
</li>
<li><p>令 <code>c</code> 等于第 b 号批里第 t 号盒子的类别号</p>
</li>
<li><p>最后填充，第 l 号特征图中的，第 b 号批数据里，第 j 行 、第 i 列，第 k 号锚框，使其坐标信息等于 b 号批里第 t 号盒子的坐标信息、置信度等于 1、类别信息等于 c （即令 <code>y_true[l][..,5+c] = 1</code> )</p>
</li>
</ul>
</li>
<li><p>上述过程把 <code>y_true</code> 该填的完，负责物体的锚框有对应值，不负责物体的锚框的值为 0，最后强调，<code>y_true</code> 是一个三元素列表，每个元素的 <code>shape=(批数,特征图高,特征图宽,3,5+类别数)</code> ，每个元素的元素可视为长度为 <code>5+类别数</code> 的特征向量，特征向量中的位置信息是<strong>相对于原图</strong>的最小横坐标比例、最小纵坐标比例、最大横坐标比例、最大纵坐标比例。</p>
</li>
</ul>
<h4 id="实现函数-1"><a href="#实现函数-1" class="headerlink" title="实现函数"></a>实现函数</h4><p>训练数据是由 <code>data_generator_wrapper</code> 生成：</p>
<h5 id="data-generator-wrapper"><a href="#data-generator-wrapper" class="headerlink" title="data_generator_wrapper"></a><code>data_generator_wrapper</code></h5><pre><code class="lang-python">data_generator_wrapper(annotation_lines, batch_size, input_shape, anchors, num_classes):
    n = len(annotation_lines)
    if n==0 or batch_size&lt;=0: return None
    return data_generator(annotation_lines, batch_size, input_shape, anchors, num_classes)
</code></pre>
<p>参数：</p>
<ul>
<li><strong>annotation_lines</strong>：yolo3 标注文件的行数，也就是总训练样本数</li>
<li><strong>batch_size</strong> ：批大小</li>
<li><strong>input_shape</strong> ：二维元组，输入张量的形状，要求32的倍数，YOLO3 设置为 (416,416)</li>
<li><strong>anchors</strong> ：锚框列表，<code>get_anchors</code> 函数得到，形如<code>[[w1,h1],[w2,h2]...]</code></li>
<li><strong>num_classes</strong> ：类别数目，由 <code>len(get_classes(classes_path))</code> 得到</li>
</ul>
<p><code>data_generator_wrapper</code> 只是对参数进行简单的检验，最终数据由 <code>data_generator</code> 生成</p>
<h5 id="data-generator"><a href="#data-generator" class="headerlink" title="data_generator"></a><code>data_generator</code></h5><pre><code class="lang-python">def data_generator(annotation_lines, batch_size, input_shape, anchors, num_classes):
    &#39;&#39;&#39;data generator for fit_generator&#39;&#39;&#39;
    n = len(annotation_lines)
    i = 0
    while True:
        image_data = []
        box_data = []
        for b in range(batch_size):
            if i==0:
                np.random.shuffle(annotation_lines)
            image, box = get_random_data(annotation_lines[i], input_shape, random=True)
            image_data.append(image)
            box_data.append(box)
            i = (i+1) % n
        image_data = np.array(image_data)
        box_data = np.array(box_data)
        y_true = preprocess_true_boxes(box_data, input_shape, anchors, num_classes)
        yield [image_data, *y_true], np.zeros(batch_size)
</code></pre>
<p><code>data_generator</code> 是一个生成器，所以用 <code>yield</code> 替代 <code>return</code> ，这生成器直接作用于 <code>model.fit_generator</code> ，所以生成器生成的数据，就是每一<code>epoch</code> 训练的数据。</p>
<p>生成器的参数和 <code>data_generator_wrapper</code> 参数一致。</p>
<p><code>model.fit_generator</code> 要求 <code>data_generator</code>  返回一个下面任意一个元组：</p>
<ul>
<li>a tuple <code>(inputs, targets)</code></li>
<li>a tuple <code>(inputs, targets, sample_weights)</code></li>
</ul>
<p>这里 <code>data_generator</code>   返回的是 <code>(inputs, targets)</code> 它的 inputs 是 <code>[image_data, *y_true]</code> , 它的 targets 是长为 <code>batch_size</code> 的全 0 向量。</p>
<p>执行过程：</p>
<ul>
<li>统计样本总数 <code>n = len(annotation_lines)</code> , 设置计数变量 <code>i = 0</code> </li>
<li>通过 while-yield 结构设计生成器 </li>
<li>每次生成数据的时候 , 执行 <code>batch_size</code> 次循环<ul>
<li>如果 <code>i==0</code> 说明第一次生成数据 , 或者所有样本都已经被生成一遍了 , 此时用 <code>np.random.shuffle(annotation_lines)</code> 将样本打乱</li>
<li>通过 <code>get_random_data(annotation_lines[i], input_shape, random=True)</code> 获得第 i 个样本的图片信息和图片上的盒子信息 <code>image, box</code></li>
<li>将图片信息和标注信息分布追加到<code>image_data, box_data</code></li>
<li><code>i = (i+1) % n</code> 表示该读下一个样本了</li>
</ul>
</li>
<li>将 <code>image_data, box_data</code> 包装为 np 数据</li>
<li>通过 <code>preprocess_true_boxes(box_data, input_shape, anchors, num_classes)</code> 由盒子信息获取 loss 函数所需的目标信息 <code>y_true</code></li>
<li>返回 <code>[image_data, *y_true], np.zeros(batch_size)</code></li>
</ul>
</div><div class="article-tags size-small is-uppercase mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/YOLO3/">YOLO3</a><a class="link-muted mr-2" rel="tag" href="/tags/Keras/">Keras</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/04/04/YOLO3%20%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">YOLO3 网络结构 Keras源码分析</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/04/04/YOLO3%20%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><span class="level-item">YOLO3 目标检测与性能评价 Keras源码分析</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="" src="/img/LOGO.jpg" alt="刘之帅"></figure><p class="title is-size-4 is-block line-height-inherit">刘之帅</p><p class="is-size-6 is-block">LogicForeach</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>LiaoNing</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">2</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/LogicForeach/" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/LogicForeach/"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Web" href="https://logicforeach.net"><i class="fab fa-internet-explorer"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/YOLO3-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><span class="level-start"><span class="level-item">YOLO3 源码分析</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-04T11:00:09.966Z">2020-04-04</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/04/YOLO3%20%E5%8F%82%E6%95%B0%E5%AD%A6%E4%B9%A0%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">YOLO3 参数学习 Keras源码分析</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/YOLO3-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">YOLO3 源码分析</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-04T11:00:08.849Z">2020-04-04</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/04/YOLO3%20%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">YOLO3 网络结构 Keras源码分析</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/YOLO3-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">YOLO3 源码分析</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-04T11:00:08.811Z">2020-04-04</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/04/YOLO3%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">YOLO3 数据处理与数据加载 Keras源码分析</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/YOLO3-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">YOLO3 源码分析</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-04T10:37:51.338Z">2020-04-04</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/04/YOLO3%20%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">YOLO3 目标检测与性能评价 Keras源码分析</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/YOLO3-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">YOLO3 源码分析</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Keras/"><span class="tag">Keras</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/YOLO3/"><span class="tag">YOLO3</span><span class="tag is-grey-lightest">4</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/LOGO.jpg" alt="LogicForeach" height="28"></a><p class="size-small"><span>&copy; 2020 刘之帅</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://yoursite.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><script>window.addEventListener("load", function () {
            MathJax.Hub.Config({
                'HTML-CSS': {
                    matchFontHeight: false
                },
                SVG: {
                    matchFontHeight: false
                },
                CommonHTML: {
                    matchFontHeight: false
                },
                tex2jax: {
                    inlineMath: [
                        ['$','$'],
                        ['\\(','\\)']
                    ]
                }
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>