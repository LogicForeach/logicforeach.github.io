<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/favicon.png" color="#222">
  <meta name="baidu-site-verification" content="zslje0YHHp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"logicforeach.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="YOLO3 Keras 源码：https:&#x2F;&#x2F;github.com&#x2F;qqwweee&#x2F;keras-yolo3 前言本文从主要是从源码层面对 YOLO3 的数据处理相关内容进行分析与讲解。通常，一个功能的实现需要多个函数配合，所以我将每个功能的实现函数分为两部分，基础函数 和 实现函数 ：  基础函数：被实现函数所依赖，是实现函数的一部分 实现函数：通过调用基础函数实现功能  源码内容比较多，通过目录">
<meta property="og:type" content="article">
<meta property="og:title" content="YOLO3 数据处理与数据加载 Keras源码分析">
<meta property="og:url" content="logicforeach.github.io/2020/04/04/YOLO3%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="LogicForeach">
<meta property="og:description" content="YOLO3 Keras 源码：https:&#x2F;&#x2F;github.com&#x2F;qqwweee&#x2F;keras-yolo3 前言本文从主要是从源码层面对 YOLO3 的数据处理相关内容进行分析与讲解。通常，一个功能的实现需要多个函数配合，所以我将每个功能的实现函数分为两部分，基础函数 和 实现函数 ：  基础函数：被实现函数所依赖，是实现函数的一部分 实现函数：通过调用基础函数实现功能  源码内容比较多，通过目录">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="/2020/04/04/YOLO3%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/20200322031027706.png">
<meta property="article:published_time" content="2020-04-04T11:00:08.811Z">
<meta property="article:modified_time" content="2020-04-14T08:20:00.789Z">
<meta property="article:author" content="刘之帅">
<meta property="article:tag" content="YOLO3">
<meta property="article:tag" content="Keras">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="/2020/04/04/YOLO3%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/20200322031027706.png">

<link rel="canonical" href="logicforeach.github.io/2020/04/04/YOLO3%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>YOLO3 数据处理与数据加载 Keras源码分析 | LogicForeach</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LogicForeach</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">刘之帅的个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="logicforeach.github.io/2020/04/04/YOLO3%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/LOGO.jpg">
      <meta itemprop="name" content="刘之帅">
      <meta itemprop="description" content="正在积极接受治疗的重度懒癌患者……">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LogicForeach">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          YOLO3 数据处理与数据加载 Keras源码分析<a href="https://github.com/LogicForeach/blog/tree/master/source/_posts/YOLO3%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pencil"></i></a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-04 19:00:08" itemprop="dateCreated datePublished" datetime="2020-04-04T19:00:08+08:00">2020-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-14 16:20:00" itemprop="dateModified" datetime="2020-04-14T16:20:00+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/YOLO3-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">YOLO3 源码分析</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>YOLO3 Keras 源码：<a href="https://github.com/qqwweee/keras-yolo3" target="_blank" rel="noopener">https://github.com/qqwweee/keras-yolo3</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文从主要是从源码层面对 YOLO3 的数据处理相关内容进行分析与讲解。通常，一个功能的实现需要多个函数配合，所以我将每个功能的实现函数分为两部分，<strong>基础函数</strong> 和 <strong>实现函数</strong> ：</p>
<ul>
<li>基础函数：被实现函数所依赖，是实现函数的一部分</li>
<li>实现函数：通过调用基础函数实现功能</li>
</ul>
<p>源码内容比较多，通过目录索引看感兴趣的地方即可。</p>
<h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><h3 id="数据集转换"><a href="#数据集转换" class="headerlink" title="数据集转换"></a>数据集转换</h3><p>YOLO3 Keras 源码所需要的数据集应该在一个<code>.txt</code> ( 文本文件 )内，文件中的一行代表一个张图片和它的标签，其中每行的格式为：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">image_file_path</span> <span class="keyword">box1 </span><span class="keyword">box2 </span>... <span class="keyword">boxN</span></span><br></pre></td></tr></table></figure>
<p><code>box*</code> 是该图片的标签，即真实框，不同box之间用空格隔开，其中每个box的格式为</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"><span class="built_in">x_min,</span>y_min,x_max,y_max,class_id</span><br></pre></td></tr></table></figure>
<p>所以总的来说，训练用的数据集应该大体是这个样子的：</p>
<a id="more"></a>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">path/to/img1.jpg <span class="number">50</span>,<span class="number">100</span>,<span class="number">150</span>,<span class="number">200</span>,<span class="number">0</span> <span class="number">30</span>,<span class="number">50</span>,<span class="number">200</span>,<span class="number">120</span>,<span class="number">3</span></span><br><span class="line">path/to/img2.jpg <span class="number">120</span>,<span class="number">300</span>,<span class="number">250</span>,<span class="number">600</span>,<span class="number">2</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>对于 VOC 数据集，Keras 源码的作者给出了脚本 <code>voc_annotation.py</code> 可以将 VOC 数据集转化成上述格式。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> getcwd</span><br><span class="line"></span><br><span class="line">sets=[(<span class="string">'2007'</span>, <span class="string">'train'</span>), (<span class="string">'2007'</span>, <span class="string">'val'</span>), (<span class="string">'2007'</span>, <span class="string">'test'</span>)]</span><br><span class="line"></span><br><span class="line">classes = [<span class="string">"aeroplane"</span>, <span class="string">"bicycle"</span>, <span class="string">"bird"</span>, <span class="string">"boat"</span>, <span class="string">"bottle"</span>, <span class="string">"bus"</span>, <span class="string">"car"</span>, <span class="string">"cat"</span>, <span class="string">"chair"</span>, <span class="string">"cow"</span>, <span class="string">"diningtable"</span>, <span class="string">"dog"</span>, <span class="string">"horse"</span>, <span class="string">"motorbike"</span>, <span class="string">"person"</span>, <span class="string">"pottedplant"</span>, <span class="string">"sheep"</span>, <span class="string">"sofa"</span>, <span class="string">"train"</span>, <span class="string">"tvmonitor"</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_annotation</span><span class="params">(year, image_id, list_file)</span>:</span></span><br><span class="line">    in_file = open(<span class="string">'VOCdevkit/VOC%s/Annotations/%s.xml'</span>%(year, image_id))</span><br><span class="line">    tree=ET.parse(in_file)</span><br><span class="line">    root = tree.getroot()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> root.iter(<span class="string">'object'</span>):</span><br><span class="line">        difficult = obj.find(<span class="string">'difficult'</span>).text</span><br><span class="line">        cls = obj.find(<span class="string">'name'</span>).text</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> classes <span class="keyword">or</span> int(difficult)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        cls_id = classes.index(cls)</span><br><span class="line">        xmlbox = obj.find(<span class="string">'bndbox'</span>)</span><br><span class="line">        b = (int(xmlbox.find(<span class="string">'xmin'</span>).text), int(xmlbox.find(<span class="string">'ymin'</span>).text), int(xmlbox.find(<span class="string">'xmax'</span>).text), int(xmlbox.find(<span class="string">'ymax'</span>).text))</span><br><span class="line">        list_file.write(<span class="string">" "</span> + <span class="string">","</span>.join([str(a) <span class="keyword">for</span> a <span class="keyword">in</span> b]) + <span class="string">','</span> + str(cls_id))</span><br><span class="line"></span><br><span class="line">wd = getcwd()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> year, image_set <span class="keyword">in</span> sets:</span><br><span class="line">    image_ids = open(<span class="string">'VOCdevkit/VOC%s/ImageSets/Main/%s.txt'</span>%(year, image_set)).read().strip().split()</span><br><span class="line">    list_file = open(<span class="string">'%s_%s.txt'</span>%(year, image_set), <span class="string">'w'</span>)</span><br><span class="line">    <span class="keyword">for</span> image_id <span class="keyword">in</span> image_ids:</span><br><span class="line">        list_file.write(<span class="string">'%s/VOCdevkit/VOC%s/JPEGImages/%s.jpg'</span>%(wd, year, image_id))</span><br><span class="line">        convert_annotation(year, image_id, list_file)</span><br><span class="line">        list_file.write(<span class="string">'\n'</span>)</span><br><span class="line">    list_file.close()</span><br></pre></td></tr></table></figure>
<h4 id="基础函数："><a href="#基础函数：" class="headerlink" title="基础函数："></a>基础函数：</h4><h5 id="convert-annotation-year-image-id-list-file"><a href="#convert-annotation-year-image-id-list-file" class="headerlink" title="convert_annotation(year, image_id, list_file)"></a><code>convert_annotation(year, image_id, list_file)</code></h5><p>参数：</p>
<ul>
<li><strong>year</strong>：整型，年代 , VOC2007 的 2007 </li>
<li><strong>image_id</strong> ：图像序号</li>
<li><strong>list_file</strong> ： 文件对象</li>
</ul>
<p>功能：</p>
<ul>
<li>通过 <code>year</code> 和 <code>image_id</code>找到 VOC 数据集里的 xml 文件，通过 ElementTree 找到这个 XML 里的每一个 <code>object</code> 标签，获取该标签内的 <code>xmin,ymin,xmax,ymax</code>，和列表序号<code>class_id</code> ，把它们写入到 list_file 所打开的文件对象中。</li>
<li>总之，这个函数是在将 <code>.xml</code> 中的标注信息转化为 YOLO3 所需要标注格式，并写入文件。</li>
</ul>
<h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><h5 id="脚本主内容"><a href="#脚本主内容" class="headerlink" title="脚本主内容"></a>脚本主内容</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> year, image_set <span class="keyword">in</span> sets:</span><br><span class="line">    image_ids = open(<span class="string">'VOCdevkit/VOC%s/ImageSets/Main/%s.txt'</span>%(year, image_set)).read().strip().split()</span><br><span class="line">    list_file = open(<span class="string">'%s_%s.txt'</span>%(year, image_set), <span class="string">'w'</span>)</span><br><span class="line">    <span class="keyword">for</span> image_id <span class="keyword">in</span> image_ids:</span><br><span class="line">        list_file.write(<span class="string">'%s/VOCdevkit/VOC%s/JPEGImages/%s.jpg'</span>%(wd, year, image_id))</span><br><span class="line">        convert_annotation(year, image_id, list_file)</span><br><span class="line">        list_file.write(<span class="string">'\n'</span>)</span><br><span class="line">    list_file.close()</span><br></pre></td></tr></table></figure>
<p><code>year, image_set</code> 是从 <code>sets</code> 提取而来，这个 for 循环的目的是操作 <code>sets</code> 中对应的每一个文件。</p>
<p>即打开<code>train.txt</code> 、<code>val.txt</code> 、<code>test.txt</code> ，它们里面内容长这个样：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">1000</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>这其中每一行都是图片的序号。</p>
<p>如打开<code>train.txt</code> ，脚本通过 <code>.read().strip().split()</code> ，把 <code>train.txt</code> 中一行一行的图片序号变成一个列表 <code>image_ids</code> ，创建一个文件对象 <code>list_file</code> 随后对列表内每一个元素进行操作：</p>
<ul>
<li>根据文件路径和图片序号的映射关系，把图片路劲写入到 <code>list_file</code>  文件对象对应的文件中。</li>
<li>通过 <code>convert_annotation</code> 把图片的标注信息（已转化为 YOLO3 所需格式），紧接着路径信息写在后面</li>
<li>写入换行符</li>
</ul>
<p>所以元素操作完事，关闭文件对象。</p>
<p>通过上述流程对 <code>train.txt</code> 、<code>val.txt</code> 、<code>test.txt</code> 都操作完，就把 VOC 数据集转化为 YOLO3 所需要的格式了。</p>
<h3 id="使用-K-means-生成锚框"><a href="#使用-K-means-生成锚框" class="headerlink" title="使用 K-means 生成锚框"></a>使用 K-means 生成锚框</h3><p>YOLO2 开始，锚框的生成使用 K-means 算法，这种倚靠训练数据自动生成的锚框，比人为设定的锚框更加符合特定场景的业务需求，所以会提高模型的准确度。</p>
<p>介绍 K-means 之前，需要先了解它是用于什么学习任务的，K-means 是解决聚类问题的一个算法。</p>
<h4 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h4><p><strong>聚类和簇</strong></p>
<p>聚类任务是一种无监督学习任务，聚类试图将样本划分为若干个不相交的子集，每个子集成为<strong>簇</strong>，通过这样的划分，每个簇对应一个潜在类别，具体是什么类别，对于聚类算法而言是未知，都是在聚类结束后，人为的判断一个簇对应的什么类别。聚类常用于寻找数据内部的分布结构，或用于对其他分类学习任务进行粗略的预先处理。比如自从 YOLO2 后，聚类算法就被用于预先为图像划定锚框。</p>
<p><strong>距离计算</strong></p>
<p>聚类任务说到底是让”簇内相似度高“且”簇间相似度低“，那么就需要一个衡量相似度的指标，两个样本间的距离可以反映样本之间的相似度，所以定义 $dist(\cdot,\cdot)$ 为两个样本的距离。距离的计算有诸多算法，比如“闵可夫斯基距离”</p>
<script type="math/tex; mode=display">
dist_{mk}(x_i,x_j)=(\sum_{u=1}^n|x_{i,u}-x_{j,x}|^p)^{\frac{1}{p}}</script><p>在 YOLO2 和 YOLO3 中，距离计算是借助两个 box 的 IOU：</p>
<script type="math/tex; mode=display">
dist(b_i,b_j)=1-IOU(b_i,b_j)</script><p><strong>K-means 算法</strong></p>
<p>K-means 的思想是，对所划分的所有簇 $C=\{C_1,C_2,\dots,C_k\}$ 使</p>
<script type="math/tex; mode=display">
E=\sum_{i=1}^k\sum_{x\in C_i}dist(x,\mu_i)</script><p>最小，其中 $\mu_i=\frac{1}{|C_i|}\sum_{x\in C_i}x$ ，即 $\mu_i$ 是 $C_i$ 的均指向量。</p>
<p>为了达到这个目的，K-means 采用贪心策略，最开始随机指定 K 个向量作为 $(\mu_1,\dots,\mu_k)$ 对于每一个 $\mu_i$ ，计算每一个向量 $x$ 与 $\mu_i$ 的距离，即 $dist(x,\mu_i)$ 将距离值最小的向量，归到 $C_i$ 然后更新  $\mu_i$ ，重复这个过程，直到 $(\mu_1,\dots,\mu_k)$ 都不再更新。</p>
<p><img src="/2020/04/04/YOLO3%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/20200322031027706.png" alt></p>
<h4 id="基础函数"><a href="#基础函数" class="headerlink" title="基础函数"></a>基础函数</h4><h5 id="YOLO-Kmeans-init"><a href="#YOLO-Kmeans-init" class="headerlink" title="YOLO_Kmeans.__init__"></a><code>YOLO_Kmeans.__init__</code></h5><p><code>YOLO_Kmeans</code> 是一个类，它的初始化函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, cluster_number, filename)</span>:</span></span><br><span class="line">    self.cluster_number = cluster_number</span><br><span class="line">    self.filename = filename</span><br></pre></td></tr></table></figure>
<p>其作用仅是将参数保留到类内</p>
<h5 id="YOLO-Kmeans-txt2boxes"><a href="#YOLO-Kmeans-txt2boxes" class="headerlink" title="YOLO_Kmeans.txt2boxes"></a><code>YOLO_Kmeans.txt2boxes</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">txt2boxes</span><span class="params">(self)</span>:</span></span><br><span class="line">    f = open(self.filename, <span class="string">'r'</span>)</span><br><span class="line">    dataSet = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        infos = line.split(<span class="string">" "</span>)</span><br><span class="line">        length = len(infos)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length):</span><br><span class="line">            width = int(infos[i].split(<span class="string">","</span>)[<span class="number">2</span>]) - \</span><br><span class="line">                int(infos[i].split(<span class="string">","</span>)[<span class="number">0</span>])</span><br><span class="line">            height = int(infos[i].split(<span class="string">","</span>)[<span class="number">3</span>]) - \</span><br><span class="line">                int(infos[i].split(<span class="string">","</span>)[<span class="number">1</span>])</span><br><span class="line">            dataSet.append([width, height])</span><br><span class="line">    result = np.array(dataSet)</span><br><span class="line">    f.close()</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>该方法的作用是将 YOLO 标注文件内的 box 信息转化为列表</p>
<p>YOLO 标注文件格式如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">path/to/img1.jpg <span class="number">50</span>,<span class="number">100</span>,<span class="number">150</span>,<span class="number">200</span>,<span class="number">0</span> <span class="number">30</span>,<span class="number">50</span>,<span class="number">200</span>,<span class="number">120</span>,<span class="number">3</span></span><br><span class="line">path/to/img2.jpg <span class="number">120</span>,<span class="number">300</span>,<span class="number">250</span>,<span class="number">600</span>,<span class="number">2</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>f</code> 是一个文件对象，文件对象可迭代，每次读取文件的一行，最外层的 for 是指对文件内的每一行操作。</p>
<p>对文件内的每一行，以空格为分隔符，将其划分为列表 <code>infos</code> ：</p>
<p>对 <code>infos[1]</code> 到 <code>infors[length-1]</code> 中的每一个元素 <code>infos[i]</code> 而言，每一个 <code>infos[i]</code> 代表一组 box 信息。<code>infos[i].split(&quot;,&quot;)[0]</code> 、<code>infos[i].split(&quot;,&quot;)[1]</code> 、<code>infos[i].split(&quot;,&quot;)[2]</code> 、<code>infos[i].split(&quot;,&quot;)[3]</code>   、<code>infos[i].split(&quot;,&quot;)[4]</code>分别对应 box 信息里的 <code>x_min,y_min,x_max,y_max,class_id</code> ，由这些信息就可以计算出 box 的宽和高，记为<code>[width, height]</code> ，将每组 box 的 <code>[width, height]</code> 追加到 <code>dataSet</code> 列表内，将 <code>dataSet</code>  转化为 <code>np.array</code> 并返回。</p>
<h5 id="YOLO-Kmeans-iou"><a href="#YOLO-Kmeans-iou" class="headerlink" title="YOLO_Kmeans.iou"></a><code>YOLO_Kmeans.iou</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iou</span><span class="params">(self, boxes, clusters)</span>:</span>  <span class="comment"># 1 box -&gt; k clusters</span></span><br><span class="line">    n = boxes.shape[<span class="number">0</span>]</span><br><span class="line">    k = self.cluster_number</span><br><span class="line"></span><br><span class="line">    box_area = boxes[:, <span class="number">0</span>] * boxes[:, <span class="number">1</span>]</span><br><span class="line">    box_area = box_area.repeat(k)</span><br><span class="line">    box_area = np.reshape(box_area, (n, k))</span><br><span class="line"></span><br><span class="line">    cluster_area = clusters[:, <span class="number">0</span>] * clusters[:, <span class="number">1</span>]</span><br><span class="line">    cluster_area = np.tile(cluster_area, [<span class="number">1</span>, n])</span><br><span class="line">    cluster_area = np.reshape(cluster_area, (n, k))</span><br><span class="line"></span><br><span class="line">    box_w_matrix = np.reshape(boxes[:, <span class="number">0</span>].repeat(k), (n, k))</span><br><span class="line">    cluster_w_matrix = np.reshape(np.tile(clusters[:, <span class="number">0</span>], (<span class="number">1</span>, n)), (n, k))</span><br><span class="line">    min_w_matrix = np.minimum(cluster_w_matrix, box_w_matrix)</span><br><span class="line"></span><br><span class="line">    box_h_matrix = np.reshape(boxes[:, <span class="number">1</span>].repeat(k), (n, k))</span><br><span class="line">    cluster_h_matrix = np.reshape(np.tile(clusters[:, <span class="number">1</span>], (<span class="number">1</span>, n)), (n, k))</span><br><span class="line">    min_h_matrix = np.minimum(cluster_h_matrix, box_h_matrix)</span><br><span class="line">    inter_area = np.multiply(min_w_matrix, min_h_matrix)</span><br><span class="line"></span><br><span class="line">    result = inter_area / (box_area + cluster_area - inter_area)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>boxes ： 盒子信息，结构为<code>[[w1,h1],[w2,h2]...]</code></li>
<li>clusters：簇点信息，内含 k 个 <code>[w,h]</code> 结构为 <code>[[w1,h1],...,[wk,hk]]</code></li>
</ul>
<p>执行过程：</p>
<ul>
<li>求每个盒子的面积，重复 k 次，得到 n*k 矩阵 <code>box_area</code> , n 是总盒子数，k 是簇数</li>
<li>求每个簇点的面积，所有簇点面积集合记为 <code>cluster_area</code> , 一开始，<code>cluster_area</code> 是 <code>shape=(1,k)</code> 的 np 数组，经过 <code>np.tile</code> 变成 <code>shape=(1,k*n)</code>，<code>np.reshape</code> 成 <code>shape=(n,k)</code></li>
<li>用相似的维度变化，求盒子的 w 矩阵 <code>box_w_matrix</code>，与簇点的 w 矩阵 <code>cluster_w_matrix</code> ，用 <code>np.minimum</code> 取宽最小矩阵 <code>min_w_matrix</code></li>
<li>同理求高最小矩阵 <code>min_h_matrix</code></li>
<li>盒子与簇在假设左上角对齐的情况下，最小的宽*最小的高就是他们相交的区域的面积，相交面积 <code>inter_area = np.multiply(min_w_matrix, min_h_matrix)</code></li>
<li>最终返回 IOU 值 IOU = 相交面积/相并面积 = 相交面积/( 盒子面积 + 簇点面积 - 相交面积 )，最红返回的 result 的形状 <code>shape=(n,k)</code></li>
</ul>
<h5 id="YOLO-Kmeans-kmeans"><a href="#YOLO-Kmeans-kmeans" class="headerlink" title="YOLO_Kmeans.kmeans"></a><code>YOLO_Kmeans.kmeans</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kmeans</span><span class="params">(self, boxes, k, dist=np.median)</span>:</span></span><br><span class="line">    box_number = boxes.shape[<span class="number">0</span>]</span><br><span class="line">    distances = np.empty((box_number, k))</span><br><span class="line">    last_nearest = np.zeros((box_number,))</span><br><span class="line">    np.random.seed()</span><br><span class="line">    clusters = boxes[np.random.choice(</span><br><span class="line">        box_number, k, replace=<span class="literal">False</span>)]  <span class="comment"># init k clusters</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">        distances = <span class="number">1</span> - self.iou(boxes, clusters)</span><br><span class="line"></span><br><span class="line">        current_nearest = np.argmin(distances, axis=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (last_nearest == current_nearest).all():</span><br><span class="line">            <span class="keyword">break</span>  <span class="comment"># clusters won't change</span></span><br><span class="line">        <span class="keyword">for</span> cluster <span class="keyword">in</span> range(k):</span><br><span class="line">            clusters[cluster] = dist(  <span class="comment"># update clusters</span></span><br><span class="line">                boxes[current_nearest == cluster], axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        last_nearest = current_nearest</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clusters</span><br></pre></td></tr></table></figure>
<p>参数 :</p>
<ul>
<li>boxes : 前面通过 <code>txt2boxes</code> 处理后得到的 np 数组，结构为<code>[[w1,h1],[w2,h2]...]</code></li>
<li>k : 整型，簇数</li>
<li>dist : 均值向量生成策略，这里用的中位数（那应该叫中位数向量hhhh）</li>
</ul>
<p>执行过程：</p>
<ul>
<li><p>得到 <code>boxes</code> 中的盒子数 <code>box_number</code>，用 <code>np.empty</code> 创建一个 <code>shape=(box_number, k)</code> 的空 np 数组 <code>distances</code>，用储存 boxes 中的每个盒子和每个簇的距离；用 <code>np.zeros</code> 创建一个长度为 <code>box_number</code> 的一维全零 np 数组，用于存储每个盒子距离最近的簇的索引值。</p>
</li>
<li><p>通过 <code>clusters = boxes[np.random.choice(box_number, k, replace=False)]</code> 从 <code>boxes</code>  中随机进行不放回抽样，选出 k 个 盒子信息作为初始的簇点。</p>
<p>  这里采用的是高级索引，<code>boxes[[1,2,3]]==[boxes[1],boxes[2],boxes[3]]</code> ，<code>numpy.random.choice(a, size=None, replace=True, p=None)</code> 它的参数从左到右依次表示候选列表、抽烟个数、是否放回、列表中各元素被抽中的概率。</p>
</li>
<li><p>进行循环直到 break 才终止：</p>
<ul>
<li><p>计算boxes 中的每个盒子和每个簇的距离，结果存放入 <code>distances</code>， <code>self.iou(boxes, clusters)</code> 后面讲解。</p>
</li>
<li><p>通过 <code>np.argmin(distances, axis=1)</code> 返回每个盒子距离最近的簇的索引值，结果存入<code>current_nearest</code>；<code>np.argmin(a, axis=None, out=None)</code> 可以沿 <code>axis</code>轴，在数组 <code>a</code> 中寻找最小值，并返回该值在 <code>axis</code> 轴内的索引。</p>
</li>
<li><p>如果上一轮循环中每个盒子距离最近的簇的索引 <code>last_nearest</code> 和这一轮的 <code>current_nearest</code>  中每一个元素都相同，那么说明算法已经收敛，跳出循环。</p>
<p>  其中 <code>last_nearest == current_nearest</code> 由于双等号两边都是同型 np 数组，所以这个表达式返回的也是同型 np 数组，数组内元素类型是布尔型，表示对应元素是否相同，<code>np.np.array.all()</code> 表示若数组内元素都为 True 则返回 True，否则返回 False</p>
</li>
<li><p>如果存在不同元素，就对 K 个簇点进行遍历， 让每个簇点等于该簇内向量的中位数。</p>
<p>  通过<code>boxes[current_nearest == cluster]</code> 找出所有”相对于其他簇点，与第<code>cluster</code> 个簇距离最近”的盒子，得到一个列表，列表结构为<code>[[w1,h1],[w2,h2]...]</code></p>
<p>  通过 <code>dist</code> 即 <code>np.median</code> 对上述列表，沿第一个轴求中位数，最终得到结构为<code>[w,h]</code>的一维二元列表。</p>
</li>
<li><p>更新结束，把当前状态 <code>current_nearest</code>  赋值给 <code>last_nearest</code> 开始下一轮循环。</p>
</li>
</ul>
</li>
<li><p>循环结束，将簇点列表 <code>clusters</code> 返回，在 YOLO3 中，各簇点就是预设的锚框信息。</p>
</li>
</ul>
<h5 id="YOLO-Kmeans-txt2clusters"><a href="#YOLO-Kmeans-txt2clusters" class="headerlink" title="YOLO_Kmeans.txt2clusters"></a><code>YOLO_Kmeans.txt2clusters</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">txt2clusters</span><span class="params">(self)</span>:</span></span><br><span class="line">      = self.txt2boxes()</span><br><span class="line">    result = self.kmeans(all_boxes, k=self.cluster_number)</span><br><span class="line">    result = result[np.lexsort(result.T[<span class="number">0</span>, <span class="literal">None</span>])]</span><br><span class="line">    self.result2txt(result)</span><br><span class="line">    print(<span class="string">"K anchors:\n &#123;&#125;"</span>.format(result))</span><br><span class="line">    print(<span class="string">"Accuracy: &#123;:.2f&#125;%"</span>.format(</span><br><span class="line">    self.avg_iou(all_boxes, result) * <span class="number">100</span>))</span><br></pre></td></tr></table></figure>
<p><code>txt2clusters</code> 是脚本的执行函数，求kmeans就是从这个函数入手，这个函数主要过程就是：</p>
<ul>
<li><p><code>txt2boxes</code> 将文本信息划分并提取成列表信息 <code>all_boxes</code> , <code>all_boxes</code> 内各个盒子的信息，结构为 <code>[[w1,h1],[w2,h2]...]</code></p>
</li>
<li><p>使用 <code>kmeans</code> 求盒子列表的聚类，返回的是 k 个簇点，结构也为 <code>[[w1,h1],[w2,h2]...]</code> j结果保存到 <code>result</code></p>
</li>
<li><p>通过 <code>result[np.lexsort(result.T[0, None])]</code> 对 <code>result</code> 进行排序，排序规则是宽度小的在前面</p>
<p>  <code>result.T</code> 会对 <code>result</code> 转置，转置后结构为 <code>[[w1,...,wk],[h1...hk]]</code></p>
<p>  <code>result.T[0,None]</code> 是只取宽度数据，并且扩充一维，变成<code>[[w1,...,wk]]</code></p>
<p>  <code>lexsort(keys, axis=None)</code> ：返回一个整数数组（返回数组的元素是索引值）。<code>keys</code> 是一个序列的序列，要求内部序列形状相同，默认情况外部序列 <code>keys</code> 中的最后一个序列元素将作为主排序序列，倒数第二个序列元素作为第二排序序列….当主排序序列中元素大小相同时，就依照第二排序系列进行排序。</p>
<p>  <code>np.lexsort(result.T[0, None])</code> 输出结果是 <code>w1,...,wk</code> 依照升序排序后的顺序输出原索引值，是有 K 个元素的一维数组</p>
</li>
<li><p>使用 <code>result2txt</code> 将结果输出为文本文件</p>
</li>
<li><p>使用 <code>avg_iou</code> 评价聚类的结果</p>
</li>
</ul>
<h5 id="YOLO-Kmeans-result2txt"><a href="#YOLO-Kmeans-result2txt" class="headerlink" title="YOLO_Kmeans.result2txt"></a><code>YOLO_Kmeans.result2txt</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">result2txt</span><span class="params">(self, data)</span>:</span></span><br><span class="line">    f = open(<span class="string">"yolo_anchors.txt"</span>, <span class="string">'w'</span>)</span><br><span class="line">    row = np.shape(data)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            x_y = <span class="string">"%d,%d"</span> % (data[i][<span class="number">0</span>], data[i][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x_y = <span class="string">", %d,%d"</span> % (data[i][<span class="number">0</span>], data[i][<span class="number">1</span>])</span><br><span class="line">        f.write(x_y)</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>
<p>将每一个簇点信息，写入 <code>yolo_anchors.txt</code> 文件，文件格式是：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">w1</span></span>,h1 w2,h2 ... wk,hk</span><br></pre></td></tr></table></figure>
<h5 id="YOLO-Kmeans-avg-iou"><a href="#YOLO-Kmeans-avg-iou" class="headerlink" title="YOLO_Kmeans.avg_iou"></a><code>YOLO_Kmeans.avg_iou</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">avg_iou</span><span class="params">(self, boxes, clusters)</span>:</span></span><br><span class="line">    accuracy = np.mean([np.max(self.iou(boxes, clusters), axis=<span class="number">1</span>)])</span><br><span class="line">    <span class="keyword">return</span> accuracy</span><br></pre></td></tr></table></figure>
<p>用于评价聚类效果，这里的准确率是 n 个盒子的平均最大交并比。对于每个盒子来说，与盒子 IOU 最大的簇，一定是这个盒子所属的簇，所以 acc 可以理解为是 n 个盒子和它所属的簇的 IOU 的均值。acc 越大，说明簇分布的越好。</p>
<p>具体算法是</p>
<script type="math/tex; mode=display">
Accuracy=\frac{\sum_{i=1}^n IOU_{max}(Box_i)}{n}</script><p>其中，</p>
<script type="math/tex; mode=display">
IOU_{max}(Box_i)=\max_{i}\{ IOU(Box_i,C_j) \}</script><p>即 n 个盒子和 k 个簇进行 IOU 运算，对于每个盒子选择 IOU 最大的值作为代表，最终求 n 个 IOU 的均值作为准确率。</p>
<h4 id="实现函数"><a href="#实现函数" class="headerlink" title="实现函数"></a>实现函数</h4><p>在 <code>\kmeans.py</code> 文件中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    cluster_number = <span class="number">9</span></span><br><span class="line">    filename = <span class="string">"2007_train.txt"</span></span><br><span class="line">    kmeans = YOLO_Kmeans(cluster_number, filename)</span><br><span class="line">    kmeans.txt2clusters()</span><br></pre></td></tr></table></figure>
<p>整体来说，这个脚本干了两件事，一个是求符合 YOLO 要求的 Kmeans，一个是把这个结果保存成文本。</p>
<h2 id="读入数据"><a href="#读入数据" class="headerlink" title="读入数据"></a>读入数据</h2><p>YOLO3 需要将训练数据载入后进行一些处理才能用于训练，这部分代码主要位于 <code>train.py</code> 文件。</p>
<h4 id="基础函数-1"><a href="#基础函数-1" class="headerlink" title="基础函数"></a>基础函数</h4><h5 id="get-random-data"><a href="#get-random-data" class="headerlink" title="get_random_data"></a><code>get_random_data</code></h5><p>在<code>yolo3\utils.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_random_data</span><span class="params">(annotation_line, input_shape, random=True, max_boxes=<span class="number">20</span>, jitter=<span class="number">.3</span>, hue=<span class="number">.1</span>, sat=<span class="number">1.5</span>, val=<span class="number">1.5</span>, proc_img=True)</span>:</span></span><br><span class="line">    <span class="string">'''为实现实时数据增强的随机预处理'''</span></span><br><span class="line">    line = annotation_line.split()</span><br><span class="line">    <span class="comment"># 打开图片</span></span><br><span class="line">    image = Image.open(line[<span class="number">0</span>])</span><br><span class="line">    iw, ih = image.size</span><br><span class="line">    h, w = input_shape</span><br><span class="line">    box = np.array([np.array(list(map(int,box.split(<span class="string">','</span>)))) <span class="keyword">for</span> box <span class="keyword">in</span> line[<span class="number">1</span>:]]) <span class="comment">#box = [[x_min,y_min,x_max,y_max,class_id],..]</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> random:</span><br><span class="line">        <span class="comment"># 调整图像尺寸,使其与input_shape一致</span></span><br><span class="line">        scale = min(w/iw, h/ih)</span><br><span class="line">        nw = int(iw*scale)</span><br><span class="line">        nh = int(ih*scale)</span><br><span class="line">        dx = (w-nw)//<span class="number">2</span></span><br><span class="line">        dy = (h-nh)//<span class="number">2</span></span><br><span class="line">        image_data=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> proc_img:</span><br><span class="line">            image = image.resize((nw,nh), Image.BICUBIC)</span><br><span class="line">            new_image = Image.new(<span class="string">'RGB'</span>, (w,h), (<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>))</span><br><span class="line">            new_image.paste(image, (dx, dy))</span><br><span class="line">            image_data = np.array(new_image)/<span class="number">255.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 修正 boxes</span></span><br><span class="line">        box_data = np.zeros((max_boxes,<span class="number">5</span>))</span><br><span class="line">        <span class="keyword">if</span> len(box)&gt;<span class="number">0</span>:</span><br><span class="line">            np.random.shuffle(box)</span><br><span class="line">            <span class="keyword">if</span> len(box)&gt;max_boxes: box = box[:max_boxes]</span><br><span class="line">            box[:, [<span class="number">0</span>,<span class="number">2</span>]] = box[:, [<span class="number">0</span>,<span class="number">2</span>]]*scale + dx</span><br><span class="line">            box[:, [<span class="number">1</span>,<span class="number">3</span>]] = box[:, [<span class="number">1</span>,<span class="number">3</span>]]*scale + dy</span><br><span class="line">            box_data[:len(box)] = box</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> image_data, box_data</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 随机调整图像长宽比，长宽比改变范围由 jitter 参数控制</span></span><br><span class="line">    new_ar = w/h * rand(<span class="number">1</span>-jitter,<span class="number">1</span>+jitter)/rand(<span class="number">1</span>-jitter,<span class="number">1</span>+jitter)</span><br><span class="line">    <span class="comment">#随机缩放图像，缩放范围为（0.25，2）</span></span><br><span class="line">    scale = rand(<span class="number">.25</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> new_ar &lt; <span class="number">1</span>:</span><br><span class="line">        nh = int(scale*h)</span><br><span class="line">        nw = int(nh*new_ar)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        nw = int(scale*w)</span><br><span class="line">        nh = int(nw/new_ar)</span><br><span class="line">    image = image.resize((nw,nh), Image.BICUBIC)</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="comment"># 图像随机平移</span></span><br><span class="line">    <span class="comment"># 调整图像尺寸,使其与input_shape一致，多的裁掉，少的用灰色填空</span></span><br><span class="line">    dx = int(rand(<span class="number">0</span>, w-nw))</span><br><span class="line">    dy = int(rand(<span class="number">0</span>, h-nh))</span><br><span class="line">    new_image = Image.new(<span class="string">'RGB'</span>, (w,h), (<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>))</span><br><span class="line">    new_image.paste(image, (dx, dy))</span><br><span class="line">    image = new_image</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 随机左右翻转，翻转概率 0.5</span></span><br><span class="line">    flip = rand()&lt;<span class="number">.5</span></span><br><span class="line">    <span class="keyword">if</span> flip: image = image.transpose(Image.FLIP_LEFT_RIGHT)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对图像的色调、饱和度、明度进行随机调整   </span></span><br><span class="line">    hue = rand(-hue, hue)</span><br><span class="line">    sat = rand(<span class="number">1</span>, sat) <span class="keyword">if</span> rand()&lt;<span class="number">.5</span> <span class="keyword">else</span> <span class="number">1</span>/rand(<span class="number">1</span>, sat) </span><br><span class="line">    val = rand(<span class="number">1</span>, val) <span class="keyword">if</span> rand()&lt;<span class="number">.5</span> <span class="keyword">else</span> <span class="number">1</span>/rand(<span class="number">1</span>, val)</span><br><span class="line">    <span class="comment"># HUE 色调; Saturation 饱和度; Value 明度</span></span><br><span class="line">    x = rgb_to_hsv(np.array(image)/<span class="number">255.</span>)</span><br><span class="line">    x[..., <span class="number">0</span>] += hue</span><br><span class="line">    x[..., <span class="number">0</span>][x[..., <span class="number">0</span>]&gt;<span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line">    x[..., <span class="number">0</span>][x[..., <span class="number">0</span>]&lt;<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">    x[..., <span class="number">1</span>] *= sat</span><br><span class="line">    x[..., <span class="number">2</span>] *= val</span><br><span class="line">    x[x&gt;<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    x[x&lt;<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    image_data = hsv_to_rgb(x) <span class="comment"># numpy array, 0 to 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修正盒子信息</span></span><br><span class="line">    box_data = np.zeros((max_boxes,<span class="number">5</span>))</span><br><span class="line">    <span class="keyword">if</span> len(box)&gt;<span class="number">0</span>:</span><br><span class="line">        np.random.shuffle(box)</span><br><span class="line">        <span class="comment"># box 缩放与位移</span></span><br><span class="line">        box[:, [<span class="number">0</span>,<span class="number">2</span>]] = box[:, [<span class="number">0</span>,<span class="number">2</span>]]*nw/iw + dx</span><br><span class="line">        box[:, [<span class="number">1</span>,<span class="number">3</span>]] = box[:, [<span class="number">1</span>,<span class="number">3</span>]]*nh/ih + dy</span><br><span class="line">        <span class="comment"># box 反转</span></span><br><span class="line">        <span class="keyword">if</span> flip: box[:, [<span class="number">0</span>,<span class="number">2</span>]] = w - box[:, [<span class="number">2</span>,<span class="number">0</span>]]</span><br><span class="line">        <span class="comment"># box 截掉超出边界的</span></span><br><span class="line">        box[:, <span class="number">0</span>:<span class="number">2</span>][box[:, <span class="number">0</span>:<span class="number">2</span>]&lt;<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        box[:, <span class="number">2</span>][box[:, <span class="number">2</span>]&gt;w] = w</span><br><span class="line">        box[:, <span class="number">3</span>][box[:, <span class="number">3</span>]&gt;h] = h</span><br><span class="line">        <span class="comment"># box 丢弃过小的</span></span><br><span class="line">        box_w = box[:, <span class="number">2</span>] - box[:, <span class="number">0</span>]</span><br><span class="line">        box_h = box[:, <span class="number">3</span>] - box[:, <span class="number">1</span>]</span><br><span class="line">        box = box[np.logical_and(box_w&gt;<span class="number">1</span>, box_h&gt;<span class="number">1</span>)] <span class="comment"># discard invalid box</span></span><br><span class="line">        <span class="keyword">if</span> len(box)&gt;max_boxes: box = box[:max_boxes]</span><br><span class="line">        box_data[:len(box)] = box</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> image_data, box_data</span><br></pre></td></tr></table></figure>
<p><code>get_random_data</code> 函数用于从 YOLO3 的标注文件生成训练所需的图像信息，同时还提供了对图像的随机数据增强。具体实现看注释吧。</p>
<p>参数：</p>
<ul>
<li><strong>annotation_line</strong>：标注文件中某一行的文本信息，通过这一行文本来获取图片路径和盒子信息。</li>
<li><strong>input_shape</strong>：指网络的输入尺寸，最终图像会被调整到这个尺寸</li>
<li><strong>random=True</strong>：是否开启随机数据增强，默认开启，如果不开启就是单纯的缩放个尺寸</li>
<li><strong>max_boxes=20</strong>：最大盒子数，默认20</li>
<li><strong>jitter=.3</strong>：开启随机数据增强时，这个参数影响长宽比变化范围</li>
<li><strong>hue=.1</strong>：开启随机数据增强时，这个参数影响色调变化范围</li>
<li><strong>sat=1.5</strong>：开启随机数据增强时，这个参数影响饱和度变化范围</li>
<li><strong>val=1.5</strong>：开启随机数据增强时，这个参数影响明度变化范围</li>
<li><strong>proc_img=True</strong>：没整明白存在的意义，True 就完事了</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回一个元组，<code>(image_data, box_data)</code></li>
<li><code>image_data</code> 形如 <code>(h,w,3)</code>，值域 0 到 1</li>
<li><code>box_data</code> 二维数组，结构类似 <code>[[x_min,y_min,x_max,y_max,class_id],..]</code>，它的形状为 <code>shape=(max_boxes,5)</code>，5 是指相对于输入尺寸的绝对坐标 <code>x_min, y_min, x_max, y_max,</code> 和类别号  <code>class_id</code></li>
</ul>
<h5 id="preprocess-true-boxes"><a href="#preprocess-true-boxes" class="headerlink" title="preprocess_true_boxes"></a><code>preprocess_true_boxes</code></h5><p>在<code>yolo3\model.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess_true_boxes</span><span class="params">(true_boxes, input_shape, anchors, num_classes)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> (true_boxes[..., <span class="number">4</span>]&lt;num_classes).all(), <span class="string">'class id must be less than num_classes'</span></span><br><span class="line">    num_layers = len(anchors)//<span class="number">3</span> <span class="comment"># default setting</span></span><br><span class="line">    anchor_mask = [[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]] <span class="keyword">if</span> num_layers==<span class="number">3</span> <span class="keyword">else</span> [[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line">    true_boxes = np.array(true_boxes, dtype=<span class="string">'float32'</span>)</span><br><span class="line">    input_shape = np.array(input_shape, dtype=<span class="string">'int32'</span>)</span><br><span class="line">    boxes_xy = (true_boxes[..., <span class="number">0</span>:<span class="number">2</span>] + true_boxes[..., <span class="number">2</span>:<span class="number">4</span>]) // <span class="number">2</span></span><br><span class="line">    boxes_wh = true_boxes[..., <span class="number">2</span>:<span class="number">4</span>] - true_boxes[..., <span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    true_boxes[..., <span class="number">0</span>:<span class="number">2</span>] = boxes_xy/input_shape[::<span class="number">-1</span>]</span><br><span class="line">    true_boxes[..., <span class="number">2</span>:<span class="number">4</span>] = boxes_wh/input_shape[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    m = true_boxes.shape[<span class="number">0</span>]</span><br><span class="line">    grid_shapes = [input_shape//&#123;<span class="number">0</span>:<span class="number">32</span>, <span class="number">1</span>:<span class="number">16</span>, <span class="number">2</span>:<span class="number">8</span>&#125;[l] <span class="keyword">for</span> l <span class="keyword">in</span> range(num_layers)]</span><br><span class="line">    y_true = [np.zeros((m,grid_shapes[l][<span class="number">0</span>],grid_shapes[l][<span class="number">1</span>],len(anchor_mask[l]),<span class="number">5</span>+num_classes),</span><br><span class="line">        dtype=<span class="string">'float32'</span>) <span class="keyword">for</span> l <span class="keyword">in</span> range(num_layers)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Expand dim to apply broadcasting.</span></span><br><span class="line">    anchors = np.expand_dims(anchors, <span class="number">0</span>)</span><br><span class="line">    anchor_maxes = anchors / <span class="number">2.</span></span><br><span class="line">    anchor_mins = -anchor_maxes</span><br><span class="line">    valid_mask = boxes_wh[..., <span class="number">0</span>]&gt;<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="comment"># Discard zero rows.</span></span><br><span class="line">        wh = boxes_wh[b, valid_mask[b]]</span><br><span class="line">        <span class="keyword">if</span> len(wh)==<span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># Expand dim to apply broadcasting.</span></span><br><span class="line">        wh = np.expand_dims(wh, <span class="number">-2</span>)</span><br><span class="line">        box_maxes = wh / <span class="number">2.</span></span><br><span class="line">        box_mins = -box_maxes</span><br><span class="line"></span><br><span class="line">        intersect_mins = np.maximum(box_mins, anchor_mins)</span><br><span class="line">        intersect_maxes = np.minimum(box_maxes, anchor_maxes)</span><br><span class="line">        intersect_wh = np.maximum(intersect_maxes - intersect_mins, <span class="number">0.</span>)</span><br><span class="line">        intersect_area = intersect_wh[..., <span class="number">0</span>] * intersect_wh[..., <span class="number">1</span>]</span><br><span class="line">        box_area = wh[..., <span class="number">0</span>] * wh[..., <span class="number">1</span>]</span><br><span class="line">        anchor_area = anchors[..., <span class="number">0</span>] * anchors[..., <span class="number">1</span>]</span><br><span class="line">        iou = intersect_area / (box_area + anchor_area - intersect_area)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Find best anchor for each true box</span></span><br><span class="line">        best_anchor = np.argmax(iou, axis=<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> t, n <span class="keyword">in</span> enumerate(best_anchor):</span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> range(num_layers):</span><br><span class="line">                <span class="keyword">if</span> n <span class="keyword">in</span> anchor_mask[l]:</span><br><span class="line">                    i = np.floor(true_boxes[b,t,<span class="number">0</span>]*grid_shapes[l][<span class="number">1</span>]).astype(<span class="string">'int32'</span>)</span><br><span class="line">                    j = np.floor(true_boxes[b,t,<span class="number">1</span>]*grid_shapes[l][<span class="number">0</span>]).astype(<span class="string">'int32'</span>)</span><br><span class="line">                    k = anchor_mask[l].index(n)</span><br><span class="line">                    c = true_boxes[b,t, <span class="number">4</span>].astype(<span class="string">'int32'</span>)</span><br><span class="line">                    y_true[l][b, j, i, k, <span class="number">0</span>:<span class="number">4</span>] = true_boxes[b,t, <span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">                    y_true[l][b, j, i, k, <span class="number">4</span>] = <span class="number">1</span></span><br><span class="line">                    y_true[l][b, j, i, k, <span class="number">5</span>+c] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y_true</span><br></pre></td></tr></table></figure>
<p>该函数用于将真实盒子信息转化成训练所需要的格式。</p>
<p>参数：</p>
<ul>
<li><strong>true_boxes</strong>: 多维数组，要求形状为 <code>(batch_size,boxes_number,5)</code> 由 <code>get_random_data</code> 生成</li>
<li><strong>input_shape</strong>: 网络的输入尺寸应该是32的倍数，注意这里的尺寸是 <strong>高在前、宽在后</strong></li>
<li><strong>anchors</strong>: 锚框，形状为<code>(k,2)</code> k是锚框个数; 2 是<code>(w,h)</code></li>
<li><strong>num_classes</strong>: 整型,总类别数</li>
</ul>
<p>返回：</p>
<ul>
<li><strong>y_true</strong> ：和 yolo3 网络输出的数据同型的数组，此时的 wxyh 已经换为相对路径</li>
</ul>
<p>执行过程：</p>
<ul>
<li><p>计算 YOLO3 网络输出的特征图数目，这里认为输出的特征图数目与锚框数目有关，经典 YOLO3 输出三个特征图，每个特征图 3 个锚框，共 9 个。tiny-YOLO 则输出 2 个特征图，每个特征图 3 个锚框，所以可由锚框数目求 YOLO3 输出的特征图数目，并分辨网络类型。其中：</p>
<ul>
<li><code>num_layers</code> 表示输出特征图数目</li>
<li><p><code>anchor_mask</code> 是锚框掩码，用于规定每个特征图用哪几个锚框</p>
<p>之后均以 <strong>YOLO3 输出三个特征图，每个特征图 3 个锚框</strong> 为例。</p>
</li>
</ul>
</li>
<li><p>对于参数 <code>true_boxes</code> 和 <code>input_shape</code> 进行类型转换</p>
</li>
<li><p>求出每个盒子的中心点坐标 <code>boxes_xy</code> 与宽高信息 <code>boxes_wh</code> 这两个参数形状为 <code>(batch_size,boxes_number,2)</code> </p>
</li>
<li><p>对  <code>true_boxes</code>  中的位置和宽高进行修改，将其改为相对于原图的比例数值，称新的 <code>true_boxes[..., 0:4]</code> 为<strong>最小横坐标比例、最小纵坐标比例、最大横坐标比例、最大纵坐标比例</strong></p>
</li>
<li><p>求 <code>grid_shapes</code> ,  <code>grid_shapes</code> 表示每个输出的特征图的两个方向各自分布多少网格。对于最终输出的特诊图而言，特征图上的一个点对应原图的一个区域，这个区域被称为网格，所以可以理解为这个变量表示的是输出的每个特征图的宽和高，经典 YOLO3 输出三个特征图，每个特征图大小别为原图宽高分别除 32、原图宽高分别除 16 、原图宽高分别除 8，最终 <code>grid_shapes</code> 的结构是 np 数组的列表：<br>  <code>[np.array([f1_w,f1_h]),np.array([f2_w,f2_h]),np.array([f3_w,f3_h])]</code> ，其中 <code>f1_w,f1_h</code> 表示最终输出的特征图里第一个特征图的宽和高。</p>
</li>
<li><p>创建 <code>y_true</code> ，此时只是先把 <code>y_true</code> 的结构定下来，其值用 0 填充，具体数值后面再填，<code>y_true</code> 的结构也是 np 数组的列表 ，它的结构为 <code>[y_true_1,y_true_2,y_true_3]</code> 。其中 <code>y_true_*</code> 是 np 数组，表示一个特征图中包含的真实信息，它的<code>shape=(批数,特征图高,特征图宽,3,5+类别数)</code></p>
</li>
<li><p>之后的代码是针对每批数据而言，故之后的代码 <strong>假设处理下标为 <code>b</code> 的一批数据</strong></p>
</li>
<li><p>对 <code>b</code>  批数据的对每个盒子对预设的锚框进行 IOU 运算，这里是假设中心点重合的 IOU，最终目的是求 <code>best_anchor</code> 。<code>best_anchor</code> 表示对于每个盒子而言，参数 <code>anchors</code> 里的哪个锚框和这个盒子重合度最高，它的 <code>shape=(valid_boxes_number,)</code> ，即长度为<code>valid_boxes_number</code> 的向量，其中 <code>valid_boxes_number</code> 为有效盒子数，有效盒子被定义为宽度大于 0 的盒子。</p>
<blockquote>
<p>这里的实现有个细节，就是 <code>anchors</code> 被扩充维度成 <code>shape=(1,k,2)</code> 而<code>wh</code>被扩充维度为 <code>shape=(boxes_number,1,2)</code> 所以最终他们的运算结果由 <code>broadcasting</code> 变成 <code>shape=(boxes_number,k,2)</code></p>
</blockquote>
</li>
<li><p>之后是一个二层循环，分别表示遍历<code>best_anchor</code>，遍历每个输出特征图，变量 <code>b,t,n,l</code>  都是索引号，分别表示：<strong>第 b 号批  、第 t 号盒子 、第t 号盒子的最大重合 anchor 索引号为 n 、第 l 号特征图</strong></p>
</li>
<li><p>如果第 t 号盒子的最大索引号 n，在第 l 号特征图的锚框掩码中，则说明，第l 号特征图内有锚框负责这个盒子，此时：</p>
<ul>
<li><p>令 <code>i</code> 等于第 b 号批里第 t 号盒子的最大横坐标比例*第 l 号特征图的宽，并向下取整</p>
</li>
<li><p>令 <code>j</code> 等于第 b 号批里第 t 号盒子的最小纵坐标比例*第 l 号特征图的高，并向下取整</p>
<blockquote>
<p>此时 <code>j,i</code> 表示第 l 号特征图中，负责这个物体的网格坐标。</p>
</blockquote>
</li>
<li><p>令 <code>k</code> 等于第 n 号锚框在第 l 号特征的索引号，<code>k</code> 只能取 0,1,2</p>
</li>
<li><p>令 <code>c</code> 等于第 b 号批里第 t 号盒子的类别号</p>
</li>
<li><p>最后填充，第 l 号特征图中的，第 b 号批数据里，第 j 行 、第 i 列，第 k 号锚框，使其坐标信息等于 b 号批里第 t 号盒子的坐标信息、置信度等于 1、类别信息等于 c （即令 <code>y_true[l][..,5+c] = 1</code> )</p>
</li>
</ul>
</li>
<li><p>上述过程把 <code>y_true</code> 该填的完，负责物体的锚框有对应值，不负责物体的锚框的值为 0，最后强调，<code>y_true</code> 是一个三元素列表，每个元素的 <code>shape=(批数,特征图高,特征图宽,3,5+类别数)</code> ，每个元素的元素可视为长度为 <code>5+类别数</code> 的特征向量，特征向量中的位置信息是<strong>相对于原图</strong>的最小横坐标比例、最小纵坐标比例、最大横坐标比例、最大纵坐标比例。</p>
</li>
</ul>
<h4 id="实现函数-1"><a href="#实现函数-1" class="headerlink" title="实现函数"></a>实现函数</h4><p>训练数据是由 <code>data_generator_wrapper</code> 生成：</p>
<h5 id="data-generator-wrapper"><a href="#data-generator-wrapper" class="headerlink" title="data_generator_wrapper"></a><code>data_generator_wrapper</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_generator_wrapper(annotation_lines, batch_size, input_shape, anchors, num_classes):</span><br><span class="line">    n = len(annotation_lines)</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span> <span class="keyword">or</span> batch_size&lt;=<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> data_generator(annotation_lines, batch_size, input_shape, anchors, num_classes)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li><strong>annotation_lines</strong>：yolo3 标注文件的行数，也就是总训练样本数</li>
<li><strong>batch_size</strong> ：批大小</li>
<li><strong>input_shape</strong> ：二维元组，输入张量的形状，要求32的倍数，YOLO3 设置为 (416,416)</li>
<li><strong>anchors</strong> ：锚框列表，<code>get_anchors</code> 函数得到，形如<code>[[w1,h1],[w2,h2]...]</code></li>
<li><strong>num_classes</strong> ：类别数目，由 <code>len(get_classes(classes_path))</code> 得到</li>
</ul>
<p><code>data_generator_wrapper</code> 只是对参数进行简单的检验，最终数据由 <code>data_generator</code> 生成</p>
<h5 id="data-generator"><a href="#data-generator" class="headerlink" title="data_generator"></a><code>data_generator</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_generator</span><span class="params">(annotation_lines, batch_size, input_shape, anchors, num_classes)</span>:</span></span><br><span class="line">    <span class="string">'''data generator for fit_generator'''</span></span><br><span class="line">    n = len(annotation_lines)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        image_data = []</span><br><span class="line">        box_data = []</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> range(batch_size):</span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">0</span>:</span><br><span class="line">                np.random.shuffle(annotation_lines)</span><br><span class="line">            image, box = get_random_data(annotation_lines[i], input_shape, random=<span class="literal">True</span>)</span><br><span class="line">            image_data.append(image)</span><br><span class="line">            box_data.append(box)</span><br><span class="line">            i = (i+<span class="number">1</span>) % n</span><br><span class="line">        image_data = np.array(image_data)</span><br><span class="line">        box_data = np.array(box_data)</span><br><span class="line">        y_true = preprocess_true_boxes(box_data, input_shape, anchors, num_classes)</span><br><span class="line">        <span class="keyword">yield</span> [image_data, *y_true], np.zeros(batch_size)</span><br></pre></td></tr></table></figure>
<p><code>data_generator</code> 是一个生成器，所以用 <code>yield</code> 替代 <code>return</code> ，这生成器直接作用于 <code>model.fit_generator</code> ，所以生成器生成的数据，就是每一<code>epoch</code> 训练的数据。</p>
<p>生成器的参数和 <code>data_generator_wrapper</code> 参数一致。</p>
<p><code>model.fit_generator</code> 要求 <code>data_generator</code>  返回一个下面任意一个元组：</p>
<ul>
<li>a tuple <code>(inputs, targets)</code></li>
<li>a tuple <code>(inputs, targets, sample_weights)</code></li>
</ul>
<p>这里 <code>data_generator</code>   返回的是 <code>(inputs, targets)</code> 它的 inputs 是 <code>[image_data, *y_true]</code> , 它的 targets 是长为 <code>batch_size</code> 的全 0 向量。</p>
<p>执行过程：</p>
<ul>
<li>统计样本总数 <code>n = len(annotation_lines)</code> , 设置计数变量 <code>i = 0</code> </li>
<li>通过 while-yield 结构设计生成器 </li>
<li>每次生成数据的时候 , 执行 <code>batch_size</code> 次循环<ul>
<li>如果 <code>i==0</code> 说明第一次生成数据 , 或者所有样本都已经被生成一遍了 , 此时用 <code>np.random.shuffle(annotation_lines)</code> 将样本打乱</li>
<li>通过 <code>get_random_data(annotation_lines[i], input_shape, random=True)</code> 获得第 i 个样本的图片信息和图片上的盒子信息 <code>image, box</code></li>
<li>将图片信息和标注信息分布追加到<code>image_data, box_data</code></li>
<li><code>i = (i+1) % n</code> 表示该读下一个样本了</li>
</ul>
</li>
<li>将 <code>image_data, box_data</code> 包装为 np 数据</li>
<li>通过 <code>preprocess_true_boxes(box_data, input_shape, anchors, num_classes)</code> 由盒子信息获取 loss 函数所需的目标信息 <code>y_true</code></li>
<li>返回 <code>[image_data, *y_true], np.zeros(batch_size)</code></li>
</ul>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020\04\04\YOLO3 参数学习 Keras源码分析\" rel="bookmark">YOLO3 参数学习 Keras源码分析</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020\04\04\YOLO3 目标检测与性能评价 Keras源码分析\" rel="bookmark">YOLO3 目标检测与性能评价 Keras源码分析</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\2020\04\04\YOLO3 网络结构 Keras源码分析\" rel="bookmark">YOLO3 网络结构 Keras源码分析</a></div>
    </li>
  </ul>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="https://blog.csdn.net/lzs781">
            <span class="icon">
              <i class="fa fa-link"></i>
            </span>

            <span class="label">CSDN</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/YOLO3/" rel="tag"><i class="fa fa-tag"></i> YOLO3</a>
              <a href="/tags/Keras/" rel="tag"><i class="fa fa-tag"></i> Keras</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/04/YOLO3%20%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="prev" title="YOLO3 目标检测与性能评价 Keras源码分析">
      <i class="fa fa-chevron-left"></i> YOLO3 目标检测与性能评价 Keras源码分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/04/YOLO3%20%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="next" title="YOLO3 网络结构 Keras源码分析">
      YOLO3 网络结构 Keras源码分析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据处理"><span class="nav-number">2.</span> <span class="nav-text">数据处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据集转换"><span class="nav-number">2.1.</span> <span class="nav-text">数据集转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#源码分析"><span class="nav-number">2.2.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础函数："><span class="nav-number">2.2.1.</span> <span class="nav-text">基础函数：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#convert-annotation-year-image-id-list-file"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">convert_annotation(year, image_id, list_file)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现过程"><span class="nav-number">2.2.2.</span> <span class="nav-text">实现过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#脚本主内容"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">脚本主内容</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-K-means-生成锚框"><span class="nav-number">2.3.</span> <span class="nav-text">使用 K-means 生成锚框</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#理论基础"><span class="nav-number">2.3.1.</span> <span class="nav-text">理论基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基础函数"><span class="nav-number">2.3.2.</span> <span class="nav-text">基础函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#YOLO-Kmeans-init"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">YOLO_Kmeans.__init__</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#YOLO-Kmeans-txt2boxes"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">YOLO_Kmeans.txt2boxes</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#YOLO-Kmeans-iou"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">YOLO_Kmeans.iou</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#YOLO-Kmeans-kmeans"><span class="nav-number">2.3.2.4.</span> <span class="nav-text">YOLO_Kmeans.kmeans</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#YOLO-Kmeans-txt2clusters"><span class="nav-number">2.3.2.5.</span> <span class="nav-text">YOLO_Kmeans.txt2clusters</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#YOLO-Kmeans-result2txt"><span class="nav-number">2.3.2.6.</span> <span class="nav-text">YOLO_Kmeans.result2txt</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#YOLO-Kmeans-avg-iou"><span class="nav-number">2.3.2.7.</span> <span class="nav-text">YOLO_Kmeans.avg_iou</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现函数"><span class="nav-number">2.3.3.</span> <span class="nav-text">实现函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读入数据"><span class="nav-number">3.</span> <span class="nav-text">读入数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础函数-1"><span class="nav-number">3.0.1.</span> <span class="nav-text">基础函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#get-random-data"><span class="nav-number">3.0.1.1.</span> <span class="nav-text">get_random_data</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#preprocess-true-boxes"><span class="nav-number">3.0.1.2.</span> <span class="nav-text">preprocess_true_boxes</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现函数-1"><span class="nav-number">3.0.2.</span> <span class="nav-text">实现函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#data-generator-wrapper"><span class="nav-number">3.0.2.1.</span> <span class="nav-text">data_generator_wrapper</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#data-generator"><span class="nav-number">3.0.2.2.</span> <span class="nav-text">data_generator</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="刘之帅"
      src="/images/LOGO.jpg">
  <p class="site-author-name" itemprop="name">刘之帅</p>
  <div class="site-description" itemprop="description">正在积极接受治疗的重度懒癌患者……</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/LogicForeach" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LogicForeach" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/lzs781" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;lzs781" rel="noopener" target="_blank"><i class="fa fa-fw fa-link"></i>CSDN</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-envelope"></i>
      E-Mail
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="mailto:lzs783@qq.com" title="mailto:lzs783@qq.com" rel="noopener" target="_blank">lzs783@qq.com</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘之帅</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">97k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:28</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    // window.MathJax = {
    //   loader: {
    //
    //     source: {
    //       '[tex]/amsCd': '[tex]/amscd',
    //       '[tex]/AMScd': '[tex]/amscd'
    //     }
    //   },
    //   tex: {
    //     inlineMath: {'[+]': [['$', '$']]},
    //
    //     tags: 'ams'
    //   },
    //   options: {
    //     renderActions: {
    //       findScript: [10, doc => {
    //         document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
    //           const display = !!node.type.match(/; *mode=display/);
    //           const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
    //           const text = document.createTextNode('');
    //           node.parentNode.replaceChild(text, node);
    //           math.start = {node: text, delim: '', n: 0};
    //           math.end = {node: text, delim: '', n: 0};
    //           doc.math.push(math);
    //         });
    //       }, '', false],
    //       insertedScript: [200, () => {
    //         document.querySelectorAll('mjx-container').forEach(node => {
    //           let target = node.parentNode;
    //           if (target.nodeName.toLowerCase() === 'li') {
    //             target.parentNode.classList.add('has-jax');
    //           }
    //         });
    //       }, '', false]
    //     }
    //   }
    // };
    window.MathJax = {
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_SVG';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    

  

</body>
</html>
