<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>YOLO3 数据处理与数据加载 Keras源码分析 - LogicForeach</title><meta description="刘之帅的个人博客"><meta property="og:type" content="blog"><meta property="og:title" content="LogicForeach"><meta property="og:url" content="logicforeach.github.io"><meta property="og:site_name" content="LogicForeach"><meta property="og:description" content="刘之帅的个人博客"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2020-04-04T11:00:08.811Z"><meta property="article:modified_time" content="2020-04-04T14:54:29.791Z"><meta property="article:author" content="刘之帅"><meta property="article:tag" content="YOLO3"><meta property="article:tag" content="Keras"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/LOGO.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"logicforeach.github.io/2020/04/04/YOLO3%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},"headline":"LogicForeach","image":["/2020/04/04/YOLO3%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/20200322031027706.png"],"datePublished":"2020-04-04T11:00:08.811Z","dateModified":"2020-04-04T14:54:29.791Z","author":{"@type":"Person","name":"刘之帅"},"description":"YOLO3 Keras 源码：https:&#x2F;&#x2F;github.com&#x2F;qqwweee&#x2F;keras-yolo3 前言本文从主要是从源码层面对 YOLO3 的数据处理相关内容进行分析与讲解。通常，一个功能的实现需要多个函数配合，所以我将每个功能的实现函数分为两部分，基础函数 和 实现函数 ：  基础函数：被实现函数所依赖，是实现函数的一部分 实现函数：通过调用基础函数实现功能  源码内容比较多，通过目录"}</script><link rel="canonical" href="logicforeach.github.io/2020/04/04/YOLO3%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/LOGO.jpg" alt="LogicForeach" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">与我相关</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/LogicForeach"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-04-04T11:00:08.811Z" title="2020-04-04T11:00:08.811Z">2020-04-04</time><span class="level-item"><a class="link-muted" href="/categories/YOLO3-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">YOLO3 源码分析</a></span><span class="level-item">1 小时 读完 (大约 7149 个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">YOLO3 数据处理与数据加载 Keras源码分析</h1><div class="content"><p>YOLO3 Keras 源码：<a href="https://github.com/qqwweee/keras-yolo3">https://github.com/qqwweee/keras-yolo3</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文从主要是从源码层面对 YOLO3 的数据处理相关内容进行分析与讲解。通常，一个功能的实现需要多个函数配合，所以我将每个功能的实现函数分为两部分，<strong>基础函数</strong> 和 <strong>实现函数</strong> ：</p>
<ul>
<li>基础函数：被实现函数所依赖，是实现函数的一部分</li>
<li>实现函数：通过调用基础函数实现功能</li>
</ul>
<p>源码内容比较多，通过目录索引看感兴趣的地方即可。</p>
<h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><h3 id="数据集转换"><a href="#数据集转换" class="headerlink" title="数据集转换"></a>数据集转换</h3><p>YOLO3 Keras 源码所需要的数据集应该在一个<code>.txt</code> ( 文本文件 )内，文件中的一行代表一个张图片和它的标签，其中每行的格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">image_file_path box1 box2 ... boxN<br></code></pre></td></tr></table></figure>
<p><code>box*</code> 是该图片的标签，即真实框，不同box之间用空格隔开，其中每个box的格式为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">x_min,y_min,x_max,y_max,class_id<br></code></pre></td></tr></table></figure>
<p>所以总的来说，训练用的数据集应该大体是这个样子的：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">path&#x2F;to&#x2F;img1.jpg 50,100,150,200,0 30,50,200,120,3<br>path&#x2F;to&#x2F;img2.jpg 120,300,250,600,2<br>...<br></code></pre></td></tr></table></figure>
<p>对于 VOC 数据集，Keras 源码的作者给出了脚本 <code>voc_annotation.py</code> 可以将 VOC 数据集转化成上述格式。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> xml.etree.ElementTree <span class="hljs-keyword">as</span> ET<br><span class="hljs-keyword">from</span> os <span class="hljs-keyword">import</span> getcwd<br><br>sets=[(<span class="hljs-string">'2007'</span>, <span class="hljs-string">'train'</span>), (<span class="hljs-string">'2007'</span>, <span class="hljs-string">'val'</span>), (<span class="hljs-string">'2007'</span>, <span class="hljs-string">'test'</span>)]<br><br>classes = [<span class="hljs-string">"aeroplane"</span>, <span class="hljs-string">"bicycle"</span>, <span class="hljs-string">"bird"</span>, <span class="hljs-string">"boat"</span>, <span class="hljs-string">"bottle"</span>, <span class="hljs-string">"bus"</span>, <span class="hljs-string">"car"</span>, <span class="hljs-string">"cat"</span>, <span class="hljs-string">"chair"</span>, <span class="hljs-string">"cow"</span>, <span class="hljs-string">"diningtable"</span>, <span class="hljs-string">"dog"</span>, <span class="hljs-string">"horse"</span>, <span class="hljs-string">"motorbike"</span>, <span class="hljs-string">"person"</span>, <span class="hljs-string">"pottedplant"</span>, <span class="hljs-string">"sheep"</span>, <span class="hljs-string">"sofa"</span>, <span class="hljs-string">"train"</span>, <span class="hljs-string">"tvmonitor"</span>]<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convert_annotation</span><span class="hljs-params">(year, image_id, list_file)</span>:</span><br>    in_file = open(<span class="hljs-string">'VOCdevkit/VOC%s/Annotations/%s.xml'</span>%(year, image_id))<br>    tree=ET.parse(in_file)<br>    root = tree.getroot()<br><br>    <span class="hljs-keyword">for</span> obj <span class="hljs-keyword">in</span> root.iter(<span class="hljs-string">'object'</span>):<br>        difficult = obj.find(<span class="hljs-string">'difficult'</span>).text<br>        cls = obj.find(<span class="hljs-string">'name'</span>).text<br>        <span class="hljs-keyword">if</span> cls <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> classes <span class="hljs-keyword">or</span> int(difficult)==<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">continue</span><br>        cls_id = classes.index(cls)<br>        xmlbox = obj.find(<span class="hljs-string">'bndbox'</span>)<br>        b = (int(xmlbox.find(<span class="hljs-string">'xmin'</span>).text), int(xmlbox.find(<span class="hljs-string">'ymin'</span>).text), int(xmlbox.find(<span class="hljs-string">'xmax'</span>).text), int(xmlbox.find(<span class="hljs-string">'ymax'</span>).text))<br>        list_file.write(<span class="hljs-string">" "</span> + <span class="hljs-string">","</span>.join([str(a) <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> b]) + <span class="hljs-string">','</span> + str(cls_id))<br><br>wd = getcwd()<br><br><span class="hljs-keyword">for</span> year, image_set <span class="hljs-keyword">in</span> sets:<br>    image_ids = open(<span class="hljs-string">'VOCdevkit/VOC%s/ImageSets/Main/%s.txt'</span>%(year, image_set)).read().strip().split()<br>    list_file = open(<span class="hljs-string">'%s_%s.txt'</span>%(year, image_set), <span class="hljs-string">'w'</span>)<br>    <span class="hljs-keyword">for</span> image_id <span class="hljs-keyword">in</span> image_ids:<br>        list_file.write(<span class="hljs-string">'%s/VOCdevkit/VOC%s/JPEGImages/%s.jpg'</span>%(wd, year, image_id))<br>        convert_annotation(year, image_id, list_file)<br>        list_file.write(<span class="hljs-string">'\n'</span>)<br>    list_file.close()<br></code></pre></td></tr></table></figure>
<h4 id="基础函数："><a href="#基础函数：" class="headerlink" title="基础函数："></a>基础函数：</h4><h5 id="convert-annotation-year-image-id-list-file"><a href="#convert-annotation-year-image-id-list-file" class="headerlink" title="convert_annotation(year, image_id, list_file)"></a><code>convert_annotation(year, image_id, list_file)</code></h5><p>参数：</p>
<ul>
<li><strong>year</strong>：整型，年代 , VOC2007 的 2007 </li>
<li><strong>image_id</strong> ：图像序号</li>
<li><strong>list_file</strong> ： 文件对象</li>
</ul>
<p>功能：</p>
<ul>
<li>通过 <code>year</code> 和 <code>image_id</code>找到 VOC 数据集里的 xml 文件，通过 ElementTree 找到这个 XML 里的每一个 <code>object</code> 标签，获取该标签内的 <code>xmin,ymin,xmax,ymax</code>，和列表序号<code>class_id</code> ，把它们写入到 list_file 所打开的文件对象中。</li>
<li>总之，这个函数是在将 <code>.xml</code> 中的标注信息转化为 YOLO3 所需要标注格式，并写入文件。</li>
</ul>
<h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><h5 id="脚本主内容"><a href="#脚本主内容" class="headerlink" title="脚本主内容"></a>脚本主内容</h5><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> year, image_set <span class="hljs-keyword">in</span> sets:<br>    image_ids = open(<span class="hljs-string">'VOCdevkit/VOC%s/ImageSets/Main/%s.txt'</span>%(year, image_set)).read().strip().split()<br>    list_file = open(<span class="hljs-string">'%s_%s.txt'</span>%(year, image_set), <span class="hljs-string">'w'</span>)<br>    <span class="hljs-keyword">for</span> image_id <span class="hljs-keyword">in</span> image_ids:<br>        list_file.write(<span class="hljs-string">'%s/VOCdevkit/VOC%s/JPEGImages/%s.jpg'</span>%(wd, year, image_id))<br>        convert_annotation(year, image_id, list_file)<br>        list_file.write(<span class="hljs-string">'\n'</span>)<br>    list_file.close()<br></code></pre></td></tr></table></figure>
<p><code>year, image_set</code> 是从 <code>sets</code> 提取而来，这个 for 循环的目的是操作 <code>sets</code> 中对应的每一个文件。</p>
<p>即打开<code>train.txt</code> 、<code>val.txt</code> 、<code>test.txt</code> ，它们里面内容长这个样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">0<br>1<br>10<br>100<br>1000<br>....<br></code></pre></td></tr></table></figure>
<p>这其中每一行都是图片的序号。</p>
<p>如打开<code>train.txt</code> ，脚本通过 <code>.read().strip().split()</code> ，把 <code>train.txt</code> 中一行一行的图片序号变成一个列表 <code>image_ids</code> ，创建一个文件对象 <code>list_file</code> 随后对列表内每一个元素进行操作：</p>
<ul>
<li>根据文件路径和图片序号的映射关系，把图片路劲写入到 <code>list_file</code>  文件对象对应的文件中。</li>
<li>通过 <code>convert_annotation</code> 把图片的标注信息（已转化为 YOLO3 所需格式），紧接着路径信息写在后面</li>
<li>写入换行符</li>
</ul>
<p>所以元素操作完事，关闭文件对象。</p>
<p>通过上述流程对 <code>train.txt</code> 、<code>val.txt</code> 、<code>test.txt</code> 都操作完，就把 VOC 数据集转化为 YOLO3 所需要的格式了。</p>
<h3 id="使用-K-means-生成锚框"><a href="#使用-K-means-生成锚框" class="headerlink" title="使用 K-means 生成锚框"></a>使用 K-means 生成锚框</h3><p>YOLO2 开始，锚框的生成使用 K-means 算法，这种倚靠训练数据自动生成的锚框，比人为设定的锚框更加符合特定场景的业务需求，所以会提高模型的准确度。</p>
<p>介绍 K-means 之前，需要先了解它是用于什么学习任务的，K-means 是解决聚类问题的一个算法。</p>
<h4 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h4><p><strong>聚类和簇</strong></p>
<p>聚类任务是一种无监督学习任务，聚类试图将样本划分为若干个不相交的子集，每个子集成为<strong>簇</strong>，通过这样的划分，每个簇对应一个潜在类别，具体是什么类别，对于聚类算法而言是未知，都是在聚类结束后，人为的判断一个簇对应的什么类别。聚类常用于寻找数据内部的分布结构，或用于对其他分类学习任务进行粗略的预先处理。比如自从 YOLO2 后，聚类算法就被用于预先为图像划定锚框。</p>
<p><strong>距离计算</strong></p>
<p>聚类任务说到底是让”簇内相似度高“且”簇间相似度低“，那么就需要一个衡量相似度的指标，两个样本间的距离可以反映样本之间的相似度，所以定义 $dist(\cdot,\cdot)$ 为两个样本的距离。距离的计算有诸多算法，比如“闵可夫斯基距离”</p>
<script type="math/tex; mode=display">
dist_{mk}(x_i,x_j)=(\sum_{u=1}^n|x_{i,u}-x_{j,x}|^p)^{\frac{1}{p}}</script><p>在 YOLO2 和 YOLO3 中，距离计算是借助两个 box 的 IOU：</p>
<script type="math/tex; mode=display">
dist(b_i,b_j)=1-IOU(b_i,b_j)</script><p><strong>K-means 算法</strong></p>
<p>K-means 的思想是，对所划分的所有簇 $C={C_1,C_2,\dots,C_k}$ 使</p>
<script type="math/tex; mode=display">
E=\sum_{i=1}^k\sum_{x\in C_i}dist(x,\mu_i)</script><p>最小，其中 $\mu<em>i=\frac{1}{|C_i|}\sum</em>{x\in C_i}x$ ，即 $\mu_i$ 是 $C_i$ 的均指向量。</p>
<p>为了达到这个目的，K-means 采用贪心策略，最开始随机指定 K 个向量作为 $(\mu_1,\dots,\mu_k)$ 对于每一个 $\mu_i$ ，计算每一个向量 $x$ 与 $\mu_i$ 的距离，即 $dist(x,\mu_i)$ 将距离值最小的向量，归到 $C_i$ 然后更新  $\mu_i$ ，重复这个过程，直到 $(\mu_1,\dots,\mu_k)$ 都不再更新。</p>
<p><img src="/2020/04/04/YOLO3%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/20200322031027706.png" alt></p>
<h4 id="基础函数"><a href="#基础函数" class="headerlink" title="基础函数"></a>基础函数</h4><h5 id="YOLO-Kmeans-init"><a href="#YOLO-Kmeans-init" class="headerlink" title="YOLO_Kmeans.__init__"></a><code>YOLO_Kmeans.__init__</code></h5><p><code>YOLO_Kmeans</code> 是一个类，它的初始化函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, cluster_number, filename)</span>:</span><br>    self.cluster_number = cluster_number<br>    self.filename = filename<br></code></pre></td></tr></table></figure>
<p>其作用仅是将参数保留到类内</p>
<h5 id="YOLO-Kmeans-txt2boxes"><a href="#YOLO-Kmeans-txt2boxes" class="headerlink" title="YOLO_Kmeans.txt2boxes"></a><code>YOLO_Kmeans.txt2boxes</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">txt2boxes</span><span class="hljs-params">(self)</span>:</span><br>    f = open(self.filename, <span class="hljs-string">'r'</span>)<br>    dataSet = []<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>        infos = line.split(<span class="hljs-string">" "</span>)<br>        length = len(infos)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, length):<br>            width = int(infos[i].split(<span class="hljs-string">","</span>)[<span class="hljs-number">2</span>]) - \<br>                int(infos[i].split(<span class="hljs-string">","</span>)[<span class="hljs-number">0</span>])<br>            height = int(infos[i].split(<span class="hljs-string">","</span>)[<span class="hljs-number">3</span>]) - \<br>                int(infos[i].split(<span class="hljs-string">","</span>)[<span class="hljs-number">1</span>])<br>            dataSet.append([width, height])<br>    result = np.array(dataSet)<br>    f.close()<br>    <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure>
<p>该方法的作用是将 YOLO 标注文件内的 box 信息转化为列表</p>
<p>YOLO 标注文件格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">path&#x2F;to&#x2F;img1.jpg 50,100,150,200,0 30,50,200,120,3<br>path&#x2F;to&#x2F;img2.jpg 120,300,250,600,2<br>...<br></code></pre></td></tr></table></figure>
<p><code>f</code> 是一个文件对象，文件对象可迭代，每次读取文件的一行，最外层的 for 是指对文件内的每一行操作。</p>
<p>对文件内的每一行，以空格为分隔符，将其划分为列表 <code>infos</code> ：</p>
<p>对 <code>infos[1]</code> 到 <code>infors[length-1]</code> 中的每一个元素 <code>infos[i]</code> 而言，每一个 <code>infos[i]</code> 代表一组 box 信息。<code>infos[i].split(&quot;,&quot;)[0]</code> 、<code>infos[i].split(&quot;,&quot;)[1]</code> 、<code>infos[i].split(&quot;,&quot;)[2]</code> 、<code>infos[i].split(&quot;,&quot;)[3]</code>   、<code>infos[i].split(&quot;,&quot;)[4]</code>分别对应 box 信息里的 <code>x_min,y_min,x_max,y_max,class_id</code> ，由这些信息就可以计算出 box 的宽和高，记为<code>[width, height]</code> ，将每组 box 的 <code>[width, height]</code> 追加到 <code>dataSet</code> 列表内，将 <code>dataSet</code>  转化为 <code>np.array</code> 并返回。</p>
<h5 id="YOLO-Kmeans-iou"><a href="#YOLO-Kmeans-iou" class="headerlink" title="YOLO_Kmeans.iou"></a><code>YOLO_Kmeans.iou</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">iou</span><span class="hljs-params">(self, boxes, clusters)</span>:</span>  <span class="hljs-comment"># 1 box -&gt; k clusters</span><br>    n = boxes.shape[<span class="hljs-number">0</span>]<br>    k = self.cluster_number<br><br>    box_area = boxes[:, <span class="hljs-number">0</span>] * boxes[:, <span class="hljs-number">1</span>]<br>    box_area = box_area.repeat(k)<br>    box_area = np.reshape(box_area, (n, k))<br><br>    cluster_area = clusters[:, <span class="hljs-number">0</span>] * clusters[:, <span class="hljs-number">1</span>]<br>    cluster_area = np.tile(cluster_area, [<span class="hljs-number">1</span>, n])<br>    cluster_area = np.reshape(cluster_area, (n, k))<br><br>    box_w_matrix = np.reshape(boxes[:, <span class="hljs-number">0</span>].repeat(k), (n, k))<br>    cluster_w_matrix = np.reshape(np.tile(clusters[:, <span class="hljs-number">0</span>], (<span class="hljs-number">1</span>, n)), (n, k))<br>    min_w_matrix = np.minimum(cluster_w_matrix, box_w_matrix)<br><br>    box_h_matrix = np.reshape(boxes[:, <span class="hljs-number">1</span>].repeat(k), (n, k))<br>    cluster_h_matrix = np.reshape(np.tile(clusters[:, <span class="hljs-number">1</span>], (<span class="hljs-number">1</span>, n)), (n, k))<br>    min_h_matrix = np.minimum(cluster_h_matrix, box_h_matrix)<br>    inter_area = np.multiply(min_w_matrix, min_h_matrix)<br><br>    result = inter_area / (box_area + cluster_area - inter_area)<br>    <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>boxes ： 盒子信息，结构为<code>[[w1,h1],[w2,h2]...]</code></li>
<li>clusters：簇点信息，内含 k 个 <code>[w,h]</code> 结构为 <code>[[w1,h1],...,[wk,hk]]</code></li>
</ul>
<p>执行过程：</p>
<ul>
<li>求每个盒子的面积，重复 k 次，得到 n*k 矩阵 <code>box_area</code> , n 是总盒子数，k 是簇数</li>
<li>求每个簇点的面积，所有簇点面积集合记为 <code>cluster_area</code> , 一开始，<code>cluster_area</code> 是 <code>shape=(1,k)</code> 的 np 数组，经过 <code>np.tile</code> 变成 <code>shape=(1,k*n)</code>，<code>np.reshape</code> 成 <code>shape=(n,k)</code></li>
<li>用相似的维度变化，求盒子的 w 矩阵 <code>box_w_matrix</code>，与簇点的 w 矩阵 <code>cluster_w_matrix</code> ，用 <code>np.minimum</code> 取宽最小矩阵 <code>min_w_matrix</code></li>
<li>同理求高最小矩阵 <code>min_h_matrix</code></li>
<li>盒子与簇在假设左上角对齐的情况下，最小的宽*最小的高就是他们相交的区域的面积，相交面积 <code>inter_area = np.multiply(min_w_matrix, min_h_matrix)</code></li>
<li>最终返回 IOU 值 IOU = 相交面积/相并面积 = 相交面积/( 盒子面积 + 簇点面积 - 相交面积 )，最红返回的 result 的形状 <code>shape=(n,k)</code></li>
</ul>
<h5 id="YOLO-Kmeans-kmeans"><a href="#YOLO-Kmeans-kmeans" class="headerlink" title="YOLO_Kmeans.kmeans"></a><code>YOLO_Kmeans.kmeans</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kmeans</span><span class="hljs-params">(self, boxes, k, dist=np.median)</span>:</span><br>    box_number = boxes.shape[<span class="hljs-number">0</span>]<br>    distances = np.empty((box_number, k))<br>    last_nearest = np.zeros((box_number,))<br>    np.random.seed()<br>    clusters = boxes[np.random.choice(<br>        box_number, k, replace=<span class="hljs-literal">False</span>)]  <span class="hljs-comment"># init k clusters</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><br>        distances = <span class="hljs-number">1</span> - self.iou(boxes, clusters)<br><br>        current_nearest = np.argmin(distances, axis=<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> (last_nearest == current_nearest).all():<br>            <span class="hljs-keyword">break</span>  <span class="hljs-comment"># clusters won't change</span><br>        <span class="hljs-keyword">for</span> cluster <span class="hljs-keyword">in</span> range(k):<br>            clusters[cluster] = dist(  <span class="hljs-comment"># update clusters</span><br>                boxes[current_nearest == cluster], axis=<span class="hljs-number">0</span>)<br><br>        last_nearest = current_nearest<br><br>    <span class="hljs-keyword">return</span> clusters<br></code></pre></td></tr></table></figure>
<p>参数 :</p>
<ul>
<li>boxes : 前面通过 <code>txt2boxes</code> 处理后得到的 np 数组，结构为<code>[[w1,h1],[w2,h2]...]</code></li>
<li>k : 整型，簇数</li>
<li>dist : 均值向量生成策略，这里用的中位数（那应该叫中位数向量hhhh）</li>
</ul>
<p>执行过程：</p>
<ul>
<li><p>得到 <code>boxes</code> 中的盒子数 <code>box_number</code>，用 <code>np.empty</code> 创建一个 <code>shape=(box_number, k)</code> 的空 np 数组 <code>distances</code>，用储存 boxes 中的每个盒子和每个簇的距离；用 <code>np.zeros</code> 创建一个长度为 <code>box_number</code> 的一维全零 np 数组，用于存储每个盒子距离最近的簇的索引值。</p>
</li>
<li><p>通过 <code>clusters = boxes[np.random.choice(box_number, k, replace=False)]</code> 从 <code>boxes</code>  中随机进行不放回抽样，选出 k 个 盒子信息作为初始的簇点。</p>
<p>  这里采用的是高级索引，<code>boxes[[1,2,3]]==[boxes[1],boxes[2],boxes[3]]</code> ，<code>numpy.random.choice(a, size=None, replace=True, p=None)</code> 它的参数从左到右依次表示候选列表、抽烟个数、是否放回、列表中各元素被抽中的概率。</p>
</li>
<li><p>进行循环直到 break 才终止：</p>
<ul>
<li><p>计算boxes 中的每个盒子和每个簇的距离，结果存放入 <code>distances</code>， <code>self.iou(boxes, clusters)</code> 后面讲解。</p>
</li>
<li><p>通过 <code>np.argmin(distances, axis=1)</code> 返回每个盒子距离最近的簇的索引值，结果存入<code>current_nearest</code>；<code>np.argmin(a, axis=None, out=None)</code> 可以沿 <code>axis</code>轴，在数组 <code>a</code> 中寻找最小值，并返回该值在 <code>axis</code> 轴内的索引。</p>
</li>
<li><p>如果上一轮循环中每个盒子距离最近的簇的索引 <code>last_nearest</code> 和这一轮的 <code>current_nearest</code>  中每一个元素都相同，那么说明算法已经收敛，跳出循环。</p>
<p>  其中 <code>last_nearest == current_nearest</code> 由于双等号两边都是同型 np 数组，所以这个表达式返回的也是同型 np 数组，数组内元素类型是布尔型，表示对应元素是否相同，<code>np.np.array.all()</code> 表示若数组内元素都为 True 则返回 True，否则返回 False</p>
</li>
<li><p>如果存在不同元素，就对 K 个簇点进行遍历， 让每个簇点等于该簇内向量的中位数。</p>
<p>  通过<code>boxes[current_nearest == cluster]</code> 找出所有”相对于其他簇点，与第<code>cluster</code> 个簇距离最近”的盒子，得到一个列表，列表结构为<code>[[w1,h1],[w2,h2]...]</code></p>
<p>  通过 <code>dist</code> 即 <code>np.median</code> 对上述列表，沿第一个轴求中位数，最终得到结构为<code>[w,h]</code>的一维二元列表。</p>
</li>
<li><p>更新结束，把当前状态 <code>current_nearest</code>  赋值给 <code>last_nearest</code> 开始下一轮循环。</p>
</li>
</ul>
</li>
<li><p>循环结束，将簇点列表 <code>clusters</code> 返回，在 YOLO3 中，各簇点就是预设的锚框信息。</p>
</li>
</ul>
<h5 id="YOLO-Kmeans-txt2clusters"><a href="#YOLO-Kmeans-txt2clusters" class="headerlink" title="YOLO_Kmeans.txt2clusters"></a><code>YOLO_Kmeans.txt2clusters</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">txt2clusters</span><span class="hljs-params">(self)</span>:</span><br>      = self.txt2boxes()<br>    result = self.kmeans(all_boxes, k=self.cluster_number)<br>    result = result[np.lexsort(result.T[<span class="hljs-number">0</span>, <span class="hljs-literal">None</span>])]<br>    self.result2txt(result)<br>    print(<span class="hljs-string">"K anchors:\n &#123;&#125;"</span>.format(result))<br>    print(<span class="hljs-string">"Accuracy: &#123;:.2f&#125;%"</span>.format(<br>    self.avg_iou(all_boxes, result) * <span class="hljs-number">100</span>))<br></code></pre></td></tr></table></figure>
<p><code>txt2clusters</code> 是脚本的执行函数，求kmeans就是从这个函数入手，这个函数主要过程就是：</p>
<ul>
<li><p><code>txt2boxes</code> 将文本信息划分并提取成列表信息 <code>all_boxes</code> , <code>all_boxes</code> 内各个盒子的信息，结构为 <code>[[w1,h1],[w2,h2]...]</code></p>
</li>
<li><p>使用 <code>kmeans</code> 求盒子列表的聚类，返回的是 k 个簇点，结构也为 <code>[[w1,h1],[w2,h2]...]</code> j结果保存到 <code>result</code></p>
</li>
<li><p>通过 <code>result[np.lexsort(result.T[0, None])]</code> 对 <code>result</code> 进行排序，排序规则是宽度小的在前面</p>
<p>  <code>result.T</code> 会对 <code>result</code> 转置，转置后结构为 <code>[[w1,...,wk],[h1...hk]]</code></p>
<p>  <code>result.T[0,None]</code> 是只取宽度数据，并且扩充一维，变成<code>[[w1,...,wk]]</code></p>
<p>  <code>lexsort(keys, axis=None)</code> ：返回一个整数数组（返回数组的元素是索引值）。<code>keys</code> 是一个序列的序列，要求内部序列形状相同，默认情况外部序列 <code>keys</code> 中的最后一个序列元素将作为主排序序列，倒数第二个序列元素作为第二排序序列….当主排序序列中元素大小相同时，就依照第二排序系列进行排序。</p>
<p>  <code>np.lexsort(result.T[0, None])</code> 输出结果是 <code>w1,...,wk</code> 依照升序排序后的顺序输出原索引值，是有 K 个元素的一维数组</p>
</li>
<li><p>使用 <code>result2txt</code> 将结果输出为文本文件</p>
</li>
<li><p>使用 <code>avg_iou</code> 评价聚类的结果</p>
</li>
</ul>
<h5 id="YOLO-Kmeans-result2txt"><a href="#YOLO-Kmeans-result2txt" class="headerlink" title="YOLO_Kmeans.result2txt"></a><code>YOLO_Kmeans.result2txt</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">result2txt</span><span class="hljs-params">(self, data)</span>:</span><br>    f = open(<span class="hljs-string">"yolo_anchors.txt"</span>, <span class="hljs-string">'w'</span>)<br>    row = np.shape(data)[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(row):<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:<br>            x_y = <span class="hljs-string">"%d,%d"</span> % (data[i][<span class="hljs-number">0</span>], data[i][<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">else</span>:<br>            x_y = <span class="hljs-string">", %d,%d"</span> % (data[i][<span class="hljs-number">0</span>], data[i][<span class="hljs-number">1</span>])<br>        f.write(x_y)<br>    f.close()<br></code></pre></td></tr></table></figure>
<p>将每一个簇点信息，写入 <code>yolo_anchors.txt</code> 文件，文件格式是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">w1,h1 w2,h2 ... wk,hk<br></code></pre></td></tr></table></figure>
<h5 id="YOLO-Kmeans-avg-iou"><a href="#YOLO-Kmeans-avg-iou" class="headerlink" title="YOLO_Kmeans.avg_iou"></a><code>YOLO_Kmeans.avg_iou</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">avg_iou</span><span class="hljs-params">(self, boxes, clusters)</span>:</span><br>    accuracy = np.mean([np.max(self.iou(boxes, clusters), axis=<span class="hljs-number">1</span>)])<br>    <span class="hljs-keyword">return</span> accuracy<br></code></pre></td></tr></table></figure>
<p>用于评价聚类效果，这里的准确率是 n 个盒子的平均最大交并比。对于每个盒子来说，与盒子 IOU 最大的簇，一定是这个盒子所属的簇，所以 acc 可以理解为是 n 个盒子和它所属的簇的 IOU 的均值。acc 越大，说明簇分布的越好。</p>
<p>具体算法是</p>
<script type="math/tex; mode=display">
Accuracy=\frac{\sum_{i=1}^n IOU_{max}(Box_i)}{n}</script><p>其中，</p>
<script type="math/tex; mode=display">
IOU_{max}(Box_i)=\max_{i}\{ IOU(Box_i,C_j) \}</script><p>即 n 个盒子和 k 个簇进行 IOU 运算，对于每个盒子选择 IOU 最大的值作为代表，最终求 n 个 IOU 的均值作为准确率。</p>
<h4 id="实现函数"><a href="#实现函数" class="headerlink" title="实现函数"></a>实现函数</h4><p>在 <code>\kmeans.py</code> 文件中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:<br>    cluster_number = <span class="hljs-number">9</span><br>    filename = <span class="hljs-string">"2007_train.txt"</span><br>    kmeans = YOLO_Kmeans(cluster_number, filename)<br>    kmeans.txt2clusters()<br></code></pre></td></tr></table></figure>
<p>整体来说，这个脚本干了两件事，一个是求符合 YOLO 要求的 Kmeans，一个是把这个结果保存成文本。</p>
<h2 id="读入数据"><a href="#读入数据" class="headerlink" title="读入数据"></a>读入数据</h2><p>YOLO3 需要将训练数据载入后进行一些处理才能用于训练，这部分代码主要位于 <code>train.py</code> 文件。</p>
<h4 id="基础函数-1"><a href="#基础函数-1" class="headerlink" title="基础函数"></a>基础函数</h4><h5 id="get-random-data"><a href="#get-random-data" class="headerlink" title="get_random_data"></a><code>get_random_data</code></h5><p>在<code>yolo3\utils.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_random_data</span><span class="hljs-params">(annotation_line, input_shape, random=True, max_boxes=<span class="hljs-number">20</span>, jitter=<span class="hljs-number">.3</span>, hue=<span class="hljs-number">.1</span>, sat=<span class="hljs-number">1.5</span>, val=<span class="hljs-number">1.5</span>, proc_img=True)</span>:</span><br>    <span class="hljs-string">'''为实现实时数据增强的随机预处理'''</span><br>    line = annotation_line.split()<br>    <span class="hljs-comment"># 打开图片</span><br>    image = Image.open(line[<span class="hljs-number">0</span>])<br>    iw, ih = image.size<br>    h, w = input_shape<br>    box = np.array([np.array(list(map(int,box.split(<span class="hljs-string">','</span>)))) <span class="hljs-keyword">for</span> box <span class="hljs-keyword">in</span> line[<span class="hljs-number">1</span>:]]) <span class="hljs-comment">#box = [[x_min,y_min,x_max,y_max,class_id],..]</span><br>    <br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> random:<br>        <span class="hljs-comment"># 调整图像尺寸,使其与input_shape一致</span><br>        scale = min(w/iw, h/ih)<br>        nw = int(iw*scale)<br>        nh = int(ih*scale)<br>        dx = (w-nw)//<span class="hljs-number">2</span><br>        dy = (h-nh)//<span class="hljs-number">2</span><br>        image_data=<span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> proc_img:<br>            image = image.resize((nw,nh), Image.BICUBIC)<br>            new_image = Image.new(<span class="hljs-string">'RGB'</span>, (w,h), (<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>))<br>            new_image.paste(image, (dx, dy))<br>            image_data = np.array(new_image)/<span class="hljs-number">255.</span><br><br>        <span class="hljs-comment"># 修正 boxes</span><br>        box_data = np.zeros((max_boxes,<span class="hljs-number">5</span>))<br>        <span class="hljs-keyword">if</span> len(box)&gt;<span class="hljs-number">0</span>:<br>            np.random.shuffle(box)<br>            <span class="hljs-keyword">if</span> len(box)&gt;max_boxes: box = box[:max_boxes]<br>            box[:, [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]] = box[:, [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]]*scale + dx<br>            box[:, [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]] = box[:, [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]]*scale + dy<br>            box_data[:len(box)] = box<br><br>        <span class="hljs-keyword">return</span> image_data, box_data<br><br>    <span class="hljs-comment"># 随机调整图像长宽比，长宽比改变范围由 jitter 参数控制</span><br>    new_ar = w/h * rand(<span class="hljs-number">1</span>-jitter,<span class="hljs-number">1</span>+jitter)/rand(<span class="hljs-number">1</span>-jitter,<span class="hljs-number">1</span>+jitter)<br>    <span class="hljs-comment">#随机缩放图像，缩放范围为（0.25，2）</span><br>    scale = rand(<span class="hljs-number">.25</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">if</span> new_ar &lt; <span class="hljs-number">1</span>:<br>        nh = int(scale*h)<br>        nw = int(nh*new_ar)<br>    <span class="hljs-keyword">else</span>:<br>        nw = int(scale*w)<br>        nh = int(nw/new_ar)<br>    image = image.resize((nw,nh), Image.BICUBIC)<br><br>   <br>    <span class="hljs-comment"># 图像随机平移</span><br>    <span class="hljs-comment"># 调整图像尺寸,使其与input_shape一致，多的裁掉，少的用灰色填空</span><br>    dx = int(rand(<span class="hljs-number">0</span>, w-nw))<br>    dy = int(rand(<span class="hljs-number">0</span>, h-nh))<br>    new_image = Image.new(<span class="hljs-string">'RGB'</span>, (w,h), (<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>))<br>    new_image.paste(image, (dx, dy))<br>    image = new_image<br><br>    <span class="hljs-comment"># 随机左右翻转，翻转概率 0.5</span><br>    flip = rand()&lt;<span class="hljs-number">.5</span><br>    <span class="hljs-keyword">if</span> flip: image = image.transpose(Image.FLIP_LEFT_RIGHT)<br><br>    <span class="hljs-comment"># 对图像的色调、饱和度、明度进行随机调整   </span><br>    hue = rand(-hue, hue)<br>    sat = rand(<span class="hljs-number">1</span>, sat) <span class="hljs-keyword">if</span> rand()&lt;<span class="hljs-number">.5</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>/rand(<span class="hljs-number">1</span>, sat) <br>    val = rand(<span class="hljs-number">1</span>, val) <span class="hljs-keyword">if</span> rand()&lt;<span class="hljs-number">.5</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>/rand(<span class="hljs-number">1</span>, val)<br>    <span class="hljs-comment"># HUE 色调; Saturation 饱和度; Value 明度</span><br>    x = rgb_to_hsv(np.array(image)/<span class="hljs-number">255.</span>)<br>    x[..., <span class="hljs-number">0</span>] += hue<br>    x[..., <span class="hljs-number">0</span>][x[..., <span class="hljs-number">0</span>]&gt;<span class="hljs-number">1</span>] -= <span class="hljs-number">1</span><br>    x[..., <span class="hljs-number">0</span>][x[..., <span class="hljs-number">0</span>]&lt;<span class="hljs-number">0</span>] += <span class="hljs-number">1</span><br>    x[..., <span class="hljs-number">1</span>] *= sat<br>    x[..., <span class="hljs-number">2</span>] *= val<br>    x[x&gt;<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    x[x&lt;<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    image_data = hsv_to_rgb(x) <span class="hljs-comment"># numpy array, 0 to 1</span><br><br>    <span class="hljs-comment"># 修正盒子信息</span><br>    box_data = np.zeros((max_boxes,<span class="hljs-number">5</span>))<br>    <span class="hljs-keyword">if</span> len(box)&gt;<span class="hljs-number">0</span>:<br>        np.random.shuffle(box)<br>        <span class="hljs-comment"># box 缩放与位移</span><br>        box[:, [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]] = box[:, [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]]*nw/iw + dx<br>        box[:, [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]] = box[:, [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]]*nh/ih + dy<br>        <span class="hljs-comment"># box 反转</span><br>        <span class="hljs-keyword">if</span> flip: box[:, [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]] = w - box[:, [<span class="hljs-number">2</span>,<span class="hljs-number">0</span>]]<br>        <span class="hljs-comment"># box 截掉超出边界的</span><br>        box[:, <span class="hljs-number">0</span>:<span class="hljs-number">2</span>][box[:, <span class="hljs-number">0</span>:<span class="hljs-number">2</span>]&lt;<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        box[:, <span class="hljs-number">2</span>][box[:, <span class="hljs-number">2</span>]&gt;w] = w<br>        box[:, <span class="hljs-number">3</span>][box[:, <span class="hljs-number">3</span>]&gt;h] = h<br>        <span class="hljs-comment"># box 丢弃过小的</span><br>        box_w = box[:, <span class="hljs-number">2</span>] - box[:, <span class="hljs-number">0</span>]<br>        box_h = box[:, <span class="hljs-number">3</span>] - box[:, <span class="hljs-number">1</span>]<br>        box = box[np.logical_and(box_w&gt;<span class="hljs-number">1</span>, box_h&gt;<span class="hljs-number">1</span>)] <span class="hljs-comment"># discard invalid box</span><br>        <span class="hljs-keyword">if</span> len(box)&gt;max_boxes: box = box[:max_boxes]<br>        box_data[:len(box)] = box<br><br>    <span class="hljs-keyword">return</span> image_data, box_data<br></code></pre></td></tr></table></figure>
<p><code>get_random_data</code> 函数用于从 YOLO3 的标注文件生成训练所需的图像信息，同时还提供了对图像的随机数据增强。具体实现看注释吧。</p>
<p>参数：</p>
<ul>
<li><strong>annotation_line</strong>：标注文件中某一行的文本信息，通过这一行文本来获取图片路径和盒子信息。</li>
<li><strong>input_shape</strong>：指网络的输入尺寸，最终图像会被调整到这个尺寸</li>
<li><strong>random=True</strong>：是否开启随机数据增强，默认开启，如果不开启就是单纯的缩放个尺寸</li>
<li><strong>max_boxes=20</strong>：最大盒子数，默认20</li>
<li><strong>jitter=.3</strong>：开启随机数据增强时，这个参数影响长宽比变化范围</li>
<li><strong>hue=.1</strong>：开启随机数据增强时，这个参数影响色调变化范围</li>
<li><strong>sat=1.5</strong>：开启随机数据增强时，这个参数影响饱和度变化范围</li>
<li><strong>val=1.5</strong>：开启随机数据增强时，这个参数影响明度变化范围</li>
<li><strong>proc_img=True</strong>：没整明白存在的意义，True 就完事了</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回一个元组，<code>(image_data, box_data)</code></li>
<li><code>image_data</code> 形如 <code>(h,w,3)</code>，值域 0 到 1</li>
<li><code>box_data</code> 二维数组，结构类似 <code>[[x_min,y_min,x_max,y_max,class_id],..]</code>，它的形状为 <code>shape=(max_boxes,5)</code>，5 是指相对于输入尺寸的绝对坐标 <code>x_min, y_min, x_max, y_max,</code> 和类别号  <code>class_id</code></li>
</ul>
<h5 id="preprocess-true-boxes"><a href="#preprocess-true-boxes" class="headerlink" title="preprocess_true_boxes"></a><code>preprocess_true_boxes</code></h5><p>在<code>yolo3\model.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">preprocess_true_boxes</span><span class="hljs-params">(true_boxes, input_shape, anchors, num_classes)</span>:</span><br>    <span class="hljs-keyword">assert</span> (true_boxes[..., <span class="hljs-number">4</span>]&lt;num_classes).all(), <span class="hljs-string">'class id must be less than num_classes'</span><br>    num_layers = len(anchors)//<span class="hljs-number">3</span> <span class="hljs-comment"># default setting</span><br>    anchor_mask = [[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>], [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]] <span class="hljs-keyword">if</span> num_layers==<span class="hljs-number">3</span> <span class="hljs-keyword">else</span> [[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]<br><br>    true_boxes = np.array(true_boxes, dtype=<span class="hljs-string">'float32'</span>)<br>    input_shape = np.array(input_shape, dtype=<span class="hljs-string">'int32'</span>)<br>    boxes_xy = (true_boxes[..., <span class="hljs-number">0</span>:<span class="hljs-number">2</span>] + true_boxes[..., <span class="hljs-number">2</span>:<span class="hljs-number">4</span>]) // <span class="hljs-number">2</span><br>    boxes_wh = true_boxes[..., <span class="hljs-number">2</span>:<span class="hljs-number">4</span>] - true_boxes[..., <span class="hljs-number">0</span>:<span class="hljs-number">2</span>]<br>    true_boxes[..., <span class="hljs-number">0</span>:<span class="hljs-number">2</span>] = boxes_xy/input_shape[::<span class="hljs-number">-1</span>]<br>    true_boxes[..., <span class="hljs-number">2</span>:<span class="hljs-number">4</span>] = boxes_wh/input_shape[::<span class="hljs-number">-1</span>]<br><br>    m = true_boxes.shape[<span class="hljs-number">0</span>]<br>    grid_shapes = [input_shape//&#123;<span class="hljs-number">0</span>:<span class="hljs-number">32</span>, <span class="hljs-number">1</span>:<span class="hljs-number">16</span>, <span class="hljs-number">2</span>:<span class="hljs-number">8</span>&#125;[l] <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> range(num_layers)]<br>    y_true = [np.zeros((m,grid_shapes[l][<span class="hljs-number">0</span>],grid_shapes[l][<span class="hljs-number">1</span>],len(anchor_mask[l]),<span class="hljs-number">5</span>+num_classes),<br>        dtype=<span class="hljs-string">'float32'</span>) <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> range(num_layers)]<br><br>    <span class="hljs-comment"># Expand dim to apply broadcasting.</span><br>    anchors = np.expand_dims(anchors, <span class="hljs-number">0</span>)<br>    anchor_maxes = anchors / <span class="hljs-number">2.</span><br>    anchor_mins = -anchor_maxes<br>    valid_mask = boxes_wh[..., <span class="hljs-number">0</span>]&gt;<span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> range(m):<br>        <span class="hljs-comment"># Discard zero rows.</span><br>        wh = boxes_wh[b, valid_mask[b]]<br>        <span class="hljs-keyword">if</span> len(wh)==<span class="hljs-number">0</span>: <span class="hljs-keyword">continue</span><br>        <span class="hljs-comment"># Expand dim to apply broadcasting.</span><br>        wh = np.expand_dims(wh, <span class="hljs-number">-2</span>)<br>        box_maxes = wh / <span class="hljs-number">2.</span><br>        box_mins = -box_maxes<br><br>        intersect_mins = np.maximum(box_mins, anchor_mins)<br>        intersect_maxes = np.minimum(box_maxes, anchor_maxes)<br>        intersect_wh = np.maximum(intersect_maxes - intersect_mins, <span class="hljs-number">0.</span>)<br>        intersect_area = intersect_wh[..., <span class="hljs-number">0</span>] * intersect_wh[..., <span class="hljs-number">1</span>]<br>        box_area = wh[..., <span class="hljs-number">0</span>] * wh[..., <span class="hljs-number">1</span>]<br>        anchor_area = anchors[..., <span class="hljs-number">0</span>] * anchors[..., <span class="hljs-number">1</span>]<br>        iou = intersect_area / (box_area + anchor_area - intersect_area)<br><br>        <span class="hljs-comment"># Find best anchor for each true box</span><br>        best_anchor = np.argmax(iou, axis=<span class="hljs-number">-1</span>)<br><br>        <span class="hljs-keyword">for</span> t, n <span class="hljs-keyword">in</span> enumerate(best_anchor):<br>            <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> range(num_layers):<br>                <span class="hljs-keyword">if</span> n <span class="hljs-keyword">in</span> anchor_mask[l]:<br>                    i = np.floor(true_boxes[b,t,<span class="hljs-number">0</span>]*grid_shapes[l][<span class="hljs-number">1</span>]).astype(<span class="hljs-string">'int32'</span>)<br>                    j = np.floor(true_boxes[b,t,<span class="hljs-number">1</span>]*grid_shapes[l][<span class="hljs-number">0</span>]).astype(<span class="hljs-string">'int32'</span>)<br>                    k = anchor_mask[l].index(n)<br>                    c = true_boxes[b,t, <span class="hljs-number">4</span>].astype(<span class="hljs-string">'int32'</span>)<br>                    y_true[l][b, j, i, k, <span class="hljs-number">0</span>:<span class="hljs-number">4</span>] = true_boxes[b,t, <span class="hljs-number">0</span>:<span class="hljs-number">4</span>]<br>                    y_true[l][b, j, i, k, <span class="hljs-number">4</span>] = <span class="hljs-number">1</span><br>                    y_true[l][b, j, i, k, <span class="hljs-number">5</span>+c] = <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">return</span> y_true<br></code></pre></td></tr></table></figure>
<p>该函数用于将真实盒子信息转化成训练所需要的格式。</p>
<p>参数：</p>
<ul>
<li><strong>true_boxes</strong>: 多维数组，要求形状为 <code>(batch_size,boxes_number,5)</code> 由 <code>get_random_data</code> 生成</li>
<li><strong>input_shape</strong>: 网络的输入尺寸应该是32的倍数，注意这里的尺寸是 <strong>高在前、宽在后</strong></li>
<li><strong>anchors</strong>: 锚框，形状为<code>(k,2)</code> k是锚框个数; 2 是<code>(w,h)</code></li>
<li><strong>num_classes</strong>: 整型,总类别数</li>
</ul>
<p>返回：</p>
<ul>
<li><strong>y_true</strong> ：和 yolo3 网络输出的数据同型的数组，此时的 wxyh 已经换为相对路径</li>
</ul>
<p>执行过程：</p>
<ul>
<li><p>计算 YOLO3 网络输出的特征图数目，这里认为输出的特征图数目与锚框数目有关，经典 YOLO3 输出三个特征图，每个特征图 3 个锚框，共 9 个。tiny-YOLO 则输出 2 个特征图，每个特征图 3 个锚框，所以可由锚框数目求 YOLO3 输出的特征图数目，并分辨网络类型。其中：</p>
<ul>
<li><code>num_layers</code> 表示输出特征图数目</li>
<li><p><code>anchor_mask</code> 是锚框掩码，用于规定每个特征图用哪几个锚框</p>
<p>之后均以 <strong>YOLO3 输出三个特征图，每个特征图 3 个锚框</strong> 为例。</p>
</li>
</ul>
</li>
<li><p>对于参数 <code>true_boxes</code> 和 <code>input_shape</code> 进行类型转换</p>
</li>
<li><p>求出每个盒子的中心点坐标 <code>boxes_xy</code> 与宽高信息 <code>boxes_wh</code> 这两个参数形状为 <code>(batch_size,boxes_number,2)</code> </p>
</li>
<li><p>对  <code>true_boxes</code>  中的位置和宽高进行修改，将其改为相对于原图的比例数值，称新的 <code>true_boxes[..., 0:4]</code> 为<strong>最小横坐标比例、最小纵坐标比例、最大横坐标比例、最大纵坐标比例</strong></p>
</li>
<li><p>求 <code>grid_shapes</code> ,  <code>grid_shapes</code> 表示每个输出的特征图的两个方向各自分布多少网格。对于最终输出的特诊图而言，特征图上的一个点对应原图的一个区域，这个区域被称为网格，所以可以理解为这个变量表示的是输出的每个特征图的宽和高，经典 YOLO3 输出三个特征图，每个特征图大小别为原图宽高分别除 32、原图宽高分别除 16 、原图宽高分别除 8，最终 <code>grid_shapes</code> 的结构是 np 数组的列表：<br>  <code>[np.array([f1_w,f1_h]),np.array([f2_w,f2_h]),np.array([f3_w,f3_h])]</code> ，其中 <code>f1_w,f1_h</code> 表示最终输出的特征图里第一个特征图的宽和高。</p>
</li>
<li><p>创建 <code>y_true</code> ，此时只是先把 <code>y_true</code> 的结构定下来，其值用 0 填充，具体数值后面再填，<code>y_true</code> 的结构也是 np 数组的列表 ，它的结构为 <code>[y_true_1,y_true_2,y_true_3]</code> 。其中 <code>y_true_*</code> 是 np 数组，表示一个特征图中包含的真实信息，它的<code>shape=(批数,特征图高,特征图宽,3,5+类别数)</code></p>
</li>
<li><p>之后的代码是针对每批数据而言，故之后的代码 <strong>假设处理下标为 <code>b</code> 的一批数据</strong></p>
</li>
<li><p>对 <code>b</code>  批数据的对每个盒子对预设的锚框进行 IOU 运算，这里是假设中心点重合的 IOU，最终目的是求 <code>best_anchor</code> 。<code>best_anchor</code> 表示对于每个盒子而言，参数 <code>anchors</code> 里的哪个锚框和这个盒子重合度最高，它的 <code>shape=(valid_boxes_number,)</code> ，即长度为<code>valid_boxes_number</code> 的向量，其中 <code>valid_boxes_number</code> 为有效盒子数，有效盒子被定义为宽度大于 0 的盒子。</p>
<blockquote>
<p>这里的实现有个细节，就是 <code>anchors</code> 被扩充维度成 <code>shape=(1,k,2)</code> 而<code>wh</code>被扩充维度为 <code>shape=(boxes_number,1,2)</code> 所以最终他们的运算结果由 <code>broadcasting</code> 变成 <code>shape=(boxes_number,k,2)</code></p>
</blockquote>
</li>
<li><p>之后是一个二层循环，分别表示遍历<code>best_anchor</code>，遍历每个输出特征图，变量 <code>b,t,n,l</code>  都是索引号，分别表示：<strong>第 b 号批  、第 t 号盒子 、第t 号盒子的最大重合 anchor 索引号为 n 、第 l 号特征图</strong></p>
</li>
<li><p>如果第 t 号盒子的最大索引号 n，在第 l 号特征图的锚框掩码中，则说明，第l 号特征图内有锚框负责这个盒子，此时：</p>
<ul>
<li><p>令 <code>i</code> 等于第 b 号批里第 t 号盒子的最大横坐标比例*第 l 号特征图的宽，并向下取整</p>
</li>
<li><p>令 <code>j</code> 等于第 b 号批里第 t 号盒子的最小纵坐标比例*第 l 号特征图的高，并向下取整</p>
<blockquote>
<p>此时 <code>j,i</code> 表示第 l 号特征图中，负责这个物体的网格坐标。</p>
</blockquote>
</li>
<li><p>令 <code>k</code> 等于第 n 号锚框在第 l 号特征的索引号，<code>k</code> 只能取 0,1,2</p>
</li>
<li><p>令 <code>c</code> 等于第 b 号批里第 t 号盒子的类别号</p>
</li>
<li><p>最后填充，第 l 号特征图中的，第 b 号批数据里，第 j 行 、第 i 列，第 k 号锚框，使其坐标信息等于 b 号批里第 t 号盒子的坐标信息、置信度等于 1、类别信息等于 c （即令 <code>y_true[l][..,5+c] = 1</code> )</p>
</li>
</ul>
</li>
<li><p>上述过程把 <code>y_true</code> 该填的完，负责物体的锚框有对应值，不负责物体的锚框的值为 0，最后强调，<code>y_true</code> 是一个三元素列表，每个元素的 <code>shape=(批数,特征图高,特征图宽,3,5+类别数)</code> ，每个元素的元素可视为长度为 <code>5+类别数</code> 的特征向量，特征向量中的位置信息是<strong>相对于原图</strong>的最小横坐标比例、最小纵坐标比例、最大横坐标比例、最大纵坐标比例。</p>
</li>
</ul>
<h4 id="实现函数-1"><a href="#实现函数-1" class="headerlink" title="实现函数"></a>实现函数</h4><p>训练数据是由 <code>data_generator_wrapper</code> 生成：</p>
<h5 id="data-generator-wrapper"><a href="#data-generator-wrapper" class="headerlink" title="data_generator_wrapper"></a><code>data_generator_wrapper</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">data_generator_wrapper(annotation_lines, batch_size, input_shape, anchors, num_classes):<br>    n = len(annotation_lines)<br>    <span class="hljs-keyword">if</span> n==<span class="hljs-number">0</span> <span class="hljs-keyword">or</span> batch_size&lt;=<span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">return</span> data_generator(annotation_lines, batch_size, input_shape, anchors, num_classes)<br></code></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li><strong>annotation_lines</strong>：yolo3 标注文件的行数，也就是总训练样本数</li>
<li><strong>batch_size</strong> ：批大小</li>
<li><strong>input_shape</strong> ：二维元组，输入张量的形状，要求32的倍数，YOLO3 设置为 (416,416)</li>
<li><strong>anchors</strong> ：锚框列表，<code>get_anchors</code> 函数得到，形如<code>[[w1,h1],[w2,h2]...]</code></li>
<li><strong>num_classes</strong> ：类别数目，由 <code>len(get_classes(classes_path))</code> 得到</li>
</ul>
<p><code>data_generator_wrapper</code> 只是对参数进行简单的检验，最终数据由 <code>data_generator</code> 生成</p>
<h5 id="data-generator"><a href="#data-generator" class="headerlink" title="data_generator"></a><code>data_generator</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">data_generator</span><span class="hljs-params">(annotation_lines, batch_size, input_shape, anchors, num_classes)</span>:</span><br>    <span class="hljs-string">'''data generator for fit_generator'''</span><br>    n = len(annotation_lines)<br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        image_data = []<br>        box_data = []<br>        <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> range(batch_size):<br>            <span class="hljs-keyword">if</span> i==<span class="hljs-number">0</span>:<br>                np.random.shuffle(annotation_lines)<br>            image, box = get_random_data(annotation_lines[i], input_shape, random=<span class="hljs-literal">True</span>)<br>            image_data.append(image)<br>            box_data.append(box)<br>            i = (i+<span class="hljs-number">1</span>) % n<br>        image_data = np.array(image_data)<br>        box_data = np.array(box_data)<br>        y_true = preprocess_true_boxes(box_data, input_shape, anchors, num_classes)<br>        <span class="hljs-keyword">yield</span> [image_data, *y_true], np.zeros(batch_size)<br></code></pre></td></tr></table></figure>
<p><code>data_generator</code> 是一个生成器，所以用 <code>yield</code> 替代 <code>return</code> ，这生成器直接作用于 <code>model.fit_generator</code> ，所以生成器生成的数据，就是每一<code>epoch</code> 训练的数据。</p>
<p>生成器的参数和 <code>data_generator_wrapper</code> 参数一致。</p>
<p><code>model.fit_generator</code> 要求 <code>data_generator</code>  返回一个下面任意一个元组：</p>
<ul>
<li>a tuple <code>(inputs, targets)</code></li>
<li>a tuple <code>(inputs, targets, sample_weights)</code></li>
</ul>
<p>这里 <code>data_generator</code>   返回的是 <code>(inputs, targets)</code> 它的 inputs 是 <code>[image_data, *y_true]</code> , 它的 targets 是长为 <code>batch_size</code> 的全 0 向量。</p>
<p>执行过程：</p>
<ul>
<li>统计样本总数 <code>n = len(annotation_lines)</code> , 设置计数变量 <code>i = 0</code> </li>
<li>通过 while-yield 结构设计生成器 </li>
<li>每次生成数据的时候 , 执行 <code>batch_size</code> 次循环<ul>
<li>如果 <code>i==0</code> 说明第一次生成数据 , 或者所有样本都已经被生成一遍了 , 此时用 <code>np.random.shuffle(annotation_lines)</code> 将样本打乱</li>
<li>通过 <code>get_random_data(annotation_lines[i], input_shape, random=True)</code> 获得第 i 个样本的图片信息和图片上的盒子信息 <code>image, box</code></li>
<li>将图片信息和标注信息分布追加到<code>image_data, box_data</code></li>
<li><code>i = (i+1) % n</code> 表示该读下一个样本了</li>
</ul>
</li>
<li>将 <code>image_data, box_data</code> 包装为 np 数据</li>
<li>通过 <code>preprocess_true_boxes(box_data, input_shape, anchors, num_classes)</code> 由盒子信息获取 loss 函数所需的目标信息 <code>y_true</code></li>
<li>返回 <code>[image_data, *y_true], np.zeros(batch_size)</code></li>
</ul>
</div><div class="article-tags size-small is-uppercase mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/YOLO3/">YOLO3</a><a class="link-muted mr-2" rel="tag" href="/tags/Keras/">Keras</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/04/04/YOLO3%20%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">YOLO3 网络结构 Keras源码分析</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/04/04/YOLO3%20%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><span class="level-item">YOLO3 目标检测与性能评价 Keras源码分析</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="" src="/img/avatar.png" alt="刘之帅"></figure><p class="title is-size-4 is-block line-height-inherit">刘之帅</p><p class="is-size-6 is-block">lzs783@qq.com</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>LiaoNing</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">4</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/LogicForeach/" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/LogicForeach/"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Web" href="https://logicforeach.net"><i class="fab fa-internet-explorer"></i></a></div></div></div><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#前言"><span class="mr-2">1</span><span>前言</span></a></li><li><a class="is-flex" href="#数据处理"><span class="mr-2">2</span><span>数据处理</span></a><ul class="menu-list"><li><a class="is-flex" href="#数据集转换"><span class="mr-2">2.1</span><span>数据集转换</span></a></li><li><a class="is-flex" href="#源码分析"><span class="mr-2">2.2</span><span>源码分析</span></a><ul class="menu-list"><li><a class="is-flex" href="#convert-annotation-year-image-id-list-file"><span class="mr-2">2.2.1</span><span>convert_annotation(year, image_id, list_file)</span></a></li><li><a class="is-flex" href="#脚本主内容"><span class="mr-2">2.2.2</span><span>脚本主内容</span></a></li></ul></li><li><a class="is-flex" href="#使用-K-means-生成锚框"><span class="mr-2">2.3</span><span>使用 K-means 生成锚框</span></a><ul class="menu-list"><li><a class="is-flex" href="#理论基础"><span class="mr-2">2.3.1</span><span>理论基础</span></a></li><li><a class="is-flex" href="#YOLO-Kmeans-avg-iou"><span class="mr-2">2.3.2</span><span>YOLO_Kmeans.avg_iou</span></a></li><li><a class="is-flex" href="#实现函数"><span class="mr-2">2.3.3</span><span>实现函数</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#读入数据"><span class="mr-2">3</span><span>读入数据</span></a><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex" href="#preprocess-true-boxes"><span class="mr-2">3.1.1</span><span>preprocess_true_boxes</span></a></li><li><a class="is-flex" href="#data-generator"><span class="mr-2">3.1.2</span><span>data_generator</span></a></li></ul></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://blog.csdn.net/lzs781" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">CSDN</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/YOLO3-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><span class="level-start"><span class="level-item">YOLO3 源码分析</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">深度学习</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-05T13:53:29.833Z">2020-04-05</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83/">机器学习中的“分布”</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-04T11:00:09.966Z">2020-04-04</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/04/YOLO3%20%E5%8F%82%E6%95%B0%E5%AD%A6%E4%B9%A0%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">YOLO3 参数学习 Keras源码分析</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/YOLO3-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">YOLO3 源码分析</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-04T11:00:08.849Z">2020-04-04</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/04/YOLO3%20%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">YOLO3 网络结构 Keras源码分析</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/YOLO3-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">YOLO3 源码分析</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-04T11:00:08.811Z">2020-04-04</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/04/YOLO3%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">YOLO3 数据处理与数据加载 Keras源码分析</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/YOLO3-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">YOLO3 源码分析</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-04T10:37:51.338Z">2020-04-04</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/04/YOLO3%20%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">YOLO3 目标检测与性能评价 Keras源码分析</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/YOLO3-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">YOLO3 源码分析</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Keras/"><span class="tag">Keras</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/YOLO3/"><span class="tag">YOLO3</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/"><span class="tag">概率分布</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="tag">深度学习</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/LOGO.jpg" alt="LogicForeach" height="28"></a><p class="size-small"><span>&copy; 2020 刘之帅</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a>  <img src="https://static.dy208.cn/o_1dfilp8ruo521thr1hvf18ji17soa.png"><a href="http://beian.miit.gov.cn" style="color:#f72b07" target="_blank">辽ICP备17015584号</a></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'logicforeach.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><script>window.addEventListener("load", function () {
            MathJax.Hub.Config({
                'HTML-CSS': {
                    matchFontHeight: false
                },
                SVG: {
                    matchFontHeight: false
                },
                CommonHTML: {
                    matchFontHeight: false
                },
                tex2jax: {
                    inlineMath: [
                        ['$','$'],
                        ['\\(','\\)']
                    ]
                }
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>