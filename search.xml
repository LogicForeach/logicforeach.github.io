<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用高阶导数公式求复杂导数</title>
      <link href="/2020/05/02/%E4%BD%BF%E7%94%A8%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0%E5%85%AC%E5%BC%8F%E6%B1%82%E5%A4%8D%E6%9D%82%E5%AF%BC%E6%95%B0/"/>
      <url>/2020/05/02/%E4%BD%BF%E7%94%A8%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0%E5%85%AC%E5%BC%8F%E6%B1%82%E5%A4%8D%E6%9D%82%E5%AF%BC%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="使用高阶导数公式求复杂导数"><a href="#使用高阶导数公式求复杂导数" class="headerlink" title="使用高阶导数公式求复杂导数"></a>使用高阶导数公式求复杂导数</h2><p>对f(x)变形，使之化为</p><p><img src="/2020/05/02/%E4%BD%BF%E7%94%A8%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0%E5%85%AC%E5%BC%8F%E6%B1%82%E5%A4%8D%E6%9D%82%E5%AF%BC%E6%95%B0/clip_image002.gif" alt="img"></p><p>其中g(x)导数为有限项，c为常数</p><p>此时使用高阶导数公式</p><p><img src="/2020/05/02/%E4%BD%BF%E7%94%A8%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0%E5%85%AC%E5%BC%8F%E6%B1%82%E5%A4%8D%E6%9D%82%E5%AF%BC%E6%95%B0/clip_image004.gif" alt="img"></p><p>由于</p><p><img src="/2020/05/02/%E4%BD%BF%E7%94%A8%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0%E5%85%AC%E5%BC%8F%E6%B1%82%E5%A4%8D%E6%9D%82%E5%AF%BC%E6%95%B0/clip_image006.gif" alt="img"></p><p>为有限项，故可得递推式</p><p><img src="/2020/05/02/%E4%BD%BF%E7%94%A8%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0%E5%85%AC%E5%BC%8F%E6%B1%82%E5%A4%8D%E6%9D%82%E5%AF%BC%E6%95%B0/clip_image008.gif" alt="img"></p><p>若f(x)无法化成上述形式，可考虑对其一阶导数、二阶导数进行变形。</p><p>例:</p><p>已知</p><p><img src="/2020/05/02/%E4%BD%BF%E7%94%A8%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0%E5%85%AC%E5%BC%8F%E6%B1%82%E5%A4%8D%E6%9D%82%E5%AF%BC%E6%95%B0/clip_image010.gif" alt="img"></p><p>求</p><p><img src="/2020/05/02/%E4%BD%BF%E7%94%A8%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0%E5%85%AC%E5%BC%8F%E6%B1%82%E5%A4%8D%E6%9D%82%E5%AF%BC%E6%95%B0/clip_image012.gif" alt="img"></p><p>解：</p><p><img src="/2020/05/02/%E4%BD%BF%E7%94%A8%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0%E5%85%AC%E5%BC%8F%E6%B1%82%E5%A4%8D%E6%9D%82%E5%AF%BC%E6%95%B0/clip_image014.gif" alt="img"></p><p>通过上述递推式可解</p>]]></content>
      
      
      <categories>
          
          <category> 考研数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 泰勒公式 </tag>
            
            <tag> 高阶导数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用泰勒公式求高阶导数</title>
      <link href="/2020/05/02/%E4%BD%BF%E7%94%A8%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F%E6%B1%82%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0/"/>
      <url>/2020/05/02/%E4%BD%BF%E7%94%A8%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F%E6%B1%82%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>使用泰勒公式求高阶导数</strong></p><p>写出f(x)泰勒展开的抽象公式</p><p><img src="/2020/05/02/%E4%BD%BF%E7%94%A8%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F%E6%B1%82%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0/clip_image002.gif" alt="img"></p><p>写出部分因式的具体展开，形如：</p><p><img src="/2020/05/02/%E4%BD%BF%E7%94%A8%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F%E6%B1%82%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0/clip_image004.gif" alt="img"></p><p>其中，P(x-a)表示关于x-a的无穷次多项式，g(a)是常数，所以最终结果也是关于(x-a)的无穷次多项式，系数为bn</p><p>由于泰勒展开具有唯一性，故下式恒成立</p><p><img src="/2020/05/02/%E4%BD%BF%E7%94%A8%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F%E6%B1%82%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0/clip_image006.gif" alt="img"></p><p>由待定系数法法，可求抽象公式中x-a的n次项前的系数，即</p><p><img src="/2020/05/02/%E4%BD%BF%E7%94%A8%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F%E6%B1%82%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0/clip_image008.gif" alt="img"></p><p>例：</p><p>已知</p><p><img src="/2020/05/02/%E4%BD%BF%E7%94%A8%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F%E6%B1%82%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0/clip_image010.gif" alt="img"></p><p>求</p><p><img src="/2020/05/02/%E4%BD%BF%E7%94%A8%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F%E6%B1%82%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0/clip_image012.gif" alt="img"></p><p>解：</p><p><img src="/2020/05/02/%E4%BD%BF%E7%94%A8%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F%E6%B1%82%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0/clip_image014.gif" alt="img"></p><p>当泰勒展开不在0点是，可通过变形，使之变为关于x-a的函数，令其在0 点展开，例如：</p><p><img src="/2020/05/02/%E4%BD%BF%E7%94%A8%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F%E6%B1%82%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0/clip_image016.gif" alt="img"></p><p>解</p><p><img src="/2020/05/02/%E4%BD%BF%E7%94%A8%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F%E6%B1%82%E9%AB%98%E9%98%B6%E5%AF%BC%E6%95%B0/clip_image018.gif" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 考研数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 泰勒公式 </tag>
            
            <tag> 高阶导数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记忆仓库-使用指南</title>
      <link href="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/"/>
      <url>/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="使用微信扫描进入记忆仓库"><a href="#使用微信扫描进入记忆仓库" class="headerlink" title="使用微信扫描进入记忆仓库"></a>使用微信扫描进入记忆仓库</h3><p>使用微信扫描下方二维码进入记忆仓库</p><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image001.png" style="zoom: 50%;"></p><a id="more"></a><p>登录完成后，即可以看到记忆仓库的主页</p><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image003.png" style="zoom:50%;"></p><h2 id="记忆库管理"><a href="#记忆库管理" class="headerlink" title="记忆库管理"></a>记忆库管理</h2><h3 id="创建记忆库"><a href="#创建记忆库" class="headerlink" title="创建记忆库"></a>创建记忆库</h3><ul><li>点击下方导航栏中【记忆库】，进入到记忆库管理页面，点击【加号】</li></ul><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image005.png" style="zoom:50%;"></p><ul><li>选择【添加记忆库】</li></ul><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image007.jpg" style="zoom:50%;"></p><ul><li>在弹出的菜单中选择【创建新的记忆库】</li></ul><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image009.jpg" style="zoom:50%;"></p><ul><li>输入记忆库名称，即可完成创建。</li></ul><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image011.jpg" style="zoom:50%;"></p><h3 id="修改记忆库名称"><a href="#修改记忆库名称" class="headerlink" title="修改记忆库名称"></a>修改记忆库名称</h3><p>用户可以对已经创建完成的记忆库进行修改名称等操作</p><ul><li>点击记忆库右侧的【工具按钮呢】</li></ul><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image013.jpg" style="zoom:50%;"></p><ul><li>点击【重命名】</li></ul><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image015.jpg" style="zoom:50%;"></p><ul><li>输入新记忆库的名称，点击确定即可。</li></ul><h3 id="删除记忆库"><a href="#删除记忆库" class="headerlink" title="删除记忆库"></a>删除记忆库</h3><p>同样，点击记忆库右侧的【工具按钮】，点击【删除】。</p><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image017.jpg" style="zoom:50%;"></p><h2 id="录入记忆"><a href="#录入记忆" class="headerlink" title="录入记忆"></a>录入记忆</h2><h3 id="直接添加记忆"><a href="#直接添加记忆" class="headerlink" title="直接添加记忆"></a>直接添加记忆</h3><ul><li>用户可以在首页点击【写入记忆】按钮，或者在某一记忆库下点击【加号】，点击【添加记忆】，即进入写入记忆页面</li></ul><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image023.png" style="zoom:50%;"></p><ul><li>在写入记忆页面，用户点击【添加段落】按钮，可以选择不同样式的段落，支持的段落有【标题】【文字】【图片】【画板】四种。</li></ul><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image025.jpg" style="zoom:50%;"></p><ul><li>在画板模式中，用户可以将难以录入的公式、图像等信息，画在手机上，下方左右【箭头】可以移动画板视角，使画板容纳更多信息。完成绘画后，点击【添加到记忆】按钮，即可生成段落。</li></ul><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image027.jpg" style="zoom:50%;"></p><ul><li>同时，记忆仓库支持将多个记忆同时提交，点击下方【添加记忆】按钮，便可以书写第二个记忆的内容。</li></ul><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image031.jpg" style="zoom:50%;"></p><h3 id="文字生成记忆"><a href="#文字生成记忆" class="headerlink" title="文字生成记忆"></a>文字生成记忆</h3><p>用户可以在添加记忆的时候，选择【文字生成记忆】模式。</p><p>对于一段长文字，用户可以在该模式下，将其转换成指定的格式，然后自动录入的记忆仓库中，这里我们约定：<strong>每个记忆用两个及两个以上的换行隔开，每个记忆中，用一个换行来将标题和内容分割。</strong></p><p>例如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">endow…<span class="keyword">with</span> sth. </span><br><span class="line"> 把某物赋予……</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> charge sb. <span class="keyword">with</span> sth. </span><br><span class="line"> 指控某人某罪</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> bear <span class="keyword">little</span>/<span class="keyword">no</span> resemblance <span class="keyword">to</span>… </span><br><span class="line"> 与…没有相似之处</span><br></pre></td></tr></table></figure><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image033.jpg" style="zoom:50%;"></p><p>将自动转化为三个记忆。</p><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image037.jpg" style="zoom:50%;"></p><h2 id="回顾记忆"><a href="#回顾记忆" class="headerlink" title="回顾记忆"></a>回顾记忆</h2><h3 id="回顾记忆-1"><a href="#回顾记忆-1" class="headerlink" title="回顾记忆"></a>回顾记忆</h3><ul><li>用户点击在首页，点击【开始回顾】</li></ul><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image039.png" style="zoom:50%;"></p><ul><li>点击【回顾记忆库】，选择需要回顾的记忆库即可。</li></ul><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image041.png" style="zoom:50%;"></p><ul><li>在记忆仓库回顾的系统中，用户通过标题联想到该记忆的内容，并根据自身实际情况，选择【已掌握】或【未掌握】按钮</li></ul><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image043.png" style="zoom:50%;"></p><ul><li>如果点击了【已掌握】后，发现自己掌握的并不准确，可以点击【更多操作按】将该记忆【标记为未掌握】</li></ul><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image045.png" style="zoom:50%;"></p><h3 id="浏览概要"><a href="#浏览概要" class="headerlink" title="浏览概要"></a>浏览概要</h3><ul><li>点击记忆库右边的【工具】按钮，选择【浏览概要】，即可以进入概要浏览模式</li></ul><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image047.jpg" style="zoom:50%;"></p><ul><li>如果记忆库下有子记忆库，点击继续点击【子记忆库名称】可进入子记忆库</li></ul><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image049.jpg" style="zoom:50%;"></p><ul><li>在该模式下，只显示记忆的标题，点击【记忆的标题】即可查看该记忆的内容。</li></ul><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image051.jpg" style="zoom:50%;"></p><h2 id="分享记忆"><a href="#分享记忆" class="headerlink" title="分享记忆"></a>分享记忆</h2><h3 id="分享给好友"><a href="#分享给好友" class="headerlink" title="分享给好友"></a>分享给好友</h3><ul><li>点击记忆库右边的【工具】按钮</li></ul><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image053.jpg" style="zoom:50%;"></p><ul><li>点击【分享记忆库】，分享成功后，系统会为该记忆库生成分享码，然后将该分享码复制给好友即可。</li></ul><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image055.jpg" style="zoom:50%;"></p><h3 id="获得好友分享的记忆库"><a href="#获得好友分享的记忆库" class="headerlink" title="获得好友分享的记忆库"></a>获得好友分享的记忆库</h3><ul><li>好友接受到该分享码后，可以在添加记忆库时，选择【获取分享记忆库】来接受好友的分享。</li></ul><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image058.jpg" style="zoom:50%;"></p><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image060.jpg" style="zoom:50%;"></p><h2 id="回顾队列"><a href="#回顾队列" class="headerlink" title="回顾队列"></a>回顾队列</h2><h3 id="管理回顾队列"><a href="#管理回顾队列" class="headerlink" title="管理回顾队列"></a>管理回顾队列</h3><ul><li>在主页，点击【我的】选项卡，点击【回顾队列】按钮，则可查看回顾队列。</li></ul><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image065.png" style="zoom:50%;"></p><ul><li>用户可以通过下方【加号】按钮与队列后的【工具】按钮对队列进行增改</li></ul><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image067.png" style="zoom:50%;"></p><h3 id="添加记忆至回顾队列"><a href="#添加记忆至回顾队列" class="headerlink" title="添加记忆至回顾队列"></a>添加记忆至回顾队列</h3><ul><li>用户可以在浏览、回顾记忆时，将某一记忆添加到回顾队列，亦可以将某一记忆库直接导入。点击进入一个回顾队列，点击【加号】按钮，选择批量导入即可。</li></ul><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image069.jpg" style="zoom:50%;"></p><h3 id="复习回顾队列中的记忆"><a href="#复习回顾队列中的记忆" class="headerlink" title="复习回顾队列中的记忆"></a>复习回顾队列中的记忆</h3><ul><li>在开始回顾时，选择回顾自定义队列，即可选择某一队列进行回顾。</li></ul><p><img src="/2020/04/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/image039.png" style="zoom:50%;"></p>]]></content>
      
      
      <categories>
          
          <category> 记忆仓库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记忆仓库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学笔记0420</title>
      <link href="/2020/04/20/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B00420/"/>
      <url>/2020/04/20/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B00420/</url>
      
        <content type="html"><![CDATA[<h2 id="n-次方差公式"><a href="#n-次方差公式" class="headerlink" title="n 次方差公式"></a>n 次方差公式</h2><p><img src="/2020/04/20/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B00420/clip_image002.gif" alt="img"></p><p><strong>重要极限补充</strong></p><p><img src="/2020/04/20/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B00420/clip_image004.gif" alt="img"></p><p><img src="/2020/04/20/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B00420/clip_image006.gif" alt="img"></p><p><img src="/2020/04/20/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B00420/clip_image008.gif" alt="img"></p><p><img src="/2020/04/20/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B00420/clip_image010.gif" alt="img"></p><h2 id="等价无穷小"><a href="#等价无穷小" class="headerlink" title="等价无穷小"></a>等价无穷小</h2><p>若</p><p><img src="/2020/04/20/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B00420/clip_image012.gif" alt="img"></p><p>则</p><p><img src="/2020/04/20/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B00420/clip_image014.gif" alt="img"></p><h2 id="完备事件组"><a href="#完备事件组" class="headerlink" title="完备事件组"></a>完备事件组</h2><p>刀切全集，不重不漏</p><h2 id="概率不等式补充"><a href="#概率不等式补充" class="headerlink" title="概率不等式补充"></a>概率不等式补充</h2><p><img src="/2020/04/20/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B00420/clip_image016.gif" alt="img"></p><h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>若 AB 互斥，则 A 与 BC 也互斥</p><p>所以</p><p><img src="/2020/04/20/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B00420/clip_image018.gif" alt="img"></p><p><img src="/2020/04/20/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B00420/clip_image020.gif" alt="img"></p><h2 id="sin-与-cos-的一些积分"><a href="#sin-与-cos-的一些积分" class="headerlink" title="sin 与 cos 的一些积分"></a>sin 与 cos 的一些积分</h2><p><img src="/2020/04/20/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B00420/image-20200420220424320.png" alt="image-20200420220424320"></p><h2 id="参数为离散值的函数"><a href="#参数为离散值的函数" class="headerlink" title="参数为离散值的函数"></a>参数为离散值的函数</h2><p>第一类：函数列</p><p><img src="/2020/04/20/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B00420/clip_image002-1587391532374.gif" alt="img"></p><p>为数列  </p><p><img src="/2020/04/20/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B00420/clip_image026.gif" alt="img"></p><p>第二类：分段函数</p><p><img src="/2020/04/20/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B00420/clip_image028.gif" alt="img"></p><p>这是合并的写法， n 取一个值，代表一个分段，不可单纯认为函数分为了两段</p><h2 id="贝叶斯与普通条件概率"><a href="#贝叶斯与普通条件概率" class="headerlink" title="贝叶斯与普通条件概率"></a>贝叶斯与普通条件概率</h2><p>二者都是为了求</p><p><img src="/2020/04/20/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B00420/clip_image030.gif" alt="img"></p><p>区别在于事件 B 是由什么构成的</p><p>贝叶斯</p><p><img src="/2020/04/20/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B00420/clip_image032.gif" alt="img"></p><p>普通条件</p><p><img src="/2020/04/20/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B00420/clip_image034.gif" alt="img"></p><p>如果事件 B 是事件组中的某个事件，则用普通条件概率计算</p><p>如果事件 B 是指事件组的某个事件与另一个事件同时发生，则用贝叶斯计算</p><h2 id="若未知数趋于正无穷，则函数单调有界必有极限"><a href="#若未知数趋于正无穷，则函数单调有界必有极限" class="headerlink" title="若未知数趋于正无穷，则函数单调有界必有极限"></a>若未知数趋于正无穷，则函数单调有界必有极限</h2><h2 id="海涅定理"><a href="#海涅定理" class="headerlink" title="海涅定理"></a>海涅定理</h2><p><img src="/2020/04/20/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B00420/clip_image036.gif" alt="img"></p><h2 id="积分的放缩"><a href="#积分的放缩" class="headerlink" title="积分的放缩"></a>积分的放缩</h2><p><img src="/2020/04/20/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B00420/clip_image038.gif" alt="img"></p><p><img src="/2020/04/20/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B00420/clip_image040.gif" alt="img"></p><p><img src="/2020/04/20/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B00420/clip_image042.gif" alt="img"></p><h2 id="牛顿莱布尼兹公式：父子转换"><a href="#牛顿莱布尼兹公式：父子转换" class="headerlink" title="牛顿莱布尼兹公式：父子转换"></a>牛顿莱布尼兹公式：父子转换</h2><p><img src="/2020/04/20/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B00420/clip_image044.gif" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 考研数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研数学 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>keras yolo3 使用 CIOU Loss</title>
      <link href="/2020/04/20/keras%20yolo3%20CIOU%20loss/"/>
      <url>/2020/04/20/keras%20yolo3%20CIOU%20loss/</url>
      
        <content type="html"><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>本文设计了 keras 实现的 CIOU 函数，并分析  keras YOLO3 源码，在原有代码的基础上进行修改，使用 CIOU Loss 替换原来的位置大小回归。</p><a id="more"></a><h2 id="原-keras-yolo3-loss-分析"><a href="#原-keras-yolo3-loss-分析" class="headerlink" title="原 keras yolo3 loss 分析"></a>原 keras yolo3 loss 分析</h2><p>参考链接：<a href="https://blog.csdn.net/lzs781/article/details/105086179" target="_blank" rel="noopener">https://blog.csdn.net/lzs781/article/details/105086179</a></p><h3 id="关键函数分析"><a href="#关键函数分析" class="headerlink" title="关键函数分析"></a>关键函数分析</h3><h4 id="yolo-head"><a href="#yolo-head" class="headerlink" title="yolo_head"></a>yolo_head</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">yolo_head</span><span class="params">(feats, anchors, num_classes, input_shape, calc_loss=False)</span>:</span></span><br><span class="line">    <span class="string">"""Convert final layer features to bounding box parameters."""</span></span><br><span class="line">    num_anchors = len(anchors)</span><br><span class="line">    <span class="comment"># Reshape to batch, height, width, num_anchors, box_params.</span></span><br><span class="line">    anchors_tensor = K.reshape(K.constant(anchors), [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, num_anchors, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    grid_shape = K.shape(feats)[<span class="number">1</span>:<span class="number">3</span>] <span class="comment"># height, width</span></span><br><span class="line">    grid_y = K.tile(K.reshape(K.arange(<span class="number">0</span>, stop=grid_shape[<span class="number">0</span>]), [<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]),</span><br><span class="line">        [<span class="number">1</span>, grid_shape[<span class="number">1</span>], <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">    grid_x = K.tile(K.reshape(K.arange(<span class="number">0</span>, stop=grid_shape[<span class="number">1</span>]), [<span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>]),</span><br><span class="line">        [grid_shape[<span class="number">0</span>], <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">    grid = K.concatenate([grid_x, grid_y])</span><br><span class="line">    grid = K.cast(grid, K.dtype(feats))</span><br><span class="line"></span><br><span class="line">    feats = K.reshape(</span><br><span class="line">        feats, [<span class="number">-1</span>, grid_shape[<span class="number">0</span>], grid_shape[<span class="number">1</span>], num_anchors, num_classes + <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Adjust preditions to each spatial grid point and anchor size.</span></span><br><span class="line">    box_xy = (K.sigmoid(feats[..., :<span class="number">2</span>]) + grid) / K.cast(grid_shape[::<span class="number">-1</span>], K.dtype(feats))</span><br><span class="line">    box_wh = K.exp(feats[..., <span class="number">2</span>:<span class="number">4</span>]) * anchors_tensor / K.cast(input_shape[::<span class="number">-1</span>], K.dtype(feats))</span><br><span class="line">    box_confidence = K.sigmoid(feats[..., <span class="number">4</span>:<span class="number">5</span>])</span><br><span class="line">    box_class_probs = K.sigmoid(feats[..., <span class="number">5</span>:])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> calc_loss == <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">return</span> grid, feats, box_xy, box_wh</span><br><span class="line">    <span class="keyword">return</span> box_xy, box_wh, box_confidence, box_class_probs</span><br></pre></td></tr></table></figure><p>该函数用于从最终输出的特征图里提取预测框信息</p><p><strong>参数 :</strong></p><ul><li><strong>feats</strong> : 特征图，通道数为 <code>5+类别数目</code></li><li><strong>anchors :</strong> 特征图中所含锚框，结构为 <code>[[w1,h1],[w2,h2],...]</code></li><li><strong>num_classes</strong> : 类别数目</li><li><strong>input_shape</strong> :  原图尺寸信息，<code>(高,宽)</code></li><li><strong>calc_loss</strong> : 是否用于计算 loss 值 </li></ul><p><strong>返回 :</strong></p><ul><li><p>如果 <code>calc_loss == True</code> ，则返回 <code>grid, feats, box_xy, box_wh</code></p></li><li><p>否则返回 <code>box_xy, box_wh, box_confidence, box_class_probs</code></p></li><li><p>其中<code>grid, feats, box_xy, box_wh, box_confidence, box_class_probs</code> 分别是网格坐标信息、原始特征图信息、预测框中心点坐标比例（相对于原图）、预测框大小比例（相对于锚框）、置信度、类别信息。</p></li><li><p>形状的形状信息为：</p>  <figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">grid.shape</span>=(特征图高,特征图宽,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="attr">feats.shape</span>=(批数,特征图高,特征图宽,锚框数,<span class="number">5</span>+类别数)</span><br><span class="line"><span class="attr">box_xy.shape</span>=(批数,特征图高,特征图宽,锚框数,<span class="number">2</span>)</span><br><span class="line"><span class="attr">box_wh.shape</span>=(批数,特征图高,特征图宽,锚框数,<span class="number">2</span>)</span><br><span class="line"><span class="attr">box_confidence.shape</span>=(批数,特征图高,特征图宽,锚框数,<span class="number">1</span>)</span><br><span class="line"><span class="attr">box_class_probs.shape</span>=(批数,特征图高,特征图宽,锚框数,类别数)</span><br></pre></td></tr></table></figure></li></ul><h4 id="yolo-loss"><a href="#yolo-loss" class="headerlink" title="yolo_loss"></a>yolo_loss</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">yolo_loss</span><span class="params">(args, anchors, num_classes, ignore_thresh=<span class="number">.5</span>, print_loss=False)</span>:</span></span><br><span class="line">    num_layers = len(anchors)//<span class="number">3</span> <span class="comment"># default setting</span></span><br><span class="line">    yolo_outputs = args[:num_layers]</span><br><span class="line">    y_true = args[num_layers:]</span><br><span class="line">    anchor_mask = [[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]] <span class="keyword">if</span> num_layers==<span class="number">3</span> <span class="keyword">else</span> [[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">    input_shape = K.cast(K.shape(yolo_outputs[<span class="number">0</span>])[<span class="number">1</span>:<span class="number">3</span>] * <span class="number">32</span>, K.dtype(y_true[<span class="number">0</span>]))</span><br><span class="line">    grid_shapes = [K.cast(K.shape(yolo_outputs[l])[<span class="number">1</span>:<span class="number">3</span>], K.dtype(y_true[<span class="number">0</span>])) <span class="keyword">for</span> l <span class="keyword">in</span> range(num_layers)]</span><br><span class="line">    loss = <span class="number">0</span></span><br><span class="line">    m = K.shape(yolo_outputs[<span class="number">0</span>])[<span class="number">0</span>] <span class="comment"># batch size, tensor</span></span><br><span class="line">    mf = K.cast(m, K.dtype(yolo_outputs[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> range(num_layers):</span><br><span class="line">        object_mask = y_true[l][..., <span class="number">4</span>:<span class="number">5</span>]</span><br><span class="line">        true_class_probs = y_true[l][..., <span class="number">5</span>:]</span><br><span class="line"></span><br><span class="line">        grid, raw_pred, pred_xy, pred_wh = yolo_head(yolo_outputs[l],</span><br><span class="line">             anchors[anchor_mask[l]], num_classes, input_shape, calc_loss=<span class="literal">True</span>)</span><br><span class="line">        pred_box = K.concatenate([pred_xy, pred_wh])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Darknet raw box to calculate loss.</span></span><br><span class="line">        raw_true_xy = y_true[l][..., :<span class="number">2</span>]*grid_shapes[l][::<span class="number">-1</span>] - grid</span><br><span class="line">        raw_true_wh = K.log(y_true[l][..., <span class="number">2</span>:<span class="number">4</span>] / anchors[anchor_mask[l]] * input_shape[::<span class="number">-1</span>])</span><br><span class="line">        raw_true_wh = K.switch(object_mask, raw_true_wh, K.zeros_like(raw_true_wh)) <span class="comment"># avoid log(0)=-inf</span></span><br><span class="line">        box_loss_scale = <span class="number">2</span> - y_true[l][...,<span class="number">2</span>:<span class="number">3</span>]*y_true[l][...,<span class="number">3</span>:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Find ignore mask, iterate over each of batch.</span></span><br><span class="line">        ignore_mask = tf.TensorArray(K.dtype(y_true[<span class="number">0</span>]), size=<span class="number">1</span>, dynamic_size=<span class="literal">True</span>)</span><br><span class="line">        object_mask_bool = K.cast(object_mask, <span class="string">'bool'</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">loop_body</span><span class="params">(b, ignore_mask)</span>:</span></span><br><span class="line">            true_box = tf.boolean_mask(y_true[l][b,...,<span class="number">0</span>:<span class="number">4</span>], object_mask_bool[b,...,<span class="number">0</span>])</span><br><span class="line">            iou = box_iou(pred_box[b], true_box)</span><br><span class="line">            best_iou = K.max(iou, axis=<span class="number">-1</span>)</span><br><span class="line">            ignore_mask = ignore_mask.write(b, K.cast(best_iou&lt;ignore_thresh, K.dtype(true_box)))</span><br><span class="line">            <span class="keyword">return</span> b+<span class="number">1</span>, ignore_mask</span><br><span class="line">        _, ignore_mask = K.control_flow_ops.while_loop(<span class="keyword">lambda</span> b,*args: b&lt;m, loop_body, [<span class="number">0</span>, ignore_mask])</span><br><span class="line">        ignore_mask = ignore_mask.stack()</span><br><span class="line">        ignore_mask = K.expand_dims(ignore_mask, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># K.binary_crossentropy is helpful to avoid exp overflow.</span></span><br><span class="line">        xy_loss = object_mask * box_loss_scale * K.binary_crossentropy(raw_true_xy, raw_pred[...,<span class="number">0</span>:<span class="number">2</span>], from_logits=<span class="literal">True</span>)</span><br><span class="line">        wh_loss = object_mask * box_loss_scale * <span class="number">0.5</span> * K.square(raw_true_wh-raw_pred[...,<span class="number">2</span>:<span class="number">4</span>])</span><br><span class="line">        confidence_loss = object_mask * K.binary_crossentropy(object_mask, raw_pred[...,<span class="number">4</span>:<span class="number">5</span>], from_logits=<span class="literal">True</span>)+ \</span><br><span class="line">            (<span class="number">1</span>-object_mask) * K.binary_crossentropy(object_mask, raw_pred[...,<span class="number">4</span>:<span class="number">5</span>], from_logits=<span class="literal">True</span>) * ignore_mask</span><br><span class="line">        class_loss = object_mask * K.binary_crossentropy(true_class_probs, raw_pred[...,<span class="number">5</span>:], from_logits=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        xy_loss = K.sum(xy_loss) / mf</span><br><span class="line">        wh_loss = K.sum(wh_loss) / mf</span><br><span class="line">        confidence_loss = K.sum(confidence_loss) / mf</span><br><span class="line">        class_loss = K.sum(class_loss) / mf</span><br><span class="line">        loss += xy_loss + wh_loss + confidence_loss + class_loss</span><br><span class="line">        <span class="keyword">if</span> print_loss:</span><br><span class="line">            loss = tf.Print(loss, [loss, xy_loss, wh_loss, confidence_loss, class_loss, K.sum(ignore_mask)], message=<span class="string">'loss: '</span>)</span><br><span class="line">    <span class="keyword">return</span> loss</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li><p><strong>args</strong> ：包含<code>(yolo_outputs,y_true)</code> ，<code>yolo_outputs</code> 指 YOLO3 模型输出的 y1，y2，y3，这里的输出是含有批维度的，且其第一维度为批维度。<code>y_true</code> 是经过<code>preprocess_true_boxes</code>函数预处理的真实框信息：</p><ul><li><code>yolo_outputs</code> 是三元素列表，其中元素分别为<code>[m批13*13特征图张量,m批26*26特征图张量,m批52*52特征图张量]</code>，每张特征图的深度都为<code>图内锚框数*(5+类别数)</code>，所以列表内每个元素的 <code>shape=(批数,特征图宽,特征图高,图内锚框数*(5+类别数))</code></li><li><p><code>y_true</code>  是三元素列表，列表内是 np 数组，每个 np 数组对于不同尺寸的特征图，它的形状为 <code>shape=(批数,特征图宽,特征图高,图内锚框数,5+类别数)</code>，每个特征图的尺寸为 <code>13*13、26*26、52*52</code></p><blockquote><p>关于 <code>yolo_outputs</code>  和  <code>y_true</code>  的形状分析可参考前几篇博文</p></blockquote></li></ul></li><li><p><strong>anchors</strong> : 锚框二维数组，结构如<code>[[w1,h1],[w2,h2]..]</code></p></li><li><p><strong>num_classes</strong> ：整型，类别数</p></li><li><p><strong>ignore_thresh</strong> ：浮点型，IOU 小于这个值的将被忽略。</p></li></ul><p><strong>返回：</strong></p><ul><li>一维向量，loss值。</li></ul><h2 id="改造-yolo-loss"><a href="#改造-yolo-loss" class="headerlink" title="改造 yolo_loss"></a>改造 yolo_loss</h2><h3 id="关键变量分析"><a href="#关键变量分析" class="headerlink" title="关键变量分析"></a>关键变量分析</h3><h4 id="y-true"><a href="#y-true" class="headerlink" title="y_true"></a><code>y_true</code></h4><ul><li>类型为三元素列表，每个元素是一个张量，分别表示<code>[m批13*13特征图张量,m批26*26特征图张量,m批52*52特征图张量]</code></li><li>形状 <code>shape=(批数,特征图宽,特征图高,图内锚框数,5+类别数)</code></li><li>数值为位置大小信息（x，y，w，h）+ 置信度信息 confidence + 类别的独热码，其中位置大小信息是相对于原图的比例数据</li></ul><h4 id="pred-box-与-raw-pred-0-4"><a href="#pred-box-与-raw-pred-0-4" class="headerlink" title="pred_box 与  raw_pred[0:4]"></a><code>pred_box</code> 与  <code>raw_pred[0:4]</code></h4><p><code>pred_box</code> 是由 <code>[pred_xy, pred_wh]</code> 连接而成</p><ul><li>类型为张量</li><li>形状  <code>shape=(批数,特征图高,特征图宽,锚框数,4)</code></li><li>数值为位置大小信息（x，y，w，h）, 数值为相对于原图的比例</li></ul><p><code>raw_pred[0:4]</code> 是特征图输出的切片</p><ul><li>类型为张量</li><li>形状<code>shape=(批数,特征图高,特征图宽,锚框数,4)</code></li><li>数值为未经归一化处理的位置大小信息（x，y，w，h）, 只是网络输出的数据</li></ul><h4 id="raw-true-xy-与-raw-true-wh"><a href="#raw-true-xy-与-raw-true-wh" class="headerlink" title="raw_true_xy 与 raw_true_wh"></a><code>raw_true_xy</code> 与 <code>raw_true_wh</code></h4><ul><li>类型均为张量</li><li>形状均为<code>shape=(批数,特征图高,特征图宽,锚框数,2)</code></li><li>数值是将 <code>y_true</code> 中的 位置大小信息逆运算，使它意义与 <code>raw_pred[0:4]</code> 一致</li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li><code>y_true</code> 与 <code>pred_box</code>  在大小位置信息（x，y，w，h）上意义一致</li><li><code>raw_true_xy</code>  、<code>raw_true_wh</code> 与 <code>raw_pred[0:4]</code> 意义一致</li></ul><h3 id="CIOU-LOSS"><a href="#CIOU-LOSS" class="headerlink" title="CIOU LOSS"></a>CIOU LOSS</h3><p>参考链接：<a href="https://blog.csdn.net/lzs781/article/details/105515150" target="_blank" rel="noopener">https://blog.csdn.net/lzs781/article/details/105515150</a></p><script type="math/tex; mode=display">CIOU(B,B^{gt})=DIOU(B,B^{gt})-\alpha\upsilon\\L_{reg}(B,B^{gt})=1-CIOU(B,B^{gt})</script><p>其中</p><script type="math/tex; mode=display">\alpha=\frac{\upsilon}{(1-IOU)+\upsilon}\\  \upsilon = \frac{4}{\pi ^2}\left(arctan\frac{w^{gt}}{h^{gt}}-arctan\frac{w}{h} \right)^2\\DIOU(B,B^{gt}) = IOU(B,B^{gt}) - \frac{\rho^{2}(b,b^{gt})}{c^{2}}</script><p>所以实现 CIOU loss 的核心是实现 IOU 运算，这里选择将 <code>y_true</code> 与 <code>pred_box</code>  作为参数构造 CIOU 运算函数</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>创建 ciou.py</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> backend <span class="keyword">as</span> K</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ciou</span><span class="params">(true_boxes,pred_box)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    true_boxes: shape=(批数,特征图高,特征图宽,锚框数,4) (x,y,w,h)</span></span><br><span class="line"><span class="string">    pred_box: shape=(批数,特征图高,特征图宽,锚框数,4) (x,y,w,h)</span></span><br><span class="line"><span class="string">    return ciou shape=(批数,特征图高,特征图宽,锚框数,1) </span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    b1_xy = true_boxes[..., :<span class="number">2</span>]</span><br><span class="line">    b1_wh = true_boxes[..., <span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">    b1_wh_half = b1_wh/<span class="number">2.</span></span><br><span class="line">    b1_mins = b1_xy - b1_wh_half</span><br><span class="line">    b1_maxes = b1_xy + b1_wh_half</span><br><span class="line"></span><br><span class="line">    b2_xy = pred_box[..., :<span class="number">2</span>]</span><br><span class="line">    b2_wh = pred_box[..., <span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">    b2_wh_half = b2_wh/<span class="number">2.</span></span><br><span class="line">    b2_mins = b2_xy - b2_wh_half</span><br><span class="line">    b2_maxes = b2_xy + b2_wh_half</span><br><span class="line"></span><br><span class="line">    intersect_mins = K.maximum(b1_mins, b2_mins)</span><br><span class="line">    intersect_maxes = K.minimum(b1_maxes, b2_maxes)</span><br><span class="line">    intersect_wh = K.maximum(intersect_maxes - intersect_mins, <span class="number">0.</span>)</span><br><span class="line">    intersect_area = intersect_wh[..., <span class="number">0</span>] * intersect_wh[..., <span class="number">1</span>]</span><br><span class="line">    b1_area = b1_wh[..., <span class="number">0</span>] * b1_wh[..., <span class="number">1</span>]</span><br><span class="line">    b2_area = b2_wh[..., <span class="number">0</span>] * b2_wh[..., <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    iou = intersect_area / (b1_area + b2_area - intersect_area)</span><br><span class="line"></span><br><span class="line">    outer_mins = K.minimum(b1_mins, b2_mins)</span><br><span class="line">    outer_maxes=K.maximum(b1_maxes, b2_maxes)</span><br><span class="line">    outer_diagonal_line = K.square(outer_maxes[...,<span class="number">0</span>]-outer_mins[...,<span class="number">0</span>])+K.square(outer_maxes[...,<span class="number">1</span>]-outer_mins[...,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    center_dis=K.square(b1_xy[...,<span class="number">0</span>]-b2_xy[...,<span class="number">0</span>])+K.square(b1_xy[...,<span class="number">1</span>]-b2_xy[...,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> use keras backend instead of tf.</span></span><br><span class="line">    v = (<span class="number">4.0</span>/(np.pi)**<span class="number">2</span>) * tf.math.square((</span><br><span class="line">            tf.math.atan((b1_wh[...,<span class="number">0</span>]/b1_wh[...,<span class="number">1</span>])) -</span><br><span class="line">            tf.math.atan((b2_wh[..., <span class="number">0</span>] / b2_wh[..., <span class="number">1</span>])) ))</span><br><span class="line">    alpha = tf.maximum(v / (<span class="number">1</span>-iou+v),<span class="number">0</span>) <span class="comment"># (1-iou+v) 在完全重合时等于 0 , 0/0=-nan(ind)</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    ciou = iou - (center_dis / outer_diagonal_line + alpha*v)</span><br><span class="line">    ciou=K.expand_dims(iou, <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> ciou</span><br></pre></td></tr></table></figure><p><strong>修改 model.py，在 yolo_loss 处：</strong></p><p>主要是使用</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reg_loss=object_mask*(<span class="number">1</span>-ciou(</span><br><span class="line">    true_boxes=y_true[l][..., :<span class="number">4</span>],</span><br><span class="line">    pred_box=pred_box</span><br><span class="line">))</span><br></pre></td></tr></table></figure><p>代替原来的位置大小回归。</p><p>我的 yolo_loss 是这样：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> yolo3.ciou <span class="keyword">import</span> ciou</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">yolo_loss</span><span class="params">(args, anchors, num_classes, ignore_thresh=<span class="number">.5</span>, print_loss=False)</span>:</span></span><br><span class="line">    num_layers = len(anchors)//<span class="number">3</span> <span class="comment"># default setting</span></span><br><span class="line">    yolo_outputs = args[:num_layers]</span><br><span class="line">    y_true = args[num_layers:]</span><br><span class="line">    anchor_mask = [[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]] <span class="keyword">if</span> num_layers==<span class="number">3</span> <span class="keyword">else</span> [[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">    input_shape = K.cast(K.shape(yolo_outputs[<span class="number">0</span>])[<span class="number">1</span>:<span class="number">3</span>] * <span class="number">32</span>, K.dtype(y_true[<span class="number">0</span>]))</span><br><span class="line">    grid_shapes = [K.cast(K.shape(yolo_outputs[l])[<span class="number">1</span>:<span class="number">3</span>], K.dtype(y_true[<span class="number">0</span>])) <span class="keyword">for</span> l <span class="keyword">in</span> range(num_layers)]</span><br><span class="line">    loss = <span class="number">0</span></span><br><span class="line">    m = K.shape(yolo_outputs[<span class="number">0</span>])[<span class="number">0</span>] <span class="comment"># batch size, tensor</span></span><br><span class="line">    mf = K.cast(m, K.dtype(yolo_outputs[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> range(num_layers):</span><br><span class="line">        object_mask = y_true[l][..., <span class="number">4</span>:<span class="number">5</span>]</span><br><span class="line">        true_class_probs = y_true[l][..., <span class="number">5</span>:]</span><br><span class="line"></span><br><span class="line">        grid, raw_pred, pred_xy, pred_wh,box_class_probs = yolo_head(yolo_outputs[l],</span><br><span class="line">             anchors[anchor_mask[l]], num_classes, input_shape, calc_loss=<span class="literal">True</span>)</span><br><span class="line">        pred_box = K.concatenate([pred_xy, pred_wh])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Darknet raw box to calculate loss.</span></span><br><span class="line">        <span class="comment"># raw_true_xy = y_true[l][..., :2]*grid_shapes[l][::-1] - grid</span></span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">        <span class="comment"># raw_true_wh = K.log(y_true[l][..., 2:4] / anchors[anchor_mask[l]] * input_shape[::-1])</span></span><br><span class="line">        <span class="comment"># raw_true_wh = K.switch(object_mask, raw_true_wh, K.zeros_like(raw_true_wh)) # avoid log(0)=-inf</span></span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">        <span class="comment"># box_loss_scale = 2 - y_true[l][...,2:3]*y_true[l][...,3:4]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Find ignore mask, iterate over each of batch.</span></span><br><span class="line">        ignore_mask = tf.TensorArray(K.dtype(y_true[<span class="number">0</span>]), size=<span class="number">1</span>, dynamic_size=<span class="literal">True</span>)</span><br><span class="line">        object_mask_bool = K.cast(object_mask, <span class="string">'bool'</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">loop_body</span><span class="params">(b, ignore_mask)</span>:</span></span><br><span class="line">            true_box = tf.boolean_mask(y_true[l][b,...,<span class="number">0</span>:<span class="number">4</span>], object_mask_bool[b,...,<span class="number">0</span>])</span><br><span class="line">            iou = box_iou(pred_box[b], true_box)</span><br><span class="line">            best_iou = K.max(iou, axis=<span class="number">-1</span>)</span><br><span class="line">            ignore_mask = ignore_mask.write(b, K.cast(best_iou&lt;ignore_thresh, K.dtype(true_box)))</span><br><span class="line">            <span class="keyword">return</span> b+<span class="number">1</span>, ignore_mask</span><br><span class="line">        _, ignore_mask = K.control_flow_ops.while_loop(<span class="keyword">lambda</span> b,*args: b&lt;m, loop_body, [<span class="number">0</span>, ignore_mask])</span><br><span class="line">        ignore_mask = ignore_mask.stack()</span><br><span class="line">        ignore_mask = K.expand_dims(ignore_mask, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># K.binary_crossentropy is helpful to avoid exp overflow.</span></span><br><span class="line">        <span class="comment"># xy_loss = object_mask * box_loss_scale * K.binary_crossentropy(raw_true_xy, raw_pred[...,0:2], from_logits=True)</span></span><br><span class="line">        <span class="comment"># wh_loss = object_mask * box_loss_scale * 0.5 * K.square(raw_true_wh-raw_pred[...,2:4])</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用 icou 作为回归损失函数</span></span><br><span class="line">        reg_loss=object_mask*(<span class="number">1</span>-ciou(</span><br><span class="line">            true_boxes=y_true[l][..., :<span class="number">4</span>],</span><br><span class="line">            pred_box=pred_box</span><br><span class="line">        ))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># confidence_loss = object_mask * K.binary_crossentropy(object_mask, raw_pred[...,4:5], from_logits=True)+ \</span></span><br><span class="line">        <span class="comment">#     (1-object_mask) * K.binary_crossentropy(object_mask, raw_pred[...,4:5], from_logits=True) * ignore_mask</span></span><br><span class="line">        confidence_loss = object_mask * K.binary_crossentropy(object_mask, raw_pred[...,<span class="number">4</span>:<span class="number">5</span>], from_logits=<span class="literal">True</span>)+ \</span><br><span class="line">            <span class="number">0.1</span>*(<span class="number">1</span>-object_mask) * K.binary_crossentropy(object_mask, raw_pred[...,<span class="number">4</span>:<span class="number">5</span>], from_logits=<span class="literal">True</span>) * ignore_mask</span><br><span class="line">           </span><br><span class="line">        class_loss = object_mask * K.binary_crossentropy(true_class_probs, box_class_probs, from_logits=<span class="literal">False</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># xy_loss = K.sum(xy_loss) / mf</span></span><br><span class="line">        <span class="comment"># wh_loss = K.sum(wh_loss) / mf</span></span><br><span class="line">        <span class="comment"># confidence_loss = K.sum(confidence_loss) / mf</span></span><br><span class="line">        <span class="comment"># class_loss = K.sum(class_loss) / mf</span></span><br><span class="line">        <span class="comment"># loss += xy_loss + wh_loss + confidence_loss + class_loss</span></span><br><span class="line"></span><br><span class="line">        reg_loss=K.sum(reg_loss) / mf</span><br><span class="line">        confidence_loss = K.sum(confidence_loss) / mf</span><br><span class="line">        class_loss = K.sum(class_loss) / mf</span><br><span class="line">        loss += reg_loss + confidence_loss + class_loss</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># if print_loss:</span></span><br><span class="line">        <span class="comment">#     loss = tf.Print(loss, [loss, xy_loss, wh_loss, confidence_loss, class_loss, K.sum(ignore_mask)], message='loss: ')</span></span><br><span class="line">    <span class="keyword">return</span> loss</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> YOLO </tag>
            
            <tag> CIOU </tag>
            
            <tag> Loss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Next主题 解决公式块中公式换行问题</title>
      <link href="/2020/04/17/Hexo%20Next%E4%B8%BB%E9%A2%98%20%E8%A7%A3%E5%86%B3%E5%85%AC%E5%BC%8F%E5%9D%97%E4%B8%AD%E5%85%AC%E5%BC%8F%E6%8D%A2%E8%A1%8C%E9%97%AE%E9%A2%98/"/>
      <url>/2020/04/17/Hexo%20Next%E4%B8%BB%E9%A2%98%20%E8%A7%A3%E5%86%B3%E5%85%AC%E5%BC%8F%E5%9D%97%E4%B8%AD%E5%85%AC%E5%BC%8F%E6%8D%A2%E8%A1%8C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>公式块内公式不能换行。</p><a id="more"></a><h3 id="问题环境"><a href="#问题环境" class="headerlink" title="问题环境"></a>问题环境</h3><ul><li><p>主题：<a href="https://theme-next.org/next-7-8-0-released/" target="_blank" rel="noopener">NexT 7.8.0 Released</a></p></li><li><p>hexo：</p>  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hexo-cli:</span> <span class="number">3.1</span><span class="number">.0</span></span><br><span class="line"><span class="attr">os:</span> <span class="string">Windows_NT</span> <span class="number">6.1</span><span class="number">.7601</span> <span class="string">win32</span> <span class="string">x64</span></span><br><span class="line"><span class="attr">node:</span> <span class="number">12.14</span><span class="number">.0</span></span><br><span class="line"><span class="attr">v8:</span> <span class="number">7.7</span><span class="number">.299</span><span class="number">.13</span><span class="string">-node.16</span></span><br><span class="line"><span class="attr">uv:</span> <span class="number">1.33</span><span class="number">.1</span></span><br><span class="line"><span class="attr">zlib:</span> <span class="number">1.2</span><span class="number">.11</span></span><br><span class="line"><span class="attr">brotli:</span> <span class="number">1.0</span><span class="number">.7</span></span><br><span class="line"><span class="attr">ares:</span> <span class="number">1.15</span><span class="number">.0</span></span><br><span class="line"><span class="attr">modules:</span> <span class="number">72</span></span><br><span class="line"><span class="attr">nghttp2:</span> <span class="number">1.39</span><span class="number">.2</span></span><br><span class="line"><span class="attr">napi:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">llhttp:</span> <span class="number">1.1</span><span class="number">.4</span></span><br><span class="line"><span class="attr">http_parser:</span> <span class="number">2.8</span><span class="number">.0</span></span><br><span class="line"><span class="attr">openssl:</span> <span class="number">1.1</span><span class="string">.1d</span></span><br><span class="line"><span class="attr">cldr:</span> <span class="number">35.1</span></span><br><span class="line"><span class="attr">icu:</span> <span class="number">64.2</span></span><br><span class="line"><span class="attr">tz:</span> <span class="string">2019c</span></span><br><span class="line"><span class="attr">unicode:</span> <span class="number">12.1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="原因定位"><a href="#原因定位" class="headerlink" title="原因定位"></a>原因定位</h3><p>Next 主题默认使用 <code>//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js</code>  进行公式渲染，但是 mathjax_v3 并不支持使用 <code>\\</code> 进行换行。</p><blockquote><p>dpvc：</p><p>Linebreaks are not yet implemented in version 3.  This is one of the  significant features from version 2 that been ported to version 3.</p><p><a href="https://github.com/mathjax/MathJax/issues/2312" target="_blank" rel="noopener">https://github.com/mathjax/MathJax/issues/2312</a></p></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="更换-mathjax-版本"><a href="#更换-mathjax-版本" class="headerlink" title="更换 mathjax 版本"></a>更换 mathjax 版本</h4><p>mathjax 支持公式块内公式换行，所以直接修改镜像</p><p>在<code>\themes\next\_config.yml</code> 中的 <code>vendors</code> 结点下修改</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">mathjax: https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/npm/m</span>athjax@<span class="number">2.7</span>.<span class="number">8</span><span class="regexp">/unpacked/</span>MathJax.js?config=TeX-MML-AM_CHTML</span><br></pre></td></tr></table></figure><p>更改 mathjax 版本后，发现原来行内公式不渲染了，原因是 v3 版本和 v2 版本对行内公式渲染的设置方式发生了变化。</p><h4 id="解决行间公式不渲染问题"><a href="#解决行间公式不渲染问题" class="headerlink" title="解决行间公式不渲染问题"></a>解决行间公式不渲染问题</h4><p>进入<code>\themes\next\layout\_third-party\math\mathjax.swig</code>  进行修改</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;%- set mathjax_uri = theme.vendors.mathjax or '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js' %&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">if</span> (<span class="keyword">typeof</span> MathJax === <span class="string">'undefined'</span>) &#123;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// window.MathJax = &#123;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//   loader: &#123;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//     &#123;%- if theme.math.mathjax.mhchem %&#125;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//       load: ['[tex]/mhchem'],</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//     &#123;%- endif %&#125;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//     source: &#123;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//       '[tex]/amsCd': '[tex]/amscd',</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//       '[tex]/AMScd': '[tex]/amscd'</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//     &#125;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//   &#125;,</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//   tex: &#123;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//     inlineMath: &#123;'[+]': [['$', '$']]&#125;,</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//     &#123;%- if theme.math.mathjax.mhchem %&#125;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//       packages: &#123;'[+]': ['mhchem']&#125;,</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//     &#123;%- endif %&#125;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//     tags: 'ams'</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//   &#125;,</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//   options: &#123;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//     renderActions: &#123;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//       findScript: [10, doc =&gt; &#123;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//         document.querySelectorAll('script[type^="math/tex"]').forEach(node =&gt; &#123;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//           const display = !!node.type.match(/; *mode=display/);</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//           const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//           const text = document.createTextNode('');</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//           node.parentNode.replaceChild(text, node);</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//           math.start = &#123;node: text, delim: '', n: 0&#125;;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//           math.end = &#123;node: text, delim: '', n: 0&#125;;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//           doc.math.push(math);</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//         &#125;);</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//       &#125;, '', false],</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//       insertedScript: [200, () =&gt; &#123;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//         document.querySelectorAll('mjx-container').forEach(node =&gt; &#123;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//           let target = node.parentNode;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//           if (target.nodeName.toLowerCase() === 'li') &#123;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//             target.parentNode.classList.add('has-jax');</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//           &#125;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//         &#125;);</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//       &#125;, '', false]</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//     &#125;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">//   &#125;</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// &#125;;</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.MathJax = &#123;</span></span><br><span class="line">      tex2jax: &#123;</span><br><span class="line"><span class="actionscript">        inlineMath: [ [<span class="string">'$'</span>,<span class="string">'$'</span>], [<span class="string">"\\("</span>,<span class="string">"\\)"</span>] ],</span></span><br><span class="line"><span class="actionscript">        processEscapes: <span class="literal">true</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="actionscript">    (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="actionscript">      script.src = <span class="string">'&#123;&#123; mathjax_uri &#125;&#125;'</span>;</span></span><br><span class="line"><span class="actionscript">      script.defer = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.head.appendChild(script);</span></span><br><span class="line">    &#125;)();</span><br><span class="line"><span class="actionscript">  &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line">    MathJax.startup.document.state(0);</span><br><span class="line">    MathJax.texReset();</span><br><span class="line">    MathJax.typeset();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>v2 版本配置行内公式渲染的办法变为了</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.MathJax = &#123;</span><br><span class="line">     tex2jax: &#123;</span><br><span class="line">       inlineMath: [ [<span class="string">'$'</span>,<span class="string">'$'</span>], [<span class="string">"\\("</span>,<span class="string">"\\)"</span>] ],</span><br><span class="line">       processEscapes: <span class="literal">true</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>直观理解多维张量的reshape</title>
      <link href="/2020/04/16/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BB%B4%E5%BC%A0%E9%87%8F%E7%9A%84reshape/"/>
      <url>/2020/04/16/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BB%B4%E5%BC%A0%E9%87%8F%E7%9A%84reshape/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在机器学习领域，通常把标量、向量、矩阵，都称为张量，即将张量分为：</p><ul><li>0 维张量，标量</li><li>1 维张量，向量</li><li>2 维张量，矩阵</li><li>….</li><li>n 维张量</li></ul><p>标量很好表示，就是一个数：</p><script type="math/tex; mode=display">1</script><p>向量是一组数：</p><script type="math/tex; mode=display">(1,2,3)</script><p>矩阵是一组向量</p><script type="math/tex; mode=display">((1,2,3),(4,5,6))</script><p>同时也可以把矩阵表示成类似表格的形式</p><script type="math/tex; mode=display">\begin{bmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \end{bmatrix}</script><a id="more"></a><p>3 维张量可以表示为一组矩阵</p><script type="math/tex; mode=display">(((1,2,3),(4,5,6)),((7,8,9),(10,11,12)))</script><p>这样看上去不是很直观，但当维度大于 2 以后，也无法用表格直观表示了，这里我推荐使用树状表示法</p><p><img src="/2020/04/16/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BB%B4%E5%BC%A0%E9%87%8F%E7%9A%84reshape/幻灯片1.PNG" alt></p><p>树状表示法的每一个分支代表一个索引，最后一列的圆圈代表张量中每个分量，其后紧接的方块是分量的数值，例如整数 12 被存储于 <code>Tensor[1][1][2]</code> （索引从 0 开始）</p><p>几乎所有机器学习框架，都会给张量分配一个名为 <code>shape</code> 的属性，该属性直译为形状，表示张量每个维度的“长度”，如上面的这个张量的<code>shape=(2,2,3)</code> 每个维度的“长度”决定了最大索引号是多少，如第一维的长度 2 ，则第一维度的最大索引号只能到 1，同时分量个数等于各维度长度之积，如上图张量中的分量数目为 <code>2*2*3=12</code></p><p>伴随着 <code>shape</code> 属性的出现，随之而来的就是 <code>reshape</code> 方法，<code>reshape</code> 方法可以改变一个张量维度数目和维度长度。</p><p>但是张量维度也不是想怎么改变就怎么改变的，不论你是几维张量，在数据结构上，说到底也不过是一个多维数组，多维数组本身就是一个逻辑结构，实际在内存中，它其实是一个元素接一个元素的线性储存的，所以原则上，无论一个张量 <code>shape</code> 怎么改变，它的分量个数都是不变的，而且它的分量在内存中的存储顺序也是不变的。</p><h2 id="如何直观理解多维张量的-reshape-方法"><a href="#如何直观理解多维张量的-reshape-方法" class="headerlink" title="如何直观理解多维张量的 reshape 方法"></a>如何直观理解多维张量的 reshape 方法</h2><p>假设给定一个多维张量，将它表示为下图</p><p><img src="/2020/04/16/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BB%B4%E5%BC%A0%E9%87%8F%E7%9A%84reshape/幻灯片1.PNG" alt></p><p>这是一张树状图，<strong><code>Tensor</code> 和其后的每一个圆圈都是一个结点</strong>，最后一列的所有结点代表张量中的每一个分量，其后紧跟的方块表示分量中的数值，前三列中每一列对应一个维度，<strong>每一列结点的出度就是该列对应维度的长度</strong>，</p><p><strong><code>Tensor</code> 是根结点，位于第一列</strong>，出度为 2 ；第二列每一个圆圈出度为 2 ；第三列的每一个圆圈出度为 3 ，所以由图可知，该多维张量的 <code>shape=(2,2,3)</code></p><p>现在我们假设期望将该张量通过 <code>reshape</code> 方法，令其第二维度长度为 1：</p><p>首先分析要改变的维度，第一维度没有变化，第二维度变化了，同时也导致第二维度之后其他维度变化了，体现在图像上就是，第一列的出度没有变化，所以第二列的结点位置也不需要变化，此时可以暂时擦去第二列之后的、除最后一列外其他列。</p><p><img src="/2020/04/16/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BB%B4%E5%BC%A0%E9%87%8F%E7%9A%84reshape/幻灯片3.PNG" alt></p><blockquote><p>为什么不擦去最后一个列呢？因为前面说过，reshape 的原则是不会改变分量数目和内存中储存顺序，最后一列中圆圈数目就是分量数目，最后一列所有圆圈的先后位置关系就是分量在内存中存储的顺序关系，所以无论如何 reshape， 最后一列的图像永远不会改变。</p></blockquote><p>第二个维度长度变为了 1 ，所以第二列的每个结点出度变了 1</p><p><img src="/2020/04/16/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BB%B4%E5%BC%A0%E9%87%8F%E7%9A%84reshape/幻灯片4.PNG" alt></p><p>画出第二所有结点向后的分支，形成第三列结点</p><p><img src="/2020/04/16/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BB%B4%E5%BC%A0%E9%87%8F%E7%9A%84reshape/幻灯片5.PNG" alt></p><p>根据 <code>reshape</code> 原则可知，分量数目不改变且各维度长度之积等于分量数目，所第三个维度长度一定（必须）等于 6，即第三列每个结点的出度等于 6，把第三列结点按照出度为 6 的标准向最后一列结点连接</p><p><img src="/2020/04/16/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BB%B4%E5%BC%A0%E9%87%8F%E7%9A%84reshape/幻灯片7.PNG" alt></p><p>画出第三列所有结点向后的分支</p><p><img src="/2020/04/16/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BB%B4%E5%BC%A0%E9%87%8F%E7%9A%84reshape/幻灯片8.PNG" alt></p><p>此时得到的就是 <code>shape=(2,1,6)</code> 的图像。</p><p>同理，尝试将 <code>shape=(2,1,6)</code> 的张量转化为 <code>shape=(2,2,3)</code> 的张量，定义 <code>shape=(2,1,6)</code> 的张量如下：</p><p><img src="/2020/04/16/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BB%B4%E5%BC%A0%E9%87%8F%E7%9A%84reshape/幻灯片11.PNG" alt></p><p>第一个维度没变，所以第一列出度不变，即第二列图像不变，最后一列肯定不会变化，所以这里应该先暂时擦掉第三列的结点</p><p><img src="/2020/04/16/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BB%B4%E5%BC%A0%E9%87%8F%E7%9A%84reshape/幻灯片14.PNG" alt></p><p>考虑第二个维度的长度变为3，所以第二列每个结点的出度应该为 3 ，画出每个结点向后的分支：</p><p><img src="/2020/04/16/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BB%B4%E5%BC%A0%E9%87%8F%E7%9A%84reshape/幻灯片16.PNG" alt></p><p>通过计算可知，最后一个维度长度必须为 2 ，那么也就是说，第三列的出度为 2 ，</p><p><img src="/2020/04/16/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BB%B4%E5%BC%A0%E9%87%8F%E7%9A%84reshape/幻灯片18.PNG" alt></p><p>补全第三列所有向后的分支，得到</p><p><img src="/2020/04/16/%E7%9B%B4%E8%A7%82%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BB%B4%E5%BC%A0%E9%87%8F%E7%9A%84reshape/幻灯片19.PNG" alt></p><p>大功告成。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多维张量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>目标检测中的损失函数笔记整理(待续)</title>
      <link href="/2020/04/14/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%9B%9E%E5%BD%92%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
      <url>/2020/04/14/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%9B%9E%E5%BD%92%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Smooth-L1-Loss"><a href="#Smooth-L1-Loss" class="headerlink" title="Smooth L1 Loss"></a>Smooth L1 Loss</h2><h3 id="函数定义与性质："><a href="#函数定义与性质：" class="headerlink" title="函数定义与性质："></a>函数定义与性质：</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><script type="math/tex; mode=display">smoothL1(x) = \left\{ \begin{aligned} 0.5x^{2}    \qquad if \left| x \right| < 1\\ \left| x \right| - 0.5  \qquad otherswise,  \\ \end{aligned} \right.</script><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul><li>连续函数，在 x=±1 处连续</li><li>偶函数，关于 x=0 对称</li><li>x=0 处取唯一极小值 0</li></ul><h3 id="导数定义与性质："><a href="#导数定义与性质：" class="headerlink" title="导数定义与性质："></a>导数定义与性质：</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><script type="math/tex; mode=display">\frac{d[smoothL1(x)]}{x}= \left\{ \begin{aligned} x \qquad if \left| x \right| <1\\ \pm1  \qquad otherswise,  \\ \end{aligned} \right.</script><h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><ul><li>导函数连续</li><li>在 x 较小时，对 x 的梯度也会变小，而在 x 很大时，对 x 的梯度为 1 ，总之 x 梯度绝对值最大为 1 </li></ul><h3 id="来源："><a href="#来源：" class="headerlink" title="来源："></a>来源：</h3><p>在 Faster RCNN 用于对 （x，y，w，h）进行回归：</p><script type="math/tex; mode=display">L_{reg}(t_i,t_i^*)=smoothL1(t_i-t_i^*)\\t_i=(x_i,y_i,w_i,h_i)\\t_i^*=(x_i^*,y_i^*,w_i^*,h_i^*)</script><h3 id="优缺点分析："><a href="#优缺点分析：" class="headerlink" title="优缺点分析："></a>优缺点分析：</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>相较于平方误差， Smooth L1 Loss 的在预测值与标签值相差较大时，梯度被稳定为 1，这样不会让那些少量离群点贡献较大的梯度，令整个梯度下降方向，向那些错误的点倾斜。</li><li>相较于绝对值误差，Smooth L1 Loss 在 0 点处可导，且预测值与真实值相差的越小，梯度也越小，这将有利于模型收敛</li><li>…..（待补充）</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>在目标识别时，（x，y，w，h）的回归损失采用加和方式组合在一起，使得（x，y，w，h）的损失彼此独立，导致 loss 虽然看起来不错，但是（x，y，w，h）四项的回归损失有高有低，这种情况下的结果通常最终效果的评价都不是很好（最终效果的评价采用 IOU 作为标准）。</li><li>目标识别时，使用 Smooth L1 Loss 的话，大边框的 loss 和小边框的 loss 并不能同等比较，相同 loss 值的情况下，大边框（100*100）的宽和高差2个像素点，肯定比小边框（10*10）的宽和高差2个像素点效果要好，但是 Smooth L1 Loss 中没有考虑边框大小这个问题，在 YOLO 中，作者使用平方根函数缓解这个问题，可这个问题依旧存在。换句话说就是  Smooth L1 Loss 不具有尺度不变形</li></ul><a id="more"></a><h2 id="IOU-Loss"><a href="#IOU-Loss" class="headerlink" title="IOU Loss"></a>IOU Loss</h2><h3 id="函数定义与性质"><a href="#函数定义与性质" class="headerlink" title="函数定义与性质"></a>函数定义与性质</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><script type="math/tex; mode=display">IOU(A,B)=\frac{A\cap B}{A\cup B}\\L_{reg}(PB,GT)=-ln[IOU(PB,GT)]</script><p>或</p><script type="math/tex; mode=display">L_{reg}(PB,GT)=1-IOU(PB,GT)</script><h4 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h4><ul><li>非负，有下届，交并比为1，损失函数为 0</li><li>使用交并比衡量预测数据与真实数据的“距离”</li></ul><h4 id="计算流程"><a href="#计算流程" class="headerlink" title="计算流程"></a>计算流程</h4><ul><li>记 $A,B$  代表两个不同的矩形</li><li>设  $A\cap B=I,A\cup B=U$ , 则 $IOU=\frac{I}{U}$</li><li>因 $U=A\cup B=A+B-I$ , 所以通常使用 $IOU=\frac{I}{A+B-I}$ 计算</li><li>若 $A=(A_{top},A_{bottom},A_{left},A_{right}),B=(B_{top},B_{bottom},B_{left},B_{right})$</li><li>则 $I=(min\{A_{bottom},B_{bottom}\}-(max\{A_{top},B_{top}\})*(min\{A_{right},B_{right}\}-max\{A_{left},B_{left}\})$</li></ul><h3 id="导数的定义与性质"><a href="#导数的定义与性质" class="headerlink" title="导数的定义与性质"></a>导数的定义与性质</h3><script type="math/tex; mode=display">\frac{\partial L}{\partial A_{top}}=\frac 1 {IOU} \cdot \frac{\partial IOU}{\partial A_{top}}</script><h4 id="性质-3"><a href="#性质-3" class="headerlink" title="性质"></a>性质</h4><ul><li>交并比为零时不可导，即预测框与真实框不相交则不可导</li><li>随交并比的变大，梯度也在减小</li><li>梯度计算复杂，预测值相互影响，收敛速度慢</li></ul><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><p>在《UnitBox: An Advanced Object Detection Network》中被提出并使用</p><h3 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>具有尺度不变性，因为本身就是比例，所以没有量纲，大框小框都是一视同仁</li><li>IOU 强调了大小、位置、宽高之间的联系，loss 值和效果评价指标（如 mAP）关联性更强</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>当预测框和真实框没有交集的时候，IOU=0，是一个常数，没有梯度，这个在两阶段目标检测网络中问题不大，因为没有交集的预测框通常都被过滤掉了，但是对于 YOLO 这样的一阶段网络来说，这些远离真实框的预测框失去了向真实框靠近的能力，虽然最后也会被过滤掉，但是会导致更少的预测框向真实框回归，间接导致准确度下降。</li><li>IOU 实际上是一个关于相交面积的函数，仅与相交面积有关，在相交面积相同的情况下，还有很多效果的不同的相交方式，这些相交方式之间无法平均。</li><li>收敛速度慢</li></ul><h2 id="GIOU-Loss"><a href="#GIOU-Loss" class="headerlink" title="GIOU Loss"></a>GIOU Loss</h2><h3 id="函数定义与性质-1"><a href="#函数定义与性质-1" class="headerlink" title="函数定义与性质"></a>函数定义与性质</h3><script type="math/tex; mode=display">IOU(A,B)=\frac{A\cap B}{A\cup B}\\GIOU(A,B)=IOU(A,B)-\frac{C-(A\cup B)}{C}\\L_{reg}(PB,GT)=1-GIOU(PB,GT)</script><p>其中 $C$ 是 $A,B$ 的最小外接矩形的面积</p><h4 id="计算流程-1"><a href="#计算流程-1" class="headerlink" title="计算流程"></a>计算流程</h4><ul><li>记 $A,B$  代表两个不同的矩形的面积</li><li>其中 $A=(A_{top},A_{bottom},A_{left},A_{right}),B=(B_{top},B_{bottom},B_{left},B_{right})$</li><li>则 $I=(min\{A_{bottom},B_{bottom}\}-(max\{A_{top},B_{top}\})*(min\{A_{right},B_{right}\}-max\{A_{left},B_{left}\})$</li><li>$U=A+B-I$</li><li>$C=(max\{A_{bottom},B_{bottom}\}-(min\{A_{top},B_{top}\})*(max\{A_{right},B_{right}\}-min\{A_{left},B_{left}\})$</li><li>$GIOU=\frac{I}{U}-\frac{C-(U)}{C}$</li></ul><h4 id="性质-4"><a href="#性质-4" class="headerlink" title="性质"></a>性质</h4><ul><li>具有尺度不变性</li><li>-1&lt;=GIOU&lt;=1，当A=B时，GIOU=IOU=1；当A与B不相交而且离得很远时，GIOU(A,B) 趋向于-1。即当 A 和 B 不相交时，GIOU 不像 IOU 那样是一个常数。</li></ul><h3 id="导数性质"><a href="#导数性质" class="headerlink" title="导数性质"></a>导数性质</h3><h4 id="性质-5"><a href="#性质-5" class="headerlink" title="性质"></a>性质</h4><ul><li>不相交的矩形 A 、B 的 GIOU 仍具有梯度</li></ul><h3 id="来源-1"><a href="#来源-1" class="headerlink" title="来源"></a>来源</h3><p>在《Generalized Intersection over Union: A Metric and A Loss for Bounding Box Regression》中被提出</p><h3 id="优缺点分析-1"><a href="#优缺点分析-1" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li>即便不相交，也有梯度，适用于“一步走”的目标识别算法</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>当两个框为包含关系时，GIOU 等同于 IOU 对回归情况还是不能很好的评价</li></ul><h2 id="DIOU-Loss"><a href="#DIOU-Loss" class="headerlink" title="DIOU Loss"></a>DIOU Loss</h2><h3 id="函数定义与性质-2"><a href="#函数定义与性质-2" class="headerlink" title="函数定义与性质"></a>函数定义与性质</h3><script type="math/tex; mode=display">DIOU(B,B^{gt}) = IOU(B,B^{gt}) - \frac{\rho^{2}(b,b^{gt})}{c^{2}}\\L_{reg}(B,B^{gt})=1-DIOU(B,B^{gt})</script><p>其中 $\rho(\cdot)$ 表示欧几里得距离，$b,b^{gt}$ 分别表示矩形框 $B,B^{gt}$ 的中心点坐标，$c$ 表示 $B,B^{gt}$ 的最小外接矩形的对角线长度。</p><h4 id="性质-6"><a href="#性质-6" class="headerlink" title="性质"></a>性质</h4><ul><li>具有尺度不变性</li><li>-1&lt;=DIOU&lt;=1，A 和 B 完全重合时，DIOU=1；当 A 和 B 为包含关系时，A 和 B 的中心点距离越近 DIOU 越大；当 A 和 B 完全不相交时，A 和 B 中心点距离越远， DIOU 越小，最终趋近 -1</li></ul><h3 id="导数性质-1"><a href="#导数性质-1" class="headerlink" title="导数性质"></a>导数性质</h3><h4 id="性质-7"><a href="#性质-7" class="headerlink" title="性质"></a>性质</h4><ul><li>不相交的矩形 A 、B 的 GIOU 仍具有梯度</li><li>相比于 GIOU，DIOU收敛的更快</li></ul><h2 id="CIOU-Loss"><a href="#CIOU-Loss" class="headerlink" title="CIOU Loss"></a>CIOU Loss</h2><h3 id="函数定义与性质-3"><a href="#函数定义与性质-3" class="headerlink" title="函数定义与性质"></a>函数定义与性质</h3><script type="math/tex; mode=display">CIOU(B,B^{gt})=DIOU(B,B^{gt})-\alpha\upsilon\\L_{reg}(B,B^{gt})=1-CIOU(B,B^{gt})</script><p>其中</p><script type="math/tex; mode=display">\alpha=\frac{\upsilon}{(1-IOU)+\upsilon}\\  \upsilon = \frac{4}{\pi ^2}\left(arctan\frac{w^{gt}}{h^{gt}}-arctan\frac{w}{h} \right)^2</script><h3 id="优缺点分析-2"><a href="#优缺点分析-2" class="headerlink" title="优缺点分析"></a>优缺点分析</h3><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ul><li>在 DIOU 基础上，考虑了长宽比的回归</li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 目标检测 </tag>
            
            <tag> 损失函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于矩阵求导的理解</title>
      <link href="/2020/04/05/%E5%85%B3%E4%BA%8E%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2020/04/05/%E5%85%B3%E4%BA%8E%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="矩阵微分"><a href="#矩阵微分" class="headerlink" title="矩阵微分"></a>矩阵微分</h2><blockquote><p>为了书写方便，常把单个函数对多个变量或者多元函数对单个变量的偏导数写成向量或者矩阵的形式，使其可以当做一个整体处理。矩阵微积分是多元微积分的一种表达方式，即可以使用矩阵和向量来表示因变量每个成分关于自变量每个成分的偏导数。 ——《神经网络与深度学习》</p></blockquote><p>对这句话的理解：</p><ol><li><p>矩阵微分是多元函数求导的一种书写行书，它的结果是各个偏导数的按照某一规定的布局。</p></li><li><p>矩阵微分的结果是一个矩阵或者向量，它内部一定包含 <strong>因变量里每一个成分关于自变量里每一个分量的偏导数</strong> ，即</p><script type="math/tex; mode=display"> \frac{\partial{\pmb{Y}}}{\partial{\pmb{X}}}=  \left[  \begin{matrix}     &  &  \\     & \frac{\partial y_i}{\partial x_j} &  \\    &  &    \end{matrix}   \right]\\   y_i\in\pmb{Y},x_j\in\pmb{X}</script></li><li><p>这里的 $\frac{\partial y_i}{\partial x_j}$ 是一个代表元素， 下标 $i$ 和 $j$ 也可以理解为在分母布局下的第 $i$ 行、第 $j$ 列 ; 在分子布局下的第 $i$ 列、第 $j$ 行，关于分子布局分母布局见下面。</p></li></ol><a id="more"></a><blockquote><p>矩阵微积分的表示通常有两种符号约定： 分子布局（ Numerator Layout）和分母布局 （ Denominator Layout）。两者的区别是一个标量关于一个向量的导数是写成列向量还是行向量 。</p></blockquote><p>例：</p><p>分子布局下</p><script type="math/tex; mode=display">\pmb{X}=[x_1,...,x_n]\\\frac{\partial{y}}{\partial{\pmb{X}}}=[ \begin{matrix}   \frac{\partial{y}}{\partial{}x_1},   \frac{\partial{y}}{\partial{}x_2},   ...,   \frac{\partial{y}}{\partial{}x_n}  \end{matrix}]</script><p>分母布局下</p><script type="math/tex; mode=display">\pmb{X}=[x_1,...,x_n]\\\frac{\partial{y}}{\partial{\pmb{X}}}=\left[ \begin{matrix}   \frac{\partial{y}}{\partial{}x_1}\\   \frac{\partial{y}}{\partial{}x_2}\\   .\\   .\\   .\\   \frac{\partial{y}}{\partial{}x_n}\\  \end{matrix}\right]</script><p>我的理解：</p><ol><li>既然矩阵微分是对偏导数的布局，那么布局就不能随便布局，就得按照一定规律和顺序把它们排布在结果矩阵上，要么结果矩阵中，对于每一行内的所有元素自变量都相同，因变量按下标顺序从头写按到尾，要么对于每一行内的所有元素因变量都相同，自变量按下标顺序从头写按到尾</li><li>如果每一行内的所有元素自变量都相同，因为自变量在分母，所以叫分母布局</li><li>如果每一行内的所有元素因变量都相同，因为因变量在分子，所以叫分子布局</li><li>如上面的分子布局中，分子只有一个，所以结果只有一行，分子保持不变，分母有n个，所以结果有n列；分母布局中，分母有n个，所以有n行，分子只有一个，所以只有一列</li><li>分母布局和分子布局是转置关系，看结果中的每一行每一列是分子不变还是分母不变就知道是啥布局了</li></ol><p>更多例子：</p><p><img src="/2020/04/05/%E5%85%B3%E4%BA%8E%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E7%9A%84%E7%90%86%E8%A7%A3/image-20200309205909365.png" alt="image-20200309205909365"></p><p><img src="/2020/04/05/%E5%85%B3%E4%BA%8E%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E7%9A%84%E7%90%86%E8%A7%A3/image-20200309205922941.png" alt="image-20200309205922941"></p><h2 id="矩阵与标量、标量与矩阵"><a href="#矩阵与标量、标量与矩阵" class="headerlink" title="矩阵与标量、标量与矩阵"></a>矩阵与标量、标量与矩阵</h2><p>矩阵参与求导运算，其实就把矩阵拆分成向量组，最后还是再算向量的微分，然后将结果拼在一起。</p><h3 id="标量对矩阵求导"><a href="#标量对矩阵求导" class="headerlink" title="标量对矩阵求导"></a>标量对矩阵求导</h3><script type="math/tex; mode=display">\frac{\partial y}{\partial\mathbf{X}}=\begin{bmatrix}\frac{\partial y}{\partial x_{11}} & \frac{\partial y}{\partial x_{12}} & \cdots & \frac{\partial y}{\partial x_{1q}}\\\frac{\partial y}{\partial x_{21}} & \frac{\partial y}{\partial x_{22}} & \cdots & \frac{\partial y}{\partial x_{2q}}\\\vdots & \vdots & \ddots & \vdots\\\frac{\partial y}{\partial x_{p1}} & \frac{\partial y}{\partial x_{p2}} & \cdots & \frac{\partial y}{\partial x_{pq}}\end{bmatrix}</script><h3 id="矩阵对标量求导"><a href="#矩阵对标量求导" class="headerlink" title="矩阵对标量求导"></a>矩阵对标量求导</h3><script type="math/tex; mode=display">\frac{\partial\mathbf{Y}}{\partial x}=\begin{bmatrix}\frac{\partial y_{11}}{\partial x} & \frac{\partial y_{21}}{\partial x} & \cdots & \frac{\partial y_{m1}}{\partial x}\\\frac{\partial y_{12}}{\partial x} & \frac{\partial y_{22}}{\partial x} & \cdots & \frac{\partial y_{m2}}{\partial x}\\\vdots & \vdots & \ddots & \vdots\\\frac{\partial y_{1n}}{\partial x} & \frac{\partial y_{2n}}{\partial x} & \cdots & \frac{\partial y_{mn}}{\partial x}\end{bmatrix}</script><h3 id="矩阵对矩阵求导"><a href="#矩阵对矩阵求导" class="headerlink" title="矩阵对矩阵求导"></a>矩阵对矩阵求导</h3><p>将矩阵视为向量组，每个向量组对向量组求导。</p><h2 id="矩阵求导运算思路与运算法则"><a href="#矩阵求导运算思路与运算法则" class="headerlink" title="矩阵求导运算思路与运算法则"></a>矩阵求导运算思路与运算法则</h2><h3 id="运算思路：代表元素法"><a href="#运算思路：代表元素法" class="headerlink" title="运算思路：代表元素法"></a>运算思路：代表元素法</h3><p>因为无论是矩阵求导，还是向量求导，本质都是每个元素对元素的求导，所以在分析求导问题的时候，可以从结果矩阵中，选取第 $i$ 行 $j$ 列为代表元素，因为代表元素一定是标量的求导，这时可以用熟悉的标量求导法则来推证。</p><h3 id="代表元素法证明矩阵求导的加减法则"><a href="#代表元素法证明矩阵求导的加减法则" class="headerlink" title="代表元素法证明矩阵求导的加减法则"></a>代表元素法证明矩阵求导的加减法则</h3><script type="math/tex; mode=display">\frac{\partial(\pmb Y+\pmb Z)}{\partial \pmb X}=\frac{\partial(\pmb Y)}{\partial \pmb X}+\frac{\partial(\pmb Z)}{\partial \pmb X}</script><p>证明:</p><p>假设</p><script type="math/tex; mode=display">\pmb{Z}=(z_1,...,z_n)\\\pmb{Y}=(y_1,...,y_n)\\\pmb{X}=(x_1,...,x_n)</script><p>由矩阵加法得</p><script type="math/tex; mode=display">\pmb Y+\pmb Z=(y_1+z_1,...,y_n+z_n)\\\frac{\partial(\pmb Y+\pmb Z)}{\partial \pmb X}= \left[ \begin{matrix}    &  &  \\    & \frac{\partial( y_i + z_i)}{\partial x_j} &  \\   &  &   \end{matrix}  \right]\\ ( y_i + z_i)\in\pmb{Y}+\pmb{Z},x_j\in\pmb{X}\\ =  \left[ \begin{matrix}    &  &  \\    & \frac{\partial( y_i)}{\partial x_j}+\frac{\partial( z_i)}{\partial x_j} &  \\   &  &   \end{matrix}  \right]\\  y_i\in\pmb{Y},z_i\in\pmb{Z},x_j\in\pmb{X}\\</script><p>因为下标 $i$ 和 下标 $j$ 是独立的，所以一定能取遍 $X,Y,Z$ 中所有的分量，故</p><script type="math/tex; mode=display"> \left[ \begin{matrix}    &  &  \\    & \frac{\partial( y_i)}{\partial x_j}+\frac{\partial( z_i)}{\partial x_j} &  \\   &  &   \end{matrix}  \right]  =\left[ \begin{matrix}    &  &  \\    & \frac{\partial( y_i)}{\partial x_j} &  \\   &  &   \end{matrix}  \right]+\left[ \begin{matrix}    &  &  \\    & \frac{\partial( z_i)}{\partial x_j} &  \\   &  &   \end{matrix}  \right]\\  y_i\in\pmb{Y},z_i\in\pmb{Z},x_j\in\pmb{X}\\  =\frac{\partial(\pmb Y)}{\partial \pmb X}+\frac{\partial(\pmb Z)}{\partial \pmb X}</script><h3 id="代表元素法证明乘法法则"><a href="#代表元素法证明乘法法则" class="headerlink" title="代表元素法证明乘法法则"></a>代表元素法证明乘法法则</h3><script type="math/tex; mode=display">\frac{\partial(\pmb Y\cdot\pmb Z)}{\partial \pmb X}=\frac{\partial(\pmb Y)}{\partial \pmb X}\pmb Z+\frac{\partial(\pmb Z)}{\partial \pmb X}\pmb Y</script><p>证明：</p><p>假设 $X,Y,Z$ 为n维列向量，则</p><script type="math/tex; mode=display">\pmb Y \cdot \pmb Z=\pmb Y ^T \pmb Z=\sum_{i=1}^{n}y_iz_i\\\frac{\partial\pmb Y\cdot\pmb Z}{\partial \pmb X}= \left[ \begin{matrix}    &  &  \\    & \frac{\partial(\sum_{i=1}^{n}y_iz_i)}{\partial x_j} &  \\   &  &   \end{matrix}  \right]\\ x_j\in\pmb{X}\\</script><p>事实上由标量导数的性质和矩阵加法可得， $\sum_{i=1}^{n}y_iz_i$ 的累加符号可以提出去</p><script type="math/tex; mode=display">\left[ \begin{matrix}    &  &  \\    & \frac{\partial(\sum_{i=1}^{n}y_iz_i)}{\partial x_j} &  \\   &  &   \end{matrix}  \right]=  \sum_{k=1}^{n}   \left[ \begin{matrix}    &  &  \\    & \frac{\partial(y_kz_k)}{\partial x_j} &  \\   &  &   \end{matrix}  \right]=  \sum_{k=1}^{n}   \left[ \begin{matrix}    &  &  \\    & \frac{\partial(y_k)}{\partial x_j}z_k+\frac{\partial(z_k)}{\partial x_j}y_k &  \\   &  &   \end{matrix}  \right]\\  =  \sum_{k=1}^{n}   \left[ \begin{matrix}    &  &  \\    & \frac{\partial(y_k)}{\partial x_j}z_k &  \\   &  &   \end{matrix}  \right]+ \sum_{k=1}^{n}   \left[ \begin{matrix}    &  &  \\    & \frac{\partial(z_k)}{\partial x_j}y_k &  \\   &  &   \end{matrix}  \right]\\   x_j\in\pmb{X}\\</script><p>考察第一项，由矩阵加法可得：</p><script type="math/tex; mode=display">\sum_{k=1}^{n}   \left[ \begin{matrix}    &  &  \\    & \frac{\partial(y_k)}{\partial x_j}z_k &  \\   &  &   \end{matrix}  \right]   =    \left[ \begin{matrix}    &  &  \\    &  \sum_{k=1}^{n}\frac{\partial(y_k)}{\partial x_j}z_k &  \\   &  &   \end{matrix}  \right] \\   x_j\in\pmb{X}\\</script><p>方框内的是代表元素，在分母布局下，$x_j$ 的下标 $j$ 表示第 $j$ 行 , 所以该矩阵全貌是</p><script type="math/tex; mode=display">\left[ \begin{matrix}    &  &  \\    &  \sum_{k=1}^{n}\frac{\partial(y_k)}{\partial x_j}z_k &  \\   &  &   \end{matrix}  \right]  =      \left[ \begin{matrix}     \sum_{k=1}^{n}\frac{\partial(y_k)}{\partial x_1}z_k   \\    \sum_{k=1}^{n}\frac{\partial(y_k)}{\partial x_2}z_k  \\   .\\   .\\   .\\    \sum_{k=1}^{n}\frac{\partial(y_k)}{\partial x_n}z_k   \end{matrix}  \right] \\</script><p>由</p><script type="math/tex; mode=display">\sum_{i=1}^n a_ib_i=[a_1,...,a_n] \left[ \begin{matrix}   b_1  \\   .\\   .\\   .\\   b_n  \end{matrix} \right]</script><p>很容易判断出</p><script type="math/tex; mode=display">\left[ \begin{matrix}     \sum_{k=1}^{n}\frac{\partial(y_k)}{\partial x_1}z_k   \\    \sum_{k=1}^{n}\frac{\partial(y_k)}{\partial x_2}z_k  \\   .\\   .\\   .\\    \sum_{k=1}^{n}\frac{\partial(y_k)}{\partial x_n}z_k   \end{matrix}  \right]   =   \left[ \begin{matrix}    \frac{\partial(y_1)}{\partial x_1}&...& \frac{\partial(y_n)}{\partial x_1} \\   . & & .\\    . & & .\\   . & & .\\    \frac{\partial(y_1)}{\partial x_n}&...& \frac{\partial(y_n)}{\partial x_x}  \end{matrix}  \right]\left[ \begin{matrix}   z_1  \\   .\\   .\\   .\\   z_n  \end{matrix} \right] = \frac{\partial(\pmb Y)}{\partial \pmb X}\pmb Z</script><p>同理可证，第二项：</p><script type="math/tex; mode=display">\sum_{k=1}^{n}   \left[ \begin{matrix}    &  &  \\    & \frac{\partial(z_k)}{\partial x_j}y_k &  \\   &  &   \end{matrix}  \right]=\frac{\partial(\pmb Z)}{\partial \pmb X}\pmb Y\\</script><p>此时原式得证</p><script type="math/tex; mode=display">\frac{\partial(\pmb Y\cdot\pmb Z)}{\partial \pmb X}=\frac{\partial(\pmb Y)}{\partial \pmb X}\pmb Z+\frac{\partial(\pmb Z)}{\partial \pmb X}\pmb Y</script><h3 id="矩阵求导运算法则"><a href="#矩阵求导运算法则" class="headerlink" title="矩阵求导运算法则"></a>矩阵求导运算法则</h3><p>其他乘法法则和链式法则也可以用类似的证明思路得到，这里略</p><p><img src="/2020/04/05/%E5%85%B3%E4%BA%8E%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E7%9A%84%E7%90%86%E8%A7%A3/image-20200310171445012.png" alt="image-20200310171445012"></p><p><img src="/2020/04/05/%E5%85%B3%E4%BA%8E%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E7%9A%84%E7%90%86%E8%A7%A3/image-20200310171505597.png" alt="image-20200310171505597"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 矩阵求导 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习中的“分布”</title>
      <link href="/2020/04/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83/"/>
      <url>/2020/04/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从在输入空间中的一个具体的实例上抽出一些属性，将这些属性组成一组向量，这组向量被称为特征向量。当一个特征向量输入到“学习器”中，“学习器”可以依据输入的特征向量返还一个期望的结果。用通俗的话讲，可以将“学习器”视为一个函数，建立一个输入空间到输出空间的映射，映射规则是由不断训练建立起来的。</p><p>一个特征向量所期望的结果，被称为标签。在学习器的训练阶段，我们将特征向量与该特征向量对应的标签一同输入到学习器内，学习器根据自身输出与期望输出的“距离”进行自我优化，不断缩小输出与期望的差距。</p><p>考虑到学习器的泛化问题，我们并不要求学习器的输出与期望完全一致，通常我们设立一个相对较“软”的指标。比如对于分类任务而言，我们并不要求学习器输出具体的类别，而是要求学习器输出该特征向量所描述的实例属于某个类的概率是多少；对于回归任务而言，我们期望输出值与期望值尽可能的接近而非完全相同。</p><p>习惯上讲特征向量组成的空间称为“特征空间”，也叫”样本空间“，所以特征向量又称为“样本”。在西瓜书中写道：</p><blockquote><p>通常假设样本空间中全体样本服从一个未知的“分布”（distribution），我们获得的每个样本都是独立地从这个分布上采样获得的，即“独立同分布”（independent and identically distributed，简称 i.i.d.） ——《机器学习》 周志华</p></blockquote><p>那么问题来了，什么叫分布？什么叫独立同分布？为什么要这样假设？</p><p>本文即是我个人对机器学习中“分布”的理解。</p><h2 id="什么叫分布？"><a href="#什么叫分布？" class="headerlink" title="什么叫分布？"></a>什么叫分布？</h2><p>我试图从概率分布对分布进行理解，要理解概率分布，先要搞清楚一个名词——随机变量</p><h3 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h3><blockquote><p>随机变量（random variable）表示随机试验各种结果的实值单值函数。随机事件不论与数量是否直接有关，都可以数量化，即都能用数量化的方式表达。  </p><p>随机事件数量化的好处是可以用数学分析的方法来研究随机现象。例如某一时间内公共汽车站等车乘客人数，电话交换台在一定时间内收到的呼叫次数，灯泡的寿命等等，都是随机变量的实例。</p></blockquote><p>简单来说，随机变量就是把事件抽象为一个数值，这个数值可以是事件的结果、事件的编号、事件的属性等。同一个事件，从不同角度进行抽象，将得到不同的随机变量。比如“一枚灯泡的寿命”，如果从单枚灯泡的角度进行抽象，那么寿命可以为 1年，2年，10年，这里 1 2 10 就是一组随机变量，如果从不同类型的灯泡角度抽象，1号灯泡寿命到达10年，2号灯泡寿命到达10，4号灯泡寿命到达10年，这里的 1 2 4 又是一组随机变量，这两组随机变量因为意义不同，所以是不能放在一起讨论的，所以只有相同意义的随机变量才能放在一起讨论，下面概率分布中所提及的随机变量，都是指意义相同的随机变量。</p><h3 id="概率分布"><a href="#概率分布" class="headerlink" title="概率分布"></a>概率分布</h3><p>概率分布，是指用于表述随机变量取值的概率规律。将随机变量作为横轴，概率作为纵轴，把随机变量与对应变量画上去，构成一个图形，这个图像就是概率分布的直观表示。通常也用概率分布函数表示 $F(x)$ 来描述一个概率分布，概率分布函数被定义为：</p><script type="math/tex; mode=display">F(x)=P\{X<x\}</script><p>总之概率分布也可以理解为一个函数，它刻画了随机变量与概率的映射关系，给定一个概率分布，就可以求任何随机变量对应的概率了。当一个随机变量与它的概率满足某一个概率分布的映射关系时，则称这个随机变量服从该概率分布。</p><h3 id="机器学习中的-“分布”-是概率分布吗？"><a href="#机器学习中的-“分布”-是概率分布吗？" class="headerlink" title="机器学习中的 “分布” 是概率分布吗？"></a>机器学习中的 “分布” 是概率分布吗？</h3><p>前文西瓜书中所提及的分布，即为概率分布，指每个样本从样本空间中被抽到的概率遵循统一的概率分布。为了说明，假设一个样本空间的抽样服从以下概率分布：</p><div class="table-container"><table><thead><tr><th style="text-align:center">$\pmb X$</th><th style="text-align:center">猫</th><th style="text-align:center">狗</th></tr></thead><tbody><tr><td style="text-align:center"><strong>P</strong></td><td style="text-align:center">0.5</td><td style="text-align:center">0.5</td></tr></tbody></table></div><p>这里的 $\pmb X$ 是表示从样本空间的任抽取一例所得结果的随机变量，可取 { 猫，狗 } ；<strong>P</strong> 是随机变量对应的概率。</p><p>假设样本空间的随机变量  $\pmb X$ 服从上述概率分布，从样本空间中独立地、按照上述分布地进行抽样，最终得到得到 n 个样本 $(\pmb X_1,\pmb X_2,\dots,\pmb X_n)$ , 其中 $\pmb X_i$ 是相互独立且均与 $\pmb X$ 服从同一概率分布的随机变量，所以 $\pmb X_i$ 的取值范围和每个取值对应的概率都与 $\pmb X$ 相同。</p><p>也就是说在独立同分布的假设下，每个样本取到猫还是取到狗的概率都各占 0.5 ，随着样本数目的增多，在所有样本中任取一个样本是猫是狗的概率分布也将趋近于总体的概率分布，如此而来，虽然样本数目远不及总体，但可以尽可能全面地表现总体的特征，这便是独立同分布的意义。</p><h3 id="如何理解-“分布”-的概念"><a href="#如何理解-“分布”-的概念" class="headerlink" title="如何理解 “分布” 的概念"></a>如何理解 “分布” 的概念</h3><p>将随机变量的取值与其对于的概率，画在随机变量为横轴、概率为纵轴的直角坐标系上，所有点构成的图像，即为概率分布的一个直观形象。也可以说，概率分布就是指这个图像。在直角坐标系上的一个图像，又对应着横轴与纵轴的一种映射关系，所以也可以说，概率分布是随机变量与概率的映射关系。那么什么是 “分布” 呢，<strong>“分布” 即是一个描述直角坐标系上图像的词，一个描述映射关系的词</strong>。如：频数分布，其实是在描述随机变量与频数的映射，XX分布，就是描述某一变量与XX的映射。总结一下就是：<strong>分布即图像、分布即映射</strong> 。</p><p>首先需要理解，什么是叫独立，什么叫同分布。</p><p>独立好理解，就是指一个特征向量的结果不影响另外一个特征向量，</p><p>同分布按照我的理解就是指所有特征向量与其期望的输出都具有相同的映射关系，即这个映射关系在这个样本集唯一。</p><p><strong>为什么要求独立呢？</strong></p><p>想想也是，我们最终学得的一个“学习器”，这个“学习器”被定义为一个特征向量与模型输出的映射关系，如果一个特征向量的结果，受到另一个特征向量的影响，此时两个特征向量不独立，如果我们想得到一个正确的输出需要把两个特征向量都输入进去，否则学习器会困惑，具体一点的例子就是，把一张只有猫尾巴的图片作为训练素材输入给一个“猫狗分类的学习器”进行训练，最后学习器肯定得不到一个好结果。</p><p><strong>为什么要求同分布呢？</strong></p><p>也是这个道理，大多数“学习器”只能在大量训练中，学会一种映射关系，比如猫狗分类任务，”学习器“的输出非猫即狗，这时候混几张兔子的素材进去，“学习器”准确度肯定要下降，此时对于猫狗素材而言，它的特征向量与期望输出存在一种映射关系，对于兔子素材而言，它的特征向量与期望输出存在的映射关系，一定与猫狗素材的不同，此时训练集的样本就没有满足同分布。</p><p>所以一个优质的训练集，样本独立同分布是一个必不可少的前提，如果样本不独立，那么学习器学不到完整的特征，如果样本不同分布，则学习会在不同映射规则之中跳来跳去。独立同分布少了哪个都会让学习器变的不稳定。</p><h2 id="BN-论文中所提及的-“分布”"><a href="#BN-论文中所提及的-“分布”" class="headerlink" title="BN 论文中所提及的 “分布”"></a>BN 论文中所提及的 “分布”</h2><p>“分布” 这个词另一个提出场景，就是在 BN 解决 ICS 的时候，</p><blockquote><p>在文章<a href="https://arxiv.org/abs/1502.03167" target="_blank" rel="noopener">Batch Normalization:Accelerating Deep Network Training by Reducing Internal Covariate Shift</a>中，其对BN与ICS是这样解释的：由于前一层的参数更新，所以这一层的输入（前一层的输出）的分布会发生变化，这种现象被称之为ICS。同样，这篇文章的观点认为BN  work的真正原因，在与其将数据的分布都归一化到均值为0，方差为1的分布上去。因此，每一层的输入（上一层输出经过BN后）分布的稳定性都提高了，故而整体减小了网络的ICS。</p><p>原文：<a href="https://zhuanlan.zhihu.com/p/52749286" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/52749286</a></p></blockquote><p>这里的分布听上去也不像概率分布，更像最大最小值区间，所以可以理解为一个特征向量到特征向量所在区间的映射，神经网络的映射规则是由特征向量与一组参数的组合运算实现，总会有一些神经元对特征向量的变化很敏感，如果期望输出不变，特征向量所在区间发送了较大的改变，说明特征向量数值波动较大，那么这些神经元可能无法很好的拟合这个映射规则，所以要通过 BN 把所有特征向量都固定在一个相对集中的区间。</p><p>顺嘴一起提，已有论文证明，BN 其实与 ICS 无关，参考链接：</p><p><a href="https://zhuanlan.zhihu.com/p/52749286" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/52749286</a></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 概率分布 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YOLO3 参数学习 Keras源码分析</title>
      <link href="/2020/04/04/YOLO3%20%E5%8F%82%E6%95%B0%E5%AD%A6%E4%B9%A0%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2020/04/04/YOLO3%20%E5%8F%82%E6%95%B0%E5%AD%A6%E4%B9%A0%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="参数学习"><a href="#参数学习" class="headerlink" title="参数学习"></a>参数学习</h2><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>Keras 源码中的损失函数：</p><script type="math/tex; mode=display">loss(object)=-\sum_{i=0}^{K\times K}\sum_{j=0}^M I_{ij}^{obj} \cdot (2-w_i\times h_i) \cdot [\hat x_ilog(x_i)+(1-\hat x_i)log(1-x_i)]-\\ \sum_{i=0}^{K\times K}\sum_{j=0}^M I_{ij}^{obj} \cdot (2-w_i\times h_i) \cdot [\hat y_ilog(y_i)+(1-\hat y_i)log(1-y_i)]+\\ 0.5 \cdot \sum_{i=0}^{K\times K}\sum_{j=0}^M I_{ij}^{obj} \cdot (2-w_i\times h_i) \cdot [(w_i-\hat w_i)^2+(h_i-\hat h_i)^2]-\\\sum_{i=0}^{K\times K}\sum_{j=0}^M I_{ij}^{obj} \cdot [\hat C_ilog(C_i)+(1-\hat C_i)log(1-C_i)]-\\\sum_{i=0}^{K\times K}\sum_{j=0}^M I_{ij}^{noobj} \cdot [\hat C_ilog(C_i)+(1-\hat C_i)log(1-C_i)]-\\\sum_{i=0}^{K\times K}\sum_{j=0}^M \sum_{c \in classes} I_{ij}^{obj} \cdot [\hat p_i(c)log(p_i(c))+(1-\hat p_i(c))log(1-(p_i(c))]\\</script><p>$K \times K$ 是网格数目，$M$ 是每个网格锚框数目，$I_{ij}^{obj}$ 表示 <code>i</code> 号 网格中 <code>j</code> 号锚框是否负责物体，所谓负责物体就是指是否有物体的中心落到这个锚框，如果有物体就落入则值，没物体落入则值为0。$w_i,h_i,x_i,y_i$ 表示网络预测的盒子长宽和中心位置，戴帽子的表示的是真实的长宽和中心位置。$C_i$ 是网络的预测的置信度，带帽是真实置信度。$p_i(c)$ 表示类别为 <code>c</code> 的概率，带帽表示真实概率。</p><a id="more"></a><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="基础函数"><a href="#基础函数" class="headerlink" title="基础函数"></a>基础函数</h4><h5 id="yolo-head"><a href="#yolo-head" class="headerlink" title="yolo_head"></a><code>yolo_head</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">yolo_head</span><span class="params">(feats, anchors, num_classes, input_shape, calc_loss=False)</span>:</span></span><br><span class="line">    <span class="string">"""Convert final layer features to bounding box parameters."""</span></span><br><span class="line">    num_anchors = len(anchors)</span><br><span class="line">    <span class="comment"># Reshape to batch, height, width, num_anchors, box_params.</span></span><br><span class="line">    anchors_tensor = K.reshape(K.constant(anchors), [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, num_anchors, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    grid_shape = K.shape(feats)[<span class="number">1</span>:<span class="number">3</span>] <span class="comment"># height, width</span></span><br><span class="line">    grid_y = K.tile(K.reshape(K.arange(<span class="number">0</span>, stop=grid_shape[<span class="number">0</span>]), [<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]),</span><br><span class="line">        [<span class="number">1</span>, grid_shape[<span class="number">1</span>], <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">    grid_x = K.tile(K.reshape(K.arange(<span class="number">0</span>, stop=grid_shape[<span class="number">1</span>]), [<span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>]),</span><br><span class="line">        [grid_shape[<span class="number">0</span>], <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">    grid = K.concatenate([grid_x, grid_y])</span><br><span class="line">    grid = K.cast(grid, K.dtype(feats))</span><br><span class="line"></span><br><span class="line">    feats = K.reshape(</span><br><span class="line">        feats, [<span class="number">-1</span>, grid_shape[<span class="number">0</span>], grid_shape[<span class="number">1</span>], num_anchors, num_classes + <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Adjust preditions to each spatial grid point and anchor size.</span></span><br><span class="line">    box_xy = (K.sigmoid(feats[..., :<span class="number">2</span>]) + grid) / K.cast(grid_shape[::<span class="number">-1</span>], K.dtype(feats))</span><br><span class="line">    box_wh = K.exp(feats[..., <span class="number">2</span>:<span class="number">4</span>]) * anchors_tensor / K.cast(input_shape[::<span class="number">-1</span>], K.dtype(feats))</span><br><span class="line">    box_confidence = K.sigmoid(feats[..., <span class="number">4</span>:<span class="number">5</span>])</span><br><span class="line">    box_class_probs = K.sigmoid(feats[..., <span class="number">5</span>:])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> calc_loss == <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">return</span> grid, feats, box_xy, box_wh</span><br><span class="line">    <span class="keyword">return</span> box_xy, box_wh, box_confidence, box_class_probs</span><br></pre></td></tr></table></figure><p>该函数用于从最终输出的特征图里提取预测框信息</p><p>参数 :</p><ul><li><strong>feats</strong> : 特征图，通道数为 <code>5+类别数目</code></li><li><strong>anchors :</strong> 特征图中所含锚框，结构为 <code>[[w1,h1],[w2,h2],...]</code></li><li><strong>num_classes</strong> : 类别数目</li><li><strong>input_shape</strong> :  原图尺寸信息，<code>(高,宽)</code></li><li><strong>calc_loss</strong> : 是否用于计算 loss 值 </li></ul><p>返回 :</p><ul><li><p>如果 <code>calc_loss == True</code> ，则返回 <code>grid, feats, box_xy, box_wh</code></p></li><li><p>否则返回 <code>box_xy, box_wh, box_confidence, box_class_probs</code></p></li><li><p>其中<code>grid, feats, box_xy, box_wh, box_confidence, box_class_probs</code> 分别是网格坐标信息、原始特征图信息、预测框中心点坐标比例（相对于原图）、预测框大小比例（相对于锚框）、置信度、类别信息。</p></li><li><p>形状的形状信息为：</p>  <figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">grid.shape</span>=(特征图高,特征图宽,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="attr">feats.shape</span>=(批数,特征图高,特征图宽,锚框数,<span class="number">5</span>+类别数)</span><br><span class="line"><span class="attr">box_xy.shape</span>=(批数,特征图高,特征图宽,锚框数,<span class="number">2</span>)</span><br><span class="line"><span class="attr">box_wh.shape</span>=(批数,特征图高,特征图宽,锚框数,<span class="number">2</span>)</span><br><span class="line"><span class="attr">box_confidence.shape</span>=(批数,特征图高,特征图宽,锚框数,<span class="number">1</span>)</span><br><span class="line"><span class="attr">box_class_probs.shape</span>=(批数,特征图高,特征图宽,锚框数,类别数)</span><br></pre></td></tr></table></figure></li></ul><p>执行过程 :</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""Convert final layer features to bounding box parameters."""</span></span><br><span class="line">num_anchors = len(anchors)</span><br><span class="line"><span class="comment"># Reshape to batch, height, width, num_anchors, box_params.</span></span><br><span class="line">anchors_tensor = K.reshape(K.constant(anchors), [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, num_anchors, <span class="number">2</span>])</span><br></pre></td></tr></table></figure><ul><li>获取锚框数目 <code>num_achors</code> </li><li>将 <code>anchors</code> 转化为 tf 张量 <code>anchors_tensor</code>，并将形状改变为<code>shape=1, 1, 1, num_anchors, 2</code> </li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">grid_shape = K.shape(feats)[<span class="number">1</span>:<span class="number">3</span>] <span class="comment"># height, width</span></span><br><span class="line">grid_y = K.tile(K.reshape(K.arange(<span class="number">0</span>, stop=grid_shape[<span class="number">0</span>]), [<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]),</span><br><span class="line">[<span class="number">1</span>, grid_shape[<span class="number">1</span>], <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">grid_x = K.tile(K.reshape(K.arange(<span class="number">0</span>, stop=grid_shape[<span class="number">1</span>]), [<span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>]),</span><br><span class="line">[grid_shape[<span class="number">0</span>], <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">grid = K.concatenate([grid_x, grid_y])</span><br><span class="line">grid = K.cast(grid, K.dtype(feats))</span><br></pre></td></tr></table></figure><ul><li><p>获取特征图尺寸 <code>grid_shape</code></p></li><li><p>通过 <code>K.arange(0, stop=grid_shape[0])</code> 生成一个长度为特征图高度的向量，元素值是<code>0,1,2,...,grid_shape[0]-1</code> ; 用<code>a</code> 代指上述向量，利用 <code>K.reshape(a, [-1, 1, 1, 1])</code> 将上述向量变成 4 维张量，张量 <code>shape=(特征图高,1,1,1)</code> ；用 <code>b</code> 代指上述张量，利用 <code>K.tile(b, [1, grid_shape[1], 1, 1])</code> 将上述张量，变成 <code>shape=(特征图高,特征图宽,1,1)</code> 的 4 维向量，将结果记为 <code>grid_y</code> </p><p>  <code>grid_y</code>  表示每个格子的纵坐标，比如<code>grid_y[5,9,0,0]==5</code> 意思是：特征图中横坐标是 9 、纵坐标是 5 的像素点的纵坐标是 5，<strong>这里特征图的一个像素点被称为一个网格</strong>。</p></li><li><p>相似的手段求 <code>grid_x</code></p><p>  <code>grid_x = K.tile(K.reshape(K.arange(0, stop=grid_shape[1]), [1, -1, 1, 1]),[grid_shape[0], 1, 1, 1])</code> ，注意求 <code>grid_x</code> 和求 <code>grid_y</code> 不一样的地方在于 <code>-1</code> 的位置。</p><p>  <code>grid_y[5,9,0,0]==9</code> 意思是：特征图中横坐标是 9、纵坐标是 5 的网格的横坐标坐标是 5。</p></li><li><p>通过 <code>K.concatenate</code> 连接 <code>grid_x</code> 和 <code>grid_y</code>  并记为<code>grid</code>，注意<code>K.concatenate</code> 默认是沿着最后一个轴连接。将 <code>grid</code> 转化为浮点型。</p><p>  <code>grid</code> 的性质是<code>(特征图高,特征图宽,1,2)</code> , 它表示每个格子的横纵坐标，比如：<code>grid[5,9,1]==(9,5)</code> 即横坐标是 9、纵坐标是 5 的格子（像素点）坐标是<code>(9,5)</code></p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">feats = K.reshape(</span><br><span class="line"> feats, [<span class="number">-1</span>, grid_shape[<span class="number">0</span>], grid_shape[<span class="number">1</span>], num_anchors, num_classes + <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Adjust preditions to each spatial grid point and anchor size.</span></span><br><span class="line">box_xy = (K.sigmoid(feats[..., :<span class="number">2</span>]) + grid) / K.cast(grid_shape[::<span class="number">-1</span>], K.dtype(feats))</span><br><span class="line">box_wh = K.exp(feats[..., <span class="number">2</span>:<span class="number">4</span>]) * anchors_tensor / K.cast(input_shape[::<span class="number">-1</span>], K.dtype(feats))</span><br><span class="line">box_confidence = K.sigmoid(feats[..., <span class="number">4</span>:<span class="number">5</span>])</span><br><span class="line">box_class_probs = K.sigmoid(feats[..., <span class="number">5</span>:])</span><br></pre></td></tr></table></figure><ul><li>参数 <code>feats</code> 变化维度为 <code>(批数,特征图高,特征图宽,锚框数,5+类别数)</code> 这样的目的是和标注信息形状一致</li><li>计算预测框中心点比例 <code>box_xy</code>，计算方法是：将特征图 0 通道和 1 通道的信息经过<code>K.sigmoid()</code> 压缩至 0 到 1 后，加上网格坐标信息，将上述张量和分别除以网格的高和宽，最终得到一个相对于网格大小的坐标比例信息，因为网格大小由原图大小缩放而来，故可<strong>认为相对于网格大小的坐标比例信息，就是相对于原图的坐标比例信息</strong>。</li><li>同理通过将特征图的 2 通道和 4 通道的数据输送给<code>K.exp()</code>，再乘上锚框张量 <code>anchors_tensor</code> , 除以网格高和宽，得到相对于锚框的大小比例信息 <code>box_wh</code></li><li>将 4 通道数据通过 <code>K.sigmoid()</code> 计算得置信度信息 <code>box_confidence</code></li><li>将剩下的通道的数据通过 <code>K.sigmoid()</code> 计算得到类别概率</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> calc_loss == <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">return</span> grid, feats, box_xy, box_wh</span><br><span class="line"><span class="keyword">return</span> box_xy, box_wh, box_confidence, box_class_probs</span><br></pre></td></tr></table></figure><ul><li>根据 <code>calc_loss</code> 参数返回相应的变量</li></ul><h5 id="box-iou"><a href="#box-iou" class="headerlink" title="box_iou"></a><code>box_iou</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">box_iou</span><span class="params">(b1, b2)</span>:</span></span><br><span class="line">    <span class="comment"># Expand dim to apply broadcasting.</span></span><br><span class="line">    b1 = K.expand_dims(b1, <span class="number">-2</span>)</span><br><span class="line">    b1_xy = b1[..., :<span class="number">2</span>]</span><br><span class="line">    b1_wh = b1[..., <span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">    b1_wh_half = b1_wh/<span class="number">2.</span></span><br><span class="line">    b1_mins = b1_xy - b1_wh_half</span><br><span class="line">    b1_maxes = b1_xy + b1_wh_half</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Expand dim to apply broadcasting.</span></span><br><span class="line">    b2 = K.expand_dims(b2, <span class="number">0</span>)</span><br><span class="line">    b2_xy = b2[..., :<span class="number">2</span>]</span><br><span class="line">    b2_wh = b2[..., <span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">    b2_wh_half = b2_wh/<span class="number">2.</span></span><br><span class="line">    b2_mins = b2_xy - b2_wh_half</span><br><span class="line">    b2_maxes = b2_xy + b2_wh_half</span><br><span class="line"></span><br><span class="line">    intersect_mins = K.maximum(b1_mins, b2_mins)</span><br><span class="line">    intersect_maxes = K.minimum(b1_maxes, b2_maxes)</span><br><span class="line">    intersect_wh = K.maximum(intersect_maxes - intersect_mins, <span class="number">0.</span>)</span><br><span class="line">    intersect_area = intersect_wh[..., <span class="number">0</span>] * intersect_wh[..., <span class="number">1</span>]</span><br><span class="line">    b1_area = b1_wh[..., <span class="number">0</span>] * b1_wh[..., <span class="number">1</span>]</span><br><span class="line">    b2_area = b2_wh[..., <span class="number">0</span>] * b2_wh[..., <span class="number">1</span>]</span><br><span class="line">    iou = intersect_area / (b1_area + b2_area - intersect_area)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> iou</span><br></pre></td></tr></table></figure><p>实现 IOU 运算</p><h4 id="实现函数"><a href="#实现函数" class="headerlink" title="实现函数"></a>实现函数</h4><h5 id="yolo-loss"><a href="#yolo-loss" class="headerlink" title="yolo_loss"></a><code>yolo_loss</code></h5><p>关于损失函数都被定义在<code>\yolo3\model.py</code> 中：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">yolo_loss</span><span class="params">(args, anchors, num_classes, ignore_thresh=<span class="number">.5</span>, print_loss=False)</span>:</span></span><br><span class="line">    num_layers = len(anchors)//<span class="number">3</span> <span class="comment"># default setting</span></span><br><span class="line">    yolo_outputs = args[:num_layers]</span><br><span class="line">    y_true = args[num_layers:]</span><br><span class="line">    anchor_mask = [[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]] <span class="keyword">if</span> num_layers==<span class="number">3</span> <span class="keyword">else</span> [[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">    input_shape = K.cast(K.shape(yolo_outputs[<span class="number">0</span>])[<span class="number">1</span>:<span class="number">3</span>] * <span class="number">32</span>, K.dtype(y_true[<span class="number">0</span>]))</span><br><span class="line">    grid_shapes = [K.cast(K.shape(yolo_outputs[l])[<span class="number">1</span>:<span class="number">3</span>], K.dtype(y_true[<span class="number">0</span>])) <span class="keyword">for</span> l <span class="keyword">in</span> range(num_layers)]</span><br><span class="line">    loss = <span class="number">0</span></span><br><span class="line">    m = K.shape(yolo_outputs[<span class="number">0</span>])[<span class="number">0</span>] <span class="comment"># batch size, tensor</span></span><br><span class="line">    mf = K.cast(m, K.dtype(yolo_outputs[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> range(num_layers):</span><br><span class="line">        object_mask = y_true[l][..., <span class="number">4</span>:<span class="number">5</span>]</span><br><span class="line">        true_class_probs = y_true[l][..., <span class="number">5</span>:]</span><br><span class="line"></span><br><span class="line">        grid, raw_pred, pred_xy, pred_wh = yolo_head(yolo_outputs[l],</span><br><span class="line">             anchors[anchor_mask[l]], num_classes, input_shape, calc_loss=<span class="literal">True</span>)</span><br><span class="line">        pred_box = K.concatenate([pred_xy, pred_wh])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Darknet raw box to calculate loss.</span></span><br><span class="line">        raw_true_xy = y_true[l][..., :<span class="number">2</span>]*grid_shapes[l][::<span class="number">-1</span>] - grid</span><br><span class="line">        raw_true_wh = K.log(y_true[l][..., <span class="number">2</span>:<span class="number">4</span>] / anchors[anchor_mask[l]] * input_shape[::<span class="number">-1</span>])</span><br><span class="line">        raw_true_wh = K.switch(object_mask, raw_true_wh, K.zeros_like(raw_true_wh)) <span class="comment"># avoid log(0)=-inf</span></span><br><span class="line">        box_loss_scale = <span class="number">2</span> - y_true[l][...,<span class="number">2</span>:<span class="number">3</span>]*y_true[l][...,<span class="number">3</span>:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Find ignore mask, iterate over each of batch.</span></span><br><span class="line">        ignore_mask = tf.TensorArray(K.dtype(y_true[<span class="number">0</span>]), size=<span class="number">1</span>, dynamic_size=<span class="literal">True</span>)</span><br><span class="line">        object_mask_bool = K.cast(object_mask, <span class="string">'bool'</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">loop_body</span><span class="params">(b, ignore_mask)</span>:</span></span><br><span class="line">            true_box = tf.boolean_mask(y_true[l][b,...,<span class="number">0</span>:<span class="number">4</span>], object_mask_bool[b,...,<span class="number">0</span>])</span><br><span class="line">            iou = box_iou(pred_box[b], true_box)</span><br><span class="line">            best_iou = K.max(iou, axis=<span class="number">-1</span>)</span><br><span class="line">            ignore_mask = ignore_mask.write(b, K.cast(best_iou&lt;ignore_thresh, K.dtype(true_box)))</span><br><span class="line">            <span class="keyword">return</span> b+<span class="number">1</span>, ignore_mask</span><br><span class="line">        _, ignore_mask = K.control_flow_ops.while_loop(<span class="keyword">lambda</span> b,*args: b&lt;m, loop_body, [<span class="number">0</span>, ignore_mask])</span><br><span class="line">        ignore_mask = ignore_mask.stack()</span><br><span class="line">        ignore_mask = K.expand_dims(ignore_mask, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># K.binary_crossentropy is helpful to avoid exp overflow.</span></span><br><span class="line">        xy_loss = object_mask * box_loss_scale * K.binary_crossentropy(raw_true_xy, raw_pred[...,<span class="number">0</span>:<span class="number">2</span>], from_logits=<span class="literal">True</span>)</span><br><span class="line">        wh_loss = object_mask * box_loss_scale * <span class="number">0.5</span> * K.square(raw_true_wh-raw_pred[...,<span class="number">2</span>:<span class="number">4</span>])</span><br><span class="line">        confidence_loss = object_mask * K.binary_crossentropy(object_mask, raw_pred[...,<span class="number">4</span>:<span class="number">5</span>], from_logits=<span class="literal">True</span>)+ \</span><br><span class="line">            (<span class="number">1</span>-object_mask) * K.binary_crossentropy(object_mask, raw_pred[...,<span class="number">4</span>:<span class="number">5</span>], from_logits=<span class="literal">True</span>) * ignore_mask</span><br><span class="line">        class_loss = object_mask * K.binary_crossentropy(true_class_probs, raw_pred[...,<span class="number">5</span>:], from_logits=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        xy_loss = K.sum(xy_loss) / mf</span><br><span class="line">        wh_loss = K.sum(wh_loss) / mf</span><br><span class="line">        confidence_loss = K.sum(confidence_loss) / mf</span><br><span class="line">        class_loss = K.sum(class_loss) / mf</span><br><span class="line">        loss += xy_loss + wh_loss + confidence_loss + class_loss</span><br><span class="line">        <span class="keyword">if</span> print_loss:</span><br><span class="line">            loss = tf.Print(loss, [loss, xy_loss, wh_loss, confidence_loss, class_loss, K.sum(ignore_mask)], message=<span class="string">'loss: '</span>)</span><br><span class="line">    <span class="keyword">return</span> loss</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><p><strong>args</strong> ：包含<code>(yolo_outputs,y_true)</code> ，<code>yolo_outputs</code> 指 YOLO3 模型输出的 y1，y2，y3，这里的输出是含有批维度的，且其第一维度为批维度。<code>y_true</code> 是经过<code>preprocess_true_boxes</code>函数预处理的真实框信息：</p><ul><li><code>yolo_outputs</code> 是三元素列表，其中元素分别为<code>[m批13*13特征图张量,m批26*26特征图张量,m批52*52特征图张量]</code>，每张特征图的深度都为<code>图内锚框数*(5+类别数)</code>，所以列表内每个元素的 <code>shape=(批数,特征图宽,特征图高,图内锚框数*(5+类别数))</code></li><li><p><code>y_true</code>  是三元素列表，列表内是 np 数组，每个 np 数组对于不同尺寸的特征图，它的形状为 <code>shape=(批数,特征图宽,特征图高,图内锚框数,5+类别数)</code>，每个特征图的尺寸为 <code>13*13、26*26、52*52</code></p><blockquote><p>关于 <code>yolo_outputs</code>  和  <code>y_true</code>  的形状分析可参考前几篇博文</p></blockquote></li></ul></li><li><p><strong>anchors</strong> : 锚框二维数组，结构如<code>[[w1,h1],[w2,h2]..]</code></p></li><li><p><strong>num_classes</strong> ：整型，类别数</p></li><li><p><strong>ignore_thresh</strong> ：浮点型，IOU 小于这个值的将被忽略。</p></li></ul><p>返回：</p><ul><li>一维向量，loss值。</li></ul><p>执行过程</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_layers = len(anchors)//<span class="number">3</span> <span class="comment"># default setting</span></span><br><span class="line">yolo_outputs = args[:num_layers]</span><br><span class="line">y_true = args[num_layers:]</span><br><span class="line">anchor_mask = [[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]] <span class="keyword">if</span> num_layers==<span class="number">3</span> <span class="keyword">else</span> [[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">input_shape = K.cast(K.shape(yolo_outputs[<span class="number">0</span>])[<span class="number">1</span>:<span class="number">3</span>] * <span class="number">32</span>, K.dtype(y_true[<span class="number">0</span>]))</span><br><span class="line">grid_shapes = [K.cast(K.shape(yolo_outputs[l])[<span class="number">1</span>:<span class="number">3</span>], K.dtype(y_true[<span class="number">0</span>])) <span class="keyword">for</span> l <span class="keyword">in</span> range(num_layers)]</span><br><span class="line">loss = <span class="number">0</span></span><br><span class="line">m = K.shape(yolo_outputs[<span class="number">0</span>])[<span class="number">0</span>] <span class="comment"># batch size, tensor</span></span><br><span class="line">mf = K.cast(m, K.dtype(yolo_outputs[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure><ul><li>获取输出特征图数目 <code>num_layers</code> ，YOLO3 输出 3 张特征图，每张特征图内有 3 个锚框，而tiny-yolo3 则输出两张，故可以根据 <code>len(anchors)</code> 来计算输出特征图数目，<strong>以下假设输出特征图数目为 3</strong></li><li>通过 <code>num_layers</code>  对参数 <code>args</code> 进行分割，得到 <code>yolo_outputs</code> 和 <code>y_true</code></li><li>定义锚框掩码 <code>anchor_mask</code> , 锚框掩码用于给每个输出特征图分配锚框。</li><li>第一个输出特征图的尺寸为 <code>K.shape(yolo_outputs[0])[1:3]</code>，由第一个输出特征图的尺寸*32，可知原图尺寸 <code>input_shape</code></li><li>由每个输出特征图的尺寸 <code>K.shape(yolo_outputs[0])[1:3]</code> 可求每个特征图内的网格信息 <code>grid_shapes</code> 。</li><li>求批大小<code>m</code> ，并将批大小<code>m</code> 转化成 tf.Tensor 类型，记为 <code>mf</code></li></ul><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> <span class="keyword">range</span>(num_layers):</span><br></pre></td></tr></table></figure><ul><li>之后是对每张输出特征图的操作，以下假设操作第 <code>l</code> 号特征图</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">object_mask = y_true[l][..., <span class="number">4</span>:<span class="number">5</span>]</span><br><span class="line">true_class_probs = y_true[l][..., <span class="number">5</span>:]</span><br><span class="line"></span><br><span class="line">grid, raw_pred, pred_xy, pred_wh = yolo_head(yolo_outputs[l],</span><br><span class="line">anchors[anchor_mask[l]], num_classes, input_shape, calc_loss=<span class="literal">True</span>)</span><br><span class="line">pred_box = K.concatenate([pred_xy, pred_wh])</span><br></pre></td></tr></table></figure><ul><li>从 <code>y_true</code> 里获得物体掩码 <code>object_mask</code> 和类别概率 <code>true_class_probs</code></li><li>为了由 <code>l</code> 号特征图的信息提取得到预测框相关信息，调用 <code>yolo_head(yolo_outputs[l], anchors[anchor_mask[l]], num_classes, input_shape, calc_loss=True)</code>，并将其返回值记为 <code>grid, raw_pred, pred_xy, pred_wh</code>，分别表示：网格坐标、原始特征图信息、预测框的中心点比例信息（相对于原图的比例）、预测框的大小比例信息（相对于锚框的比例）</li><li>计算预测框信息 <code>pred_box</code> ，它的值就是合并预测的位置信息和预测的大小信息 <code>pred_box = K.concatenate([pred_xy, pred_wh])</code></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Darknet raw box to calculate loss.</span></span><br><span class="line">raw_true_xy = y_true[l][..., :<span class="number">2</span>]*grid_shapes[l][::<span class="number">-1</span>] - grid</span><br><span class="line">raw_true_wh = K.log(y_true[l][..., <span class="number">2</span>:<span class="number">4</span>] / anchors[anchor_mask[l]] * input_shape[::<span class="number">-1</span>])</span><br><span class="line">raw_true_wh = K.switch(object_mask, raw_true_wh, K.zeros_like(raw_true_wh)) <span class="comment"># avoid log(0)=-inf</span></span><br><span class="line">box_loss_scale = <span class="number">2</span> - y_true[l][...,<span class="number">2</span>:<span class="number">3</span>]*y_true[l][...,<span class="number">3</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure><ul><li>对真实盒子信息进行处理，按逆运算，从 <code>l</code> 号特征图的真是信息 <code>y_true[l]</code> 中求出真实框的中心点比例信息 <code>raw_true_xy</code> 和真实框大小比例信息  <code>raw_true_wh</code> </li><li>利用 <code>K.switch</code> ，通过 <code>object_mask</code> 对 <code>raw_true_wh</code>  进行修正，<code>raw_true_wh</code>  中含有物体的网格包含真实框的大小比例信息，不包含物体的网格大小为 0</li><li>定义修正比例 <code>box_loss_scale</code> 这个比例被赋值为 <code>2-w*h</code> ，最终要乘到坐标和大小的误差项中，意味着 loss 函数对小物体的误差比大物体的误差更敏感。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Find ignore mask, iterate over each of batch.</span></span><br><span class="line">ignore_mask = tf.TensorArray(K.dtype(y_true[<span class="number">0</span>]), size=<span class="number">1</span>, dynamic_size=<span class="literal">True</span>)</span><br><span class="line">object_mask_bool = K.cast(object_mask, <span class="string">'bool'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_body</span><span class="params">(b, ignore_mask)</span>:</span></span><br><span class="line">true_box = tf.boolean_mask(y_true[l][b,...,<span class="number">0</span>:<span class="number">4</span>], object_mask_bool[b,...,<span class="number">0</span>])</span><br><span class="line">iou = box_iou(pred_box[b], true_box)</span><br><span class="line">best_iou = K.max(iou, axis=<span class="number">-1</span>)</span><br><span class="line">ignore_mask = ignore_mask.write(b, K.cast(best_iou&lt;ignore_thresh, K.dtype(true_box)))</span><br><span class="line"><span class="keyword">return</span> b+<span class="number">1</span>, ignore_mask</span><br><span class="line">_, ignore_mask = K.control_flow_ops.while_loop(<span class="keyword">lambda</span> b,*args: b&lt;m, loop_body, [<span class="number">0</span>, ignore_mask])</span><br><span class="line">ignore_mask = ignore_mask.stack()</span><br><span class="line">ignore_mask = K.expand_dims(ignore_mask, <span class="number">-1</span>)</span><br></pre></td></tr></table></figure><ul><li>定义 <code>ignore_mask</code> ，它的形状与 <code>pred_box</code> 只有最后一个维度不同，<code>ignore_mask</code> 的最后一维为 1，通过 tf 的静态图控制语句，动态定义一个掩码张量，用每批预测框张量与 <code>l</code> 层特征图中的每批真实框张量进行 IOU 运算，如果一个预测框存在一个与 IOU 大于参数<code>ignore_thresh</code> 的真是框，就在这个 <code>ignore_mask</code>  中把这个预测框对应位置的元素置值为 1 ，将无效预测框过滤掉。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># K.binary_crossentropy is helpful to avoid exp overflow.</span></span><br><span class="line">xy_loss = object_mask * box_loss_scale * K.binary_crossentropy(raw_true_xy, raw_pred[...,<span class="number">0</span>:<span class="number">2</span>], from_logits=<span class="literal">True</span>)</span><br><span class="line">wh_loss = object_mask * box_loss_scale * <span class="number">0.5</span> * K.square(raw_true_wh-raw_pred[...,<span class="number">2</span>:<span class="number">4</span>])</span><br><span class="line">confidence_loss = object_mask * K.binary_crossentropy(object_mask, raw_pred[...,<span class="number">4</span>:<span class="number">5</span>], from_logits=<span class="literal">True</span>)+ \</span><br><span class="line">(<span class="number">1</span>-object_mask) * K.binary_crossentropy(object_mask, raw_pred[...,<span class="number">4</span>:<span class="number">5</span>], from_logits=<span class="literal">True</span>) * ignore_mask</span><br><span class="line">class_loss = object_mask * K.binary_crossentropy(true_class_probs, raw_pred[...,<span class="number">5</span>:], from_logits=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><ul><li>按照损失函数计算  <code>xy_loss</code> 、<code>wh_loss</code>、<code>confidence_loss</code> 、<code>class_loss</code></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xy_loss = K.sum(xy_loss) / mf</span><br><span class="line">wh_loss = K.sum(wh_loss) / mf</span><br><span class="line">confidence_loss = K.sum(confidence_loss) / mf</span><br><span class="line">class_loss = K.sum(class_loss) / mf</span><br><span class="line">loss += xy_loss + wh_loss + confidence_loss + class_loss</span><br></pre></td></tr></table></figure><ul><li>将 <code>l</code> 号特征图的各 loss 项求和并除批大小，最终化为标量，随后将各标量加和到 <code>loss</code></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> loss</span><br></pre></td></tr></table></figure><ul><li>处理好所有特征图后，返回 <code>loss</code> ，<code>loss.shape=(1,)</code></li></ul><h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><h4 id="基础函数-1"><a href="#基础函数-1" class="headerlink" title="基础函数"></a>基础函数</h4><h5 id="get-classes"><a href="#get-classes" class="headerlink" title="get_classes"></a><code>get_classes</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_classes</span><span class="params">(classes_path)</span>:</span></span><br><span class="line">    <span class="string">'''loads the classes'''</span></span><br><span class="line">    <span class="keyword">with</span> open(classes_path) <span class="keyword">as</span> f:</span><br><span class="line">        class_names = f.readlines()</span><br><span class="line">    class_names = [c.strip() <span class="keyword">for</span> c <span class="keyword">in</span> class_names]</span><br><span class="line">    <span class="keyword">return</span> class_names</span><br></pre></td></tr></table></figure><ul><li>从 classes_path 中按行读取类别，构建类别列表并返回</li></ul><h5 id="get-anchors"><a href="#get-anchors" class="headerlink" title="get_anchors"></a><code>get_anchors</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_anchors</span><span class="params">(anchors_path)</span>:</span></span><br><span class="line">    <span class="string">'''loads the anchors from a file'''</span></span><br><span class="line">    <span class="keyword">with</span> open(anchors_path) <span class="keyword">as</span> f:</span><br><span class="line">        anchors = f.readline()</span><br><span class="line">    anchors = [float(x) <span class="keyword">for</span> x <span class="keyword">in</span> anchors.split(<span class="string">','</span>)]</span><br><span class="line">    <span class="keyword">return</span> np.array(anchors).reshape(<span class="number">-1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li>从 anchors_path 按行读取锚框信息，构建锚框列表并返回</li></ul><h5 id="create-model"><a href="#create-model" class="headerlink" title="create_model()"></a><code>create_model()</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_model</span><span class="params">(input_shape, anchors, num_classes, load_pretrained=True, freeze_body=<span class="number">2</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            weights_path=<span class="string">'model_data/yolo_weights.h5'</span>)</span>:</span></span><br><span class="line">    <span class="string">'''create the training model'''</span></span><br><span class="line">    K.clear_session() <span class="comment"># get a new session</span></span><br><span class="line">    image_input = Input(shape=(<span class="literal">None</span>, <span class="literal">None</span>, <span class="number">3</span>))</span><br><span class="line">    h, w = input_shape</span><br><span class="line">    num_anchors = len(anchors)</span><br><span class="line"></span><br><span class="line">    y_true = [Input(shape=(h//&#123;<span class="number">0</span>:<span class="number">32</span>, <span class="number">1</span>:<span class="number">16</span>, <span class="number">2</span>:<span class="number">8</span>&#125;[l], w//&#123;<span class="number">0</span>:<span class="number">32</span>, <span class="number">1</span>:<span class="number">16</span>, <span class="number">2</span>:<span class="number">8</span>&#125;[l], \</span><br><span class="line">        num_anchors//<span class="number">3</span>, num_classes+<span class="number">5</span>)) <span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line">    model_body = yolo_body(image_input, num_anchors//<span class="number">3</span>, num_classes)</span><br><span class="line">    print(<span class="string">'Create YOLOv3 model with &#123;&#125; anchors and &#123;&#125; classes.'</span>.format(num_anchors, num_classes))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> load_pretrained:</span><br><span class="line">        model_body.load_weights(weights_path, by_name=<span class="literal">True</span>, skip_mismatch=<span class="literal">True</span>)</span><br><span class="line">        print(<span class="string">'Load weights &#123;&#125;.'</span>.format(weights_path))</span><br><span class="line">        <span class="keyword">if</span> freeze_body <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>]:</span><br><span class="line">            <span class="comment"># Freeze darknet53 body or freeze all but 3 output layers.</span></span><br><span class="line">            num = (<span class="number">185</span>, len(model_body.layers)<span class="number">-3</span>)[freeze_body<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(num): model_body.layers[i].trainable = <span class="literal">False</span></span><br><span class="line">            print(<span class="string">'Freeze the first &#123;&#125; layers of total &#123;&#125; layers.'</span>.format(num, len(model_body.layers)))</span><br><span class="line"></span><br><span class="line">    model_loss = Lambda(yolo_loss, output_shape=(<span class="number">1</span>,), name=<span class="string">'yolo_loss'</span>,</span><br><span class="line">        arguments=&#123;<span class="string">'anchors'</span>: anchors, <span class="string">'num_classes'</span>: num_classes, <span class="string">'ignore_thresh'</span>: <span class="number">0.5</span>&#125;)(</span><br><span class="line">        [*model_body.output, *y_true])</span><br><span class="line">    model = Model([model_body.input, *y_true], model_loss)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>input_shape</code> : 二维列表或张量，输入图片的尺寸，高在前，宽在后</li><li><code>anchors</code> : 锚框信息列表，结构类似 <code>[[w1,h1]...]</code></li><li><code>num_classes</code> ：整型，类别数目</li><li><code>load_pretrained</code> ：是否加载预训练的权重，默认是 <code>True</code></li><li><code>freeze_body</code>：设置冻结那些层</li><li><code>weights_path</code>：预训练权重的存储路径</li></ul><p>分段讲解：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">K.clear_session() <span class="comment"># get a new session</span></span><br><span class="line">image_input = Input(shape=(<span class="literal">None</span>, <span class="literal">None</span>, <span class="number">3</span>))</span><br><span class="line">h, w = input_shape</span><br><span class="line">num_anchors = len(anchors)</span><br></pre></td></tr></table></figure><ul><li>创建 Input 类型张量作为静态图的输入结点，从 <code>input_shape</code> 中分离高 <code>h</code> 和宽 <code>w</code>，获取锚框数目 <code>num_anchors</code></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y_true = [Input(shape=(h//&#123;<span class="number">0</span>:<span class="number">32</span>, <span class="number">1</span>:<span class="number">16</span>, <span class="number">2</span>:<span class="number">8</span>&#125;[l], w//&#123;<span class="number">0</span>:<span class="number">32</span>, <span class="number">1</span>:<span class="number">16</span>, <span class="number">2</span>:<span class="number">8</span>&#125;[l], \</span><br><span class="line">        num_anchors//<span class="number">3</span>, num_classes+<span class="number">5</span>)) <span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br></pre></td></tr></table></figure><ul><li>构建 <code>y_true</code> ，<code>y_true</code> 是一个拥有三个 Input 张量的列表，三个 Input 张量的尺寸分别为 <code>原图长宽/32,原图窗口/16,原图长宽/8</code>，每个 Input 张量的通道数都是 <code>类别数+5</code></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model_body = yolo_body(image_input, num_anchors//<span class="number">3</span>, num_classes)</span><br><span class="line">print(<span class="string">'Create YOLOv3 model with &#123;&#125; anchors and &#123;&#125; classes.'</span>.format(num_anchors, num_classes))</span><br></pre></td></tr></table></figure><ul><li>构建 yolo 网络，记为<code>model_body</code>，通过 <code>yolo_body</code></li><li><code>yolo_body</code> 是一个定义在 <code>model.py</code> 的函数，里面定义了 输入结点里的数据在静态图中的流转过程。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> load_pretrained:</span><br><span class="line">    model_body.load_weights(weights_path, by_name=<span class="literal">True</span>, skip_mismatch=<span class="literal">True</span>)</span><br><span class="line">    print(<span class="string">'Load weights &#123;&#125;.'</span>.format(weights_path))</span><br><span class="line">    <span class="keyword">if</span> freeze_body <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>]:</span><br><span class="line">        <span class="comment"># Freeze darknet53 body or freeze all but 3 output layers.</span></span><br><span class="line">        num = (<span class="number">185</span>, len(model_body.layers)<span class="number">-3</span>)[freeze_body<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(num): model_body.layers[i].trainable = <span class="literal">False</span></span><br><span class="line">        print(<span class="string">'Freeze the first &#123;&#125; layers of total &#123;&#125; layers.'</span>.format(num, len(model_body.layers)))</span><br></pre></td></tr></table></figure><ul><li>根据参数 <code>load_pretrained</code>  判断是否需要加载预训练权重</li><li>如果需要加载预训练权重，则从预训练权重路径加载权重，并忽略不匹配的层</li><li>计算总共需要冻结的层 <code>num</code> ，<code>load_pretrained=1</code> 则冻结 darknet53，如果<code>load_pretrained=2</code> 就除了倒数三层（三个用于输出的层）其余层都冻结。</li><li>把 0 到 <code>num</code> 层全冻结。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model_loss = Lambda(yolo_loss, output_shape=(<span class="number">1</span>,), name=<span class="string">'yolo_loss'</span>,</span><br><span class="line">    arguments=&#123;<span class="string">'anchors'</span>: anchors, <span class="string">'num_classes'</span>: num_classes, <span class="string">'ignore_thresh'</span>: <span class="number">0.5</span>&#125;)(</span><br><span class="line">    [*model_body.output, *y_true])</span><br><span class="line">model = Model([model_body.input, *y_true], model_loss)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> model</span><br></pre></td></tr></table></figure><ul><li><p>使用 <code>keras.layers.Lambda</code> 自定义一个层，这个层使用的是 <code>yolo_loss</code> 函数，层的输出形状是 <code>(1,)</code>，名称为 yolo_loss，输入的参数是 <code>{&#39;anchors&#39;: anchors, &#39;num_classes&#39;: num_classes, &#39;ignore_thresh&#39;: 0.5}</code></p><blockquote><p>使用 <code>Lambda</code>  可以将一个函数转化为层对象，使之可以被添加进模型之中，要求函数的第一个参数是输的入张量，其余参数可以通过 <code>arguments</code> 以字典的形式传入</p></blockquote></li><li><p>将 <code>[*model_body.output, *y_true]</code> 作为输入的张量，输入到 <code>Lambda</code> 定义的层的，将其返回的张量定义为 <code>model_loss</code> ，该过程另静态图中衔接了新的结构，训练时从输入结点输入的数据将会先通过 <code>model_body</code> 静态图，再通过 <code>Lambda</code> 定义的静态图，最后输送到输出结点</p></li><li>使用 <code>keras.models.Model</code> 将 <code>[model_body.input, *y_true]</code> 作为输入结点，将 <code>model_loss</code> 作为输出结点，构建静态图，并返回模型。</li></ul><blockquote><p><code>create_model()</code> 创建的并非是 YOLO3 网络本身，而是 YOLO3 网络，加上 loss 函数层，在定义 loss 函数时，只需要将最后一层的输出作为最终loss值即可，也就是说，loss 函数的运算部分作为模型的最后层被 <code>create_model()</code>  所创建。</p></blockquote><h4 id="实现函数-1"><a href="#实现函数-1" class="headerlink" title="实现函数"></a>实现函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_main</span><span class="params">()</span>:</span></span><br><span class="line">    annotation_path = <span class="string">'train.txt'</span></span><br><span class="line">    log_dir = <span class="string">'logs/000/'</span></span><br><span class="line">    classes_path = <span class="string">'model_data/voc_classes.txt'</span></span><br><span class="line">    anchors_path = <span class="string">'model_data/yolo_anchors.txt'</span></span><br><span class="line">    class_names = get_classes(classes_path)</span><br><span class="line">    num_classes = len(class_names)</span><br><span class="line">    anchors = get_anchors(anchors_path)</span><br><span class="line"></span><br><span class="line">    input_shape = (<span class="number">416</span>,<span class="number">416</span>) <span class="comment"># multiple of 32, hw</span></span><br><span class="line"></span><br><span class="line">    is_tiny_version = len(anchors)==<span class="number">6</span> <span class="comment"># default setting</span></span><br><span class="line">    <span class="keyword">if</span> is_tiny_version:</span><br><span class="line">        model = create_tiny_model(input_shape, anchors, num_classes,</span><br><span class="line">            freeze_body=<span class="number">2</span>, weights_path=<span class="string">'model_data/tiny_yolo_weights.h5'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        model = create_model(input_shape, anchors, num_classes,</span><br><span class="line">            freeze_body=<span class="number">2</span>, weights_path=<span class="string">'model_data/yolo_weights.h5'</span>) <span class="comment"># make sure you know what you freeze</span></span><br><span class="line"></span><br><span class="line">    logging = TensorBoard(log_dir=log_dir)</span><br><span class="line">    checkpoint = ModelCheckpoint(log_dir + <span class="string">'ep&#123;epoch:03d&#125;-loss&#123;loss:.3f&#125;-val_loss&#123;val_loss:.3f&#125;.h5'</span>,</span><br><span class="line">        monitor=<span class="string">'val_loss'</span>, save_weights_only=<span class="literal">True</span>, save_best_only=<span class="literal">True</span>, period=<span class="number">3</span>)</span><br><span class="line">    reduce_lr = ReduceLROnPlateau(monitor=<span class="string">'val_loss'</span>, factor=<span class="number">0.1</span>, patience=<span class="number">3</span>, verbose=<span class="number">1</span>)</span><br><span class="line">    early_stopping = EarlyStopping(monitor=<span class="string">'val_loss'</span>, min_delta=<span class="number">0</span>, patience=<span class="number">10</span>, verbose=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    val_split = <span class="number">0.1</span></span><br><span class="line">    <span class="keyword">with</span> open(annotation_path) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line">    np.random.seed(<span class="number">10101</span>)</span><br><span class="line">    np.random.shuffle(lines)</span><br><span class="line">    np.random.seed(<span class="literal">None</span>)</span><br><span class="line">    num_val = int(len(lines)*val_split)</span><br><span class="line">    num_train = len(lines) - num_val</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Train with frozen layers first, to get a stable loss.</span></span><br><span class="line">    <span class="comment"># Adjust num epochs to your dataset. This step is enough to obtain a not bad model.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">        model.compile(optimizer=Adam(lr=<span class="number">1e-3</span>), loss=&#123;</span><br><span class="line">            <span class="comment"># use custom yolo_loss Lambda layer.</span></span><br><span class="line">            <span class="string">'yolo_loss'</span>: <span class="keyword">lambda</span> y_true, y_pred: y_pred&#125;)</span><br><span class="line"></span><br><span class="line">        batch_size = <span class="number">32</span></span><br><span class="line">        print(<span class="string">'Train on &#123;&#125; samples, val on &#123;&#125; samples, with batch size &#123;&#125;.'</span>.format(num_train, num_val, batch_size))</span><br><span class="line">        model.fit_generator(data_generator_wrapper(lines[:num_train], batch_size, input_shape, anchors, num_classes),</span><br><span class="line">                steps_per_epoch=max(<span class="number">1</span>, num_train//batch_size),</span><br><span class="line">                validation_data=data_generator_wrapper(lines[num_train:], batch_size, input_shape, anchors, num_classes),</span><br><span class="line">                validation_steps=max(<span class="number">1</span>, num_val//batch_size),</span><br><span class="line">                epochs=<span class="number">50</span>,</span><br><span class="line">                initial_epoch=<span class="number">0</span>,</span><br><span class="line">                callbacks=[logging, checkpoint])</span><br><span class="line">        model.save_weights(log_dir + <span class="string">'trained_weights_stage_1.h5'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Unfreeze and continue training, to fine-tune.</span></span><br><span class="line">    <span class="comment"># Train longer if the result is not good.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(model.layers)):</span><br><span class="line">            model.layers[i].trainable = <span class="literal">True</span></span><br><span class="line">        model.compile(optimizer=Adam(lr=<span class="number">1e-4</span>), loss=&#123;<span class="string">'yolo_loss'</span>: <span class="keyword">lambda</span> y_true, y_pred: y_pred&#125;) <span class="comment"># recompile to apply the change</span></span><br><span class="line">        print(<span class="string">'Unfreeze all of the layers.'</span>)</span><br><span class="line"></span><br><span class="line">        batch_size = <span class="number">32</span> <span class="comment"># note that more GPU memory is required after unfreezing the body</span></span><br><span class="line">        print(<span class="string">'Train on &#123;&#125; samples, val on &#123;&#125; samples, with batch size &#123;&#125;.'</span>.format(num_train, num_val, batch_size))</span><br><span class="line">        model.fit_generator(data_generator_wrapper(lines[:num_train], batch_size, input_shape, anchors, num_classes),</span><br><span class="line">            steps_per_epoch=max(<span class="number">1</span>, num_train//batch_size),</span><br><span class="line">            validation_data=data_generator_wrapper(lines[num_train:], batch_size, input_shape, anchors, num_classes),</span><br><span class="line">            validation_steps=max(<span class="number">1</span>, num_val//batch_size),</span><br><span class="line">            epochs=<span class="number">100</span>,</span><br><span class="line">            initial_epoch=<span class="number">50</span>,</span><br><span class="line">            callbacks=[logging, checkpoint, reduce_lr, early_stopping])</span><br><span class="line">        model.save_weights(log_dir + <span class="string">'trained_weights_final.h5'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Further training if needed.</span></span><br></pre></td></tr></table></figure><p>分段讲解：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">annotation_path = <span class="string">'train.txt'</span></span><br><span class="line">log_dir = <span class="string">'logs/000/'</span></span><br><span class="line">classes_path = <span class="string">'model_data/voc_classes.txt'</span></span><br><span class="line">anchors_path = <span class="string">'model_data/yolo_anchors.txt'</span></span><br></pre></td></tr></table></figure><ul><li>配置相关文件路径，<code>annotation_path</code> 是由 voc_annotation.py 生成的 YOLO3 格式的批注文件的路径, <code>log_dir</code> 用于保存 TensorBoard 和 checkpoint;<code>classes_path</code> 是 YOLO3 类别文件路径; <code>anchors_path</code> 是 YOLO3 锚框(预设框)文件路径</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">class_names = get_classes(classes_path)</span><br><span class="line">num_classes = len(class_names)</span><br><span class="line">anchors = get_anchors(anchors_path)</span><br><span class="line"></span><br><span class="line">input_shape = (<span class="number">416</span>,<span class="number">416</span>) <span class="comment"># multiple of 32, hw</span></span><br><span class="line"></span><br><span class="line">is_tiny_version = len(anchors)==<span class="number">6</span> <span class="comment"># default setting</span></span><br></pre></td></tr></table></figure><ul><li>定义相关变量，<code>class_names</code> 是由 <code>get_classes(classes_path)</code> 生成的类别名数组; <code>num_classes</code> 是类别数据中的类别的数目; <code>anchors</code> 是由 <code>get_anchors(anchors_path)</code> 生成的锚框坐标大小信息数组; <code>input_shape</code> 定义输入图像的尺寸，高在前宽在后。<code>is_tiny_version</code> 通过判断锚框数目断定是否是 tiny yolo。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> is_tiny_version:</span><br><span class="line">    model = create_tiny_model(input_shape, anchors, num_classes,</span><br><span class="line">        freeze_body=<span class="number">2</span>, weights_path=<span class="string">'model_data/tiny_yolo_weights.h5'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    model = create_model(input_shape, anchors, num_classes,</span><br><span class="line">        freeze_body=<span class="number">2</span>, weights_path=<span class="string">'model_data/yolo_weights.h5'</span>) <span class="comment"># make sure you know what you freeze</span></span><br></pre></td></tr></table></figure><ul><li>根据 <code>is_tiny_version</code> 变量判断使用的网络版本,不同版本通过不同函数创建网络,如 yolo3 网络通过 <code>create_model()</code> 创建.</li><li>使用 <code>create_model()</code> 创建模型的时候，通过参数设计冻结两层，并设置好预训练权重路径 </li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">logging = TensorBoard(log_dir=log_dir)</span><br><span class="line">checkpoint = ModelCheckpoint(log_dir + <span class="string">'ep&#123;epoch:03d&#125;-loss&#123;loss:.3f&#125;-val_loss&#123;val_loss:.3f&#125;.h5'</span>,</span><br><span class="line">    monitor=<span class="string">'val_loss'</span>, save_weights_only=<span class="literal">True</span>, save_best_only=<span class="literal">True</span>, period=<span class="number">3</span>)</span><br><span class="line">reduce_lr = ReduceLROnPlateau(monitor=<span class="string">'val_loss'</span>, factor=<span class="number">0.1</span>, patience=<span class="number">3</span>, verbose=<span class="number">1</span>)</span><br><span class="line">early_stopping = EarlyStopping(monitor=<span class="string">'val_loss'</span>, min_delta=<span class="number">0</span>, patience=<span class="number">10</span>, verbose=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li>设置 TensorBoard 回调，用于保存训练过程中的信息，进行可视化，实例名记为 <code>logging</code></li><li>设置 ModelCheckpoint 回调函数，用于保存训练过程的权重，参数解读：保存权重的路径为 <code>log_dir</code> ，文件名格式为<code>ep{epoch:03d}-loss{loss:.3f}-val_loss{val_loss:.3f}.h5</code> ，监视的目标是在测试集的loss值 <code>val_loss</code> ，只保存权重不保存模型结构，只保存结果好与已有结果的权重，每 3 轮保存一次。记实例名为 <code>checkpoint</code></li><li>设置 ReduceLROnPlateau 回调，当 loss 不再下降的时候，按照一定因数下调学习率，继续训练。根据参数解读：监视的 loss 为训练集上的 loss 值 <code>val_loss</code> ,每次调整学习率的因数为 0.1，根据公式 <code>new_lr = lr * factor</code> 可知，每次将学习率缩小十倍，如果 <code>val_loss</code> 连续 3 轮没有下降，则降低学习率，日志模式为 1。记实例名为 <code>reduce_lr</code>。</li><li>设置 EarlyStopping 回调，当 loss 值不再下降时，提前停止训练，参数解读：监视目标为 <code>val_loss</code> ，最小下降值为 0，如果连续 10 论没有下降则早停，日志模型为 1。记实例名为 <code>early_stopping</code></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">val_split = <span class="number">0.1</span></span><br><span class="line"><span class="keyword">with</span> open(annotation_path) <span class="keyword">as</span> f:</span><br><span class="line">    lines = f.readlines()</span><br><span class="line">np.random.seed(<span class="number">10101</span>)</span><br><span class="line">np.random.shuffle(lines)</span><br><span class="line">np.random.seed(<span class="literal">None</span>)</span><br><span class="line">num_val = int(len(lines)*val_split)</span><br><span class="line">num_train = len(lines) - num_val</span><br></pre></td></tr></table></figure><ul><li>给定测试集划分比例为 0.1 ，总载入样本的 <code>val_split</code> 部分将会作为测试集，不参与训练。 </li><li>将 <code>annotation_path</code> 中的信息读入到 <code>lines</code> 列表中</li><li>对 <code>lines</code> 按照 <code>val_split</code> 进行划分，将测试数目记为 <code>num_val</code>, 训练集数目记为 <code>num_train</code></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Train with frozen layers first, to get a stable loss.</span></span><br><span class="line"><span class="comment"># Adjust num epochs to your dataset. This step is enough to obtain a not bad model.</span></span><br><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    model.compile(optimizer=Adam(lr=<span class="number">1e-3</span>), loss=&#123;</span><br><span class="line">        <span class="comment"># use custom yolo_loss Lambda layer.</span></span><br><span class="line">        <span class="string">'yolo_loss'</span>: <span class="keyword">lambda</span> y_true, y_pred: y_pred&#125;)</span><br><span class="line"></span><br><span class="line">    batch_size = <span class="number">32</span></span><br><span class="line">    print(<span class="string">'Train on &#123;&#125; samples, val on &#123;&#125; samples, with batch size &#123;&#125;.'</span>.format(num_train, num_val, batch_size))</span><br><span class="line">    model.fit_generator(data_generator_wrapper(lines[:num_train], batch_size, input_shape, anchors, num_classes),</span><br><span class="line">            steps_per_epoch=max(<span class="number">1</span>, num_train//batch_size),</span><br><span class="line">            validation_data=data_generator_wrapper(lines[num_train:], batch_size, input_shape, anchors, num_classes),</span><br><span class="line">            validation_steps=max(<span class="number">1</span>, num_val//batch_size),</span><br><span class="line">            epochs=<span class="number">50</span>,</span><br><span class="line">            initial_epoch=<span class="number">0</span>,</span><br><span class="line">            callbacks=[logging, checkpoint])</span><br><span class="line">    model.save_weights(log_dir + <span class="string">'trained_weights_stage_1.h5'</span>)</span><br></pre></td></tr></table></figure><ul><li><p>进行第一阶段训练,该阶段会冻结主干网络的权重(已经已经预加载了一些),通过调整部分权重使模型快速的 loss 快速下降到一个可接受的值。</p></li><li><p>编译模型，使用 <code>Adam</code> 优化器，名为 <code>yolo_loss</code>  的输出经过函数 <code>lambda y_true, y_pred: y_pred</code> 得到 loss 值</p><blockquote><p>这里的 loss 函数把模型最后一层的输出作为 loss 值，原因是 <code>create_model()</code> 把 loss 函数的运算部分定义在了模型的最后一层</p></blockquote></li><li><p>批大小设置为 32</p></li><li><p>训练数据，通过 <code>data_generator_wrapper()</code> 生成器生成训练数据，用 <code>data_generator_wrapper</code> 生成验证数据，使用 <code>logging</code> 和 <code>checkpoint</code> 作为回调对象</p></li><li><p>将训练好的权重保存起来</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(model.layers)):</span><br><span class="line">        model.layers[i].trainable = <span class="literal">True</span></span><br><span class="line">    model.compile(optimizer=Adam(lr=<span class="number">1e-4</span>), loss=&#123;<span class="string">'yolo_loss'</span>: <span class="keyword">lambda</span> y_true, y_pred: y_pred&#125;) <span class="comment"># recompile to apply the change</span></span><br><span class="line">    print(<span class="string">'Unfreeze all of the layers.'</span>)</span><br><span class="line"></span><br><span class="line">    batch_size = <span class="number">32</span> <span class="comment"># note that more GPU memory is required after unfreezing the body</span></span><br><span class="line">    print(<span class="string">'Train on &#123;&#125; samples, val on &#123;&#125; samples, with batch size &#123;&#125;.'</span>.format(num_train, num_val, batch_size))</span><br><span class="line">    model.fit_generator(data_generator_wrapper(lines[:num_train], batch_size, input_shape, anchors, num_classes),</span><br><span class="line">        steps_per_epoch=max(<span class="number">1</span>, num_train//batch_size),</span><br><span class="line">        validation_data=data_generator_wrapper(lines[num_train:], batch_size, input_shape, anchors, num_classes),</span><br><span class="line">        validation_steps=max(<span class="number">1</span>, num_val//batch_size),</span><br><span class="line">        epochs=<span class="number">100</span>,</span><br><span class="line">        initial_epoch=<span class="number">50</span>,</span><br><span class="line">        callbacks=[logging, checkpoint, reduce_lr, early_stopping])</span><br><span class="line">    model.save_weights(log_dir + <span class="string">'trained_weights_final.h5'</span>)</span><br></pre></td></tr></table></figure><ul><li>第二阶段训练，这个阶段将会解冻所有层，在第一阶段训练的基础上进行微调。</li><li>用 <code>for</code> 解冻所有层</li><li>编译模型，与第一阶段相同</li><li>批大小为 32</li><li>训练模型，数据载入与第一阶段相同，使用 <code>logging,checkpoint,reduce_lr,early_stopping</code> 作为回调</li><li>保存最终模型</li></ul>]]></content>
      
      
      <categories>
          
          <category> YOLO3 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> YOLO3 </tag>
            
            <tag> Keras </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YOLO3 网络结构 Keras源码分析</title>
      <link href="/2020/04/04/YOLO3%20%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2020/04/04/YOLO3%20%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>YOLO3 Keras 源码：<a href="https://github.com/qqwweee/keras-yolo3" target="_blank" rel="noopener">https://github.com/qqwweee/keras-yolo3</a></p><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><h3 id="网络结构图"><a href="#网络结构图" class="headerlink" title="网络结构图"></a>网络结构图</h3><p><img src="/2020/04/04/YOLO3%20%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2018100917221176.jpg" alt="img"></p><p>图片来自：<a href="https://blog.csdn.net/leviopku/article/details/82660381" target="_blank" rel="noopener">https://blog.csdn.net/leviopku/article/details/82660381</a></p><p>将 YOLO3 网络结构划分为多个层和层包，下面的各个层包的解释：</p><ul><li>conv：卷积层</li><li>DBL： Darknetconv2d_BN_Leaky，conv  + BN + Leaky relu。</li></ul><ul><li>res*：resblock_body， * 是数字，表示内含res_unit数目，有res1，res2, … ,res8等等</li><li>res_unit ： 借鉴残差网络思想，将特征值 $\pmb x$ 与经过两个 DBL 的净输入值 $\pmb z$ 相加作为最终净输入。</li></ul><p>操作：</p><ul><li>concat：张量拼接，即<code>tf.concat</code>，会使最后一个维度变长。</li></ul><a id="more"></a><h3 id="Darknetconv2d-BN-Leaky"><a href="#Darknetconv2d-BN-Leaky" class="headerlink" title="Darknetconv2d_BN_Leaky"></a>Darknetconv2d_BN_Leaky</h3><p><strong>什么是 Darknetconv2d_BN_Leaky </strong></p><p>Darknetconv2d_BN_Leaky  是指在卷积层后接一个 BN 然后再通过 relu 函数，这个不是在 YOLO3 提出的，在 YOLO2 就采取在每个卷积层后进行 BN 的做法了。</p><p>YOLO3 keras 源码中的 Darknetconv2d_BN_Leaky 的特征图尺寸，要么等于原图尺寸，要么原图的 1/4 主要看 <code>strides</code> 参数怎么设定。</p><p><strong>为什么使用 Darknetconv2d_BN_Leaky</strong></p><p>接 BN 主要是为了解决梯度消失问题，同时因为 BN 可以把特诊图拉回均值为 0 ，方差为 1 的分布，所以也能对解决内部协变量位移问题起一定作用，保证对于深层网络而言，每批数据的分布大致相同。（当然均值和方差相同也不一定就是分布相同，所以作用有限）</p><p>从 YOLO1 其就在使用 Leaky relu 作为激活函数，Leaky relu 对比 relu 的好处就是，总是有梯度存在的，不至于让深层神经元在训练过程中因为梯度始终为 0 而出现不更新的情况。</p><p><strong>如何实现 Darknetconv2d_BN_Leaky</strong></p><p>在 <code>\yolo3\model.py</code> 文件中：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@wraps(Conv2D)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DarknetConv2D</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""Wrapper to set Darknet parameters for Convolution2D."""</span></span><br><span class="line">    darknet_conv_kwargs = &#123;<span class="string">'kernel_regularizer'</span>: l2(<span class="number">5e-4</span>)&#125; <span class="comment">#l2 是keras的l2正则化器</span></span><br><span class="line">    darknet_conv_kwargs[<span class="string">'padding'</span>] = <span class="string">'valid'</span> <span class="keyword">if</span> kwargs.get(<span class="string">'strides'</span>)==(<span class="number">2</span>,<span class="number">2</span>) <span class="keyword">else</span> <span class="string">'same'</span></span><br><span class="line">    darknet_conv_kwargs.update(kwargs)</span><br><span class="line">    <span class="keyword">return</span> Conv2D(*args, **darknet_conv_kwargs)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DarknetConv2D_BN_Leaky</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""Darknet Convolution2D followed by BatchNormalization and LeakyReLU."""</span></span><br><span class="line">    no_bias_kwargs = &#123;<span class="string">'use_bias'</span>: <span class="literal">False</span>&#125;</span><br><span class="line">    no_bias_kwargs.update(kwargs)</span><br><span class="line">    <span class="keyword">return</span> compose(</span><br><span class="line">        DarknetConv2D(*args, **no_bias_kwargs),</span><br><span class="line">        BatchNormalization(),</span><br><span class="line">        LeakyReLU(alpha=<span class="number">0.1</span>))</span><br></pre></td></tr></table></figure><h4 id="源码分析："><a href="#源码分析：" class="headerlink" title="源码分析："></a>源码分析：</h4><h5 id="l2-5e-4"><a href="#l2-5e-4" class="headerlink" title="l2(5e-4) :"></a><code>l2(5e-4)</code> :</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.keras.regularizers.l2(</span><br><span class="line">    l=<span class="number">0.01</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>参数:</p><ul><li><strong><code>l</code></strong>: 浮点型，L2 正则项前的系数</li></ul><p><code>l2(5e-4)</code> 表示使用 L2 正则项，系数为 <code>5e-4</code></p><h5 id="Conv2D-args-darknet-conv-kwargs"><a href="#Conv2D-args-darknet-conv-kwargs" class="headerlink" title="Conv2D(*args, **darknet_conv_kwargs) :"></a><code>Conv2D(*args, **darknet_conv_kwargs)</code> :</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.keras.layers.Conv2D(</span><br><span class="line">    filters, kernel_size, strides=(<span class="number">1</span>, <span class="number">1</span>), padding=<span class="string">'valid'</span>, data_format=<span class="literal">None</span>,</span><br><span class="line">    dilation_rate=(<span class="number">1</span>, <span class="number">1</span>), activation=<span class="literal">None</span>, use_bias=<span class="literal">True</span>,</span><br><span class="line">    kernel_initializer=<span class="string">'glorot_uniform'</span>, bias_initializer=<span class="string">'zeros'</span>,</span><br><span class="line">    kernel_regularizer=<span class="literal">None</span>, bias_regularizer=<span class="literal">None</span>, activity_regularizer=<span class="literal">None</span>,</span><br><span class="line">    kernel_constraint=<span class="literal">None</span>, bias_constraint=<span class="literal">None</span>, **kwargs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>卷积层</p><p><strong>参数</strong></p><ul><li><strong><code>filters</code></strong>: 整数，卷积核数目，这个参数决定输出的特征图的深度。</li><li><strong><code>kernel_size</code></strong>: 整数，或者整数列表，卷积核大小</li><li><strong><code>strides</code></strong>: 由两个整数组成的整数或元组/列表，指定卷积沿高度和宽度的步幅。可以是单个整数，以指定所有空间维度的相同值。</li><li><strong><code>padding</code></strong>: <code>&quot;valid&quot;</code> 或 <code>&quot;same&quot;</code> (不区分大小写).两个值代表窄卷积和等宽卷积</li><li><strong><code>data_format</code></strong>: 一个字符串,  <code>channels_last</code> (默认) 或者 <code>channels_first</code> 其中之一. 代表输入的张量中通道在哪个维度 <code>channels_last</code> 相当于输入的张量形如 <code>(batch, height, width, channels)</code> 而<code>channels_first</code> 相当于输入张量形如 <code>(batch, channels, height, width)</code>. </li><li><strong><code>dilation_rate</code></strong>: 一个由2个整数组成的整数或元组/列表，指定用于扩张卷积（即空洞卷积）的扩张率。可以是单个整数，以指定所有空间维度的相同值。</li><li><strong><code>activation</code></strong>: 指定激活函数，默认不指定</li><li><strong><code>use_bias</code></strong>: 布尔型，是否使用偏置向量</li><li><strong><code>kernel_initializer</code></strong>: 权重矩阵初始化器</li><li><strong><code>bias_initializer</code></strong>: 偏置向量初始化器</li><li><strong><code>kernel_regularizer</code></strong>: 权重矩阵正则化器</li><li><strong><code>bias_regularizer</code></strong>: 偏置向量正则化器</li><li><strong><code>activity_regularizer</code></strong>: 激活函数初始化器</li><li><strong><code>kernel_constraint</code></strong>: 优化器更新权重后，用于权重的约束函数，要求函数接受一个张量且输出相同形状的张量。</li><li><strong><code>bias_constraint</code></strong>: 优化器更新偏置后，用于偏置向量的约束函数，要求函数接受一个张量且输出相同形状的张量。</li></ul><p><code>Conv2D(*args, **darknet_conv_kwargs)</code> : 对 <code>args</code> 和 <code>darknet_conv_kwargs</code> 解包传参，即除了初始化器，参数都从外部传入。</p><h5 id="DarknetConv2D-BN-Leaky-args-kwargs"><a href="#DarknetConv2D-BN-Leaky-args-kwargs" class="headerlink" title="DarknetConv2D_BN_Leaky(*args, **kwargs) :"></a><code>DarknetConv2D_BN_Leaky(*args, **kwargs)</code> :</h5><p>DBL 块，这个函数主要返回一个函数，该函数通过 compose 构造：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">compose(</span><br><span class="line">        DarknetConv2D(*args, **no_bias_kwargs),</span><br><span class="line">        BatchNormalization(),</span><br><span class="line">        LeakyReLU(alpha=<span class="number">0.1</span>))</span><br></pre></td></tr></table></figure><p><code>compose</code> 是定义在 <code>\yolo3\utils.py</code> 的函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compose</span><span class="params">(*funcs)</span>:</span></span><br><span class="line">    <span class="string">"""Compose arbitrarily many functions, evaluated left to right.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Reference: https://mathieularose.com/function-composition-in-python/</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># return lambda x: reduce(lambda v, f: f(v), funcs, x)</span></span><br><span class="line">    <span class="keyword">if</span> funcs:</span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> f, g: <span class="keyword">lambda</span> *a, **kw: g(f(*a, **kw)), funcs)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'Composition of empty sequence not supported.'</span>)</span><br></pre></td></tr></table></figure><p>其作用主要是通过<code>functools.reduce()</code> 实现可调用对象的连续调用</p><p><code>DarknetConv2D_BN_Leaky(*args, **kwargs)</code> 实际上返回的是</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="constructor">LeakyReLU(<span class="params">alpha</span>=0.1)</span>)(<span class="constructor">BatchNormalization()</span>(<span class="constructor">DarknetConv2D(<span class="operator">*</span><span class="params">args</span>, <span class="operator">**</span><span class="params">no_bias_kwargs</span>)</span>(Inputs)))</span><br></pre></td></tr></table></figure><p>即输入张量经过 <code>DarknetConv2D</code> 后接 <code>BatchNormalization</code> 接 <code>LeakyReLU</code> 。</p><p>其中，<code>BatchNormalization</code> 和 <code>LeakyReLU</code> 分别：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.keras.layers.BatchNormalization(</span><br><span class="line">    axis=<span class="number">-1</span>, momentum=<span class="number">0.99</span>, epsilon=<span class="number">0.001</span>, center=<span class="literal">True</span>, scale=<span class="literal">True</span>,</span><br><span class="line">    beta_initializer=<span class="string">'zeros'</span>, gamma_initializer=<span class="string">'ones'</span>,</span><br><span class="line">    moving_mean_initializer=<span class="string">'zeros'</span>, moving_variance_initializer=<span class="string">'ones'</span>,</span><br><span class="line">    beta_regularizer=<span class="literal">None</span>, gamma_regularizer=<span class="literal">None</span>, beta_constraint=<span class="literal">None</span>,</span><br><span class="line">    gamma_constraint=<span class="literal">None</span>, renorm=<span class="literal">False</span>, renorm_clipping=<span class="literal">None</span>, renorm_momentum=<span class="number">0.99</span>,</span><br><span class="line">    fused=<span class="literal">None</span>, trainable=<span class="literal">True</span>, virtual_batch_size=<span class="literal">None</span>, adjustment=<span class="literal">None</span>, name=<span class="literal">None</span>,</span><br><span class="line">    **kwargs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>部分参数：</p><ul><li><strong><code>axis</code></strong>: 整数，应该被标准化的轴数（第几个维度） 经过卷积的数据应该是通道维度被标准化，所以在<code>data_format=&quot;channels_first&quot;</code> 的 <code>Conv2D</code> 后 , 设置 <code>axis=1</code> 。</li><li><strong><code>momentum</code></strong>: 移动均值和移动方差的动量。</li><li><strong><code>epsilon</code></strong>: 增加到方差的小的浮点数，以避免除以零。</li><li><strong><code>center</code></strong>:如果为 True，把 <code>beta</code> 的偏移量加到标准化的张量上。 如果为 False， <code>beta</code> 被忽略。</li><li><strong><code>scale</code></strong>: 如果为 True，乘以 <code>gamma</code>。 如果为 False，<code>gamma</code> 不使用。 当下一层为线性层（或者例如 <code>nn.relu</code>）， 这可以被禁用，因为缩放将由下一层完成。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.keras.layers.LeakyReLU(</span><br><span class="line">    alpha=<span class="number">0.3</span>, **kwargs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>该函数被解释为<code>f(x) = alpha * x for x &lt; 0</code>, <code>f(x) = x for x &gt;= 0</code>.</p><h3 id="resblock-body"><a href="#resblock-body" class="headerlink" title="resblock_body"></a>resblock_body</h3><p><strong>什么是 resblock_body</strong></p><p>一个 resblock_body 包含多个 res_unit，res 是  (Residual Network， ResNet ) 的缩写 , 每个 res_unit 被定义为</p><script type="math/tex; mode=display">Res(\pmb Z)= \pmb Z + DBL(DBL(\pmb Z))</script><p>其中的 DBL 都是不改变尺寸的，所以 $+$ 即按元素相加</p><p><strong>为什么使用 resblock_body</strong></p><blockquote><p>根据通用近似定理，一个由神经网络构成的非线性单元有足够的能力来近似逼<br>近原始目标函数或残差函数，但实际中后者更容易学习 [He等人，2016]。</p><p>参考论文：</p><p>He K, Zhang X, Ren S, et al. Deep residual learning for image recognition[C] //Proceedings of the IEEE conference on computer vision and pattern recognition. 2016: 770-778.  </p></blockquote><p>容易学习主要体现在</p><p>一方面，$h(z)=z+f(z)$ 在求 $z$ 的偏导时，有链式法则得 ：</p><script type="math/tex; mode=display">\frac{\partial E}{\partial w} = \cdots \frac{\partial h}{\partial z}\cdot \frac{\partial z}{\partial w} \cdots \\=\cdots (1+\frac{\partial f}{\partial z})\cdot \frac{\partial z}{\partial w} \cdots</script><p>相较于普通深度神经网络的梯度相乘，加入常数项 1 一定程度上能稳定梯度，使它不容易消失。让深层神经网络成为可能。</p><p>其次，残差网络可以将前基层的特征隔层传递给下面的层，让一些可能被忽视的特征有了再被提取的可能。</p><p><strong>怎么实现 resblock_body</strong></p><p>在 <code>\yolo3\model.py</code> 文件中：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resblock_body</span><span class="params">(x, num_filters, num_blocks)</span>:</span></span><br><span class="line">    <span class="string">'''A series of resblocks starting with a downsampling Convolution2D'''</span></span><br><span class="line">    <span class="comment"># Darknet uses left and top padding instead of 'same' mode</span></span><br><span class="line">    x = ZeroPadding2D(((<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>)))(x)</span><br><span class="line">    x = DarknetConv2D_BN_Leaky(num_filters, (<span class="number">3</span>,<span class="number">3</span>), strides=(<span class="number">2</span>,<span class="number">2</span>))(x)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_blocks):</span><br><span class="line">        y = compose(</span><br><span class="line">                DarknetConv2D_BN_Leaky(num_filters//<span class="number">2</span>, (<span class="number">1</span>,<span class="number">1</span>)),</span><br><span class="line">                DarknetConv2D_BN_Leaky(num_filters, (<span class="number">3</span>,<span class="number">3</span>)))(x)</span><br><span class="line">        x = Add()([x,y])</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="resblock-body-x-num-filters-num-blocks"><a href="#resblock-body-x-num-filters-num-blocks" class="headerlink" title="resblock_body(x, num_filters, num_blocks)"></a><code>resblock_body(x, num_filters, num_blocks)</code></h5><p><code>x</code> 是输入张量，<code>num_filters</code> 是 DBL 卷积核数目，决定了最终输出的通道数目，<code>num_blocks</code> 指 res_unit 数目。</p><p>可以看到特征图经过一个 resblock_body 先要提取特征并缩小尺寸，随后开始经历 <code>num_blocks</code>  个残差单元，每个残差单元的 y 都要经过一个 1*1 卷积和 3*3 卷积</p><h5 id="ZeroPadding2D-1-0-1-0-x"><a href="#ZeroPadding2D-1-0-1-0-x" class="headerlink" title="ZeroPadding2D(((1,0),(1,0)))(x)"></a><code>ZeroPadding2D(((1,0),(1,0)))(x)</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.keras.layers.ZeroPadding2D(</span><br><span class="line">    padding=(<span class="number">1</span>, <span class="number">1</span>), data_format=<span class="literal">None</span>, **kwargs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>2D 输入的零填充层（例如图像）。</p><p>该图层可以在图像张量的顶部、底部、左侧和右侧添加零表示的行和列。</p><p><strong>参数</strong></p><ul><li><p><strong><code>padding</code></strong></p><p>  : 整数，或 2 个整数的元组，或 2 个整数的 2 个元组。</p><ul><li>如果为整数：将对宽度和高度运用相同的对称填充。</li><li>如果为 2 个整数的元组：</li><li>如果为整数：: 解释为高度和高度的 2 个不同的对称裁剪值：    <code>(symmetric_height_pad, symmetric_width_pad)</code>。</li><li>如果为 2 个整数的 2 个元组：    解释为 <code>((top_pad, bottom_pad), (left_pad, right_pad))</code>。</li></ul></li><li><p><strong><code>data_format</code></strong>: 字符串， <code>channels_last</code> (默认) 或 <code>channels_first</code> 之一， 表示输入中维度的顺序。<code>channels_last</code> 对应输入尺寸为  <code>(batch, height, width, channels)</code>， <code>channels_first</code> 对应输入尺寸为  <code>(batch, channels, height, width)</code>。</p></li></ul><p><strong>输入尺寸</strong></p><ul><li><p>如果 <code>data_format</code> 为 <code>&quot;channels_last&quot;</code>， 输入 4D 张量，尺寸为  <code>(batch, rows, cols, channels)</code>。</p></li><li><p>如果 <code>data_format</code> 为 <code>&quot;channels_first&quot;</code>， 输入 4D 张量，尺寸为  <code>(batch, channels, rows, cols)</code>。</p></li></ul><p><strong>输出尺寸</strong></p><ul><li>如果 <code>data_format</code> 为 <code>&quot;channels_last&quot;</code>， 输出 4D 张量，尺寸为  <code>(batch, padded_rows, padded_cols, channels)</code>。</li><li>如果 <code>data_format</code> 为 <code>&quot;channels_first&quot;</code>， 输出 4D 张量，尺寸为  <code>(batch, channels, padded_rows, padded_cols)</code>。</li></ul><p><code>ZeroPadding2D(((1,0),(1,0)))(x)</code> 表示在 x 的上面和左边填充一列 0 </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = ZeroPadding2D(((<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>)))(x)</span><br><span class="line">x = DarknetConv2D_BN_Leaky(num_filters, (<span class="number">3</span>,<span class="number">3</span>), strides=(<span class="number">2</span>,<span class="number">2</span>))(x)</span><br></pre></td></tr></table></figure><p>上边和左边填一列零后，用 3*3 卷积核，以 2 跨步，<code>valid</code> 模式，经过卷积输出的张量尺寸为（(h-3+1)/2向下取整，(w-1+3)/2向下取整），这样也起到了池化层的作用。</p><h5 id="Add-x-y"><a href="#Add-x-y" class="headerlink" title="Add()([x,y])"></a><code>Add()([x,y])</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.keras.layers.Add(</span><br><span class="line">    **kwargs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>该实例没有舒适化参数，直接实例化调用就行，调用时的输入参数是一个张量列表，要求列表内的张量必须形状相同，最后结果是对应元素相加。</p><p><code>Add()([x,y])</code> 是 y 是经过两个 DBL 的特征图</p><h3 id="darknet-body"><a href="#darknet-body" class="headerlink" title="darknet_body"></a>darknet_body</h3><p><strong>什么是 darknet_body</strong></p><p>darknet_body 就是 YOLO3 的支柱网络，它是 “Darknet-53 ”去掉最后一层卷积层，Darknet-53 结构图如下：</p><p><img src="/2020/04/04/YOLO3%20%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20200317183957614.png" alt="image-20200317183957614"></p><p><strong>为什么使用 darknet_body</strong></p><p>因为 Darknet-53 比 Darknet-19 牛逼，Darknet-53 也是改良自 Darknet-19 ，主要改良是引入了残差结构和用卷积层代替池化层。</p><p>引入残差结构可能为了能提高网络深度。</p><p>使用卷积代替池化，可能是因为单纯的池化没有可学习参数，一般都是在池化前加上 1*1 卷积增加池化层的特征提取功能，Darknet-53 把 1*1 卷积与池化层合并成一个卷积了，减少了一层运算。</p><p><strong>怎么实现 darknet_body</strong></p><p>在 <code>\yolo3\model.py</code> 文件中：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">darknet_body</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">'''Darknent body having 52 Convolution2D layers'''</span></span><br><span class="line">    x = DarknetConv2D_BN_Leaky(<span class="number">32</span>, (<span class="number">3</span>,<span class="number">3</span>))(x)</span><br><span class="line">    x = resblock_body(x, <span class="number">64</span>, <span class="number">1</span>)</span><br><span class="line">    x = resblock_body(x, <span class="number">128</span>, <span class="number">2</span>)</span><br><span class="line">    x = resblock_body(x, <span class="number">256</span>, <span class="number">8</span>)</span><br><span class="line">    x = resblock_body(x, <span class="number">512</span>, <span class="number">8</span>)</span><br><span class="line">    x = resblock_body(x, <span class="number">1024</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>相关层的源码上面已经解释过了，这里就照着结构图复现就完事了。</p><h3 id="yolo-body"><a href="#yolo-body" class="headerlink" title="yolo_body"></a>yolo_body</h3><p><strong>什么是 yolo_body</strong></p><p>yolo_body 从 yolo3 的支柱网络 Darknet-52 手里接过输出的特征图，兵分三路，最终生成了 y1，y2，y3 三个输出，三个输出深度一直，唯一不同就是尺寸，前面的 Darknet-52 是特征提取，到这就开始根据前面提取的特征进行目标识别了。</p><p><strong>为什么要分成三个输出，每个输出还要拼接前面的层</strong></p><p>因为自从 YOLO2 开始，YOLO 网络开始借助 RPN 的思想，最终输出的特征图的每一个像素点，其实包含了一个<strong>感受野区域</strong>的特征信息，显然 13*13 的特征图，意味着感受野比较大，这样的特征图适合识别大物体；相反 52*52 的感受野较小，这样的特征图适合识别小物体，这也是相对于YOLO2 的改进，这样 YOLO3 就既能识别大物体，又能识别小物体了。</p><p>拼接之前层的输出，是从 YOLO2 就开始有的思想，叫细粒度分类，也是为了能保留小物体的特征。</p><p><strong>怎么实现 yolo_body</strong></p><p>在 <code>\yolo3\model.py</code> 文件中：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_last_layers</span><span class="params">(x, num_filters, out_filters)</span>:</span></span><br><span class="line">    <span class="string">'''6 Conv2D_BN_Leaky layers followed by a Conv2D_linear layer'''</span></span><br><span class="line">    x = compose(</span><br><span class="line">            DarknetConv2D_BN_Leaky(num_filters, (<span class="number">1</span>,<span class="number">1</span>)),</span><br><span class="line">            DarknetConv2D_BN_Leaky(num_filters*<span class="number">2</span>, (<span class="number">3</span>,<span class="number">3</span>)),</span><br><span class="line">            DarknetConv2D_BN_Leaky(num_filters, (<span class="number">1</span>,<span class="number">1</span>)),</span><br><span class="line">            DarknetConv2D_BN_Leaky(num_filters*<span class="number">2</span>, (<span class="number">3</span>,<span class="number">3</span>)),</span><br><span class="line">            DarknetConv2D_BN_Leaky(num_filters, (<span class="number">1</span>,<span class="number">1</span>)))(x)</span><br><span class="line">    y = compose(</span><br><span class="line">            DarknetConv2D_BN_Leaky(num_filters*<span class="number">2</span>, (<span class="number">3</span>,<span class="number">3</span>)),</span><br><span class="line">            DarknetConv2D(out_filters, (<span class="number">1</span>,<span class="number">1</span>)))(x)</span><br><span class="line">    <span class="keyword">return</span> x, y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">yolo_body</span><span class="params">(inputs, num_anchors, num_classes)</span>:</span></span><br><span class="line">    <span class="string">"""Create YOLO_V3 model CNN body in Keras."""</span></span><br><span class="line">    darknet = Model(inputs, darknet_body(inputs))</span><br><span class="line">    x, y1 = make_last_layers(darknet.output, <span class="number">512</span>, num_anchors*(num_classes+<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">    x = compose(</span><br><span class="line">            DarknetConv2D_BN_Leaky(<span class="number">256</span>, (<span class="number">1</span>,<span class="number">1</span>)),</span><br><span class="line">            UpSampling2D(<span class="number">2</span>))(x)</span><br><span class="line">    x = Concatenate()([x,darknet.layers[<span class="number">152</span>].output])</span><br><span class="line">    x, y2 = make_last_layers(x, <span class="number">256</span>, num_anchors*(num_classes+<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">    x = compose(</span><br><span class="line">            DarknetConv2D_BN_Leaky(<span class="number">128</span>, (<span class="number">1</span>,<span class="number">1</span>)),</span><br><span class="line">            UpSampling2D(<span class="number">2</span>))(x)</span><br><span class="line">    x = Concatenate()([x,darknet.layers[<span class="number">92</span>].output])</span><br><span class="line">    x, y3 = make_last_layers(x, <span class="number">128</span>, num_anchors*(num_classes+<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Model(inputs, [y1,y2,y3])</span><br></pre></td></tr></table></figure><p>这里 darknet 和 yolo3 都是用的 keras 的 Functional API 构建的网络模型，Functional API 挺简单的而且还支持多输出。</p><h4 id="源码讲解"><a href="#源码讲解" class="headerlink" title="源码讲解"></a>源码讲解</h4><h5 id="make-last-layers-darknet-output-512-num-anchors-num-classes-5"><a href="#make-last-layers-darknet-output-512-num-anchors-num-classes-5" class="headerlink" title="make_last_layers(darknet.output, 512, num_anchors*(num_classes+5))"></a><code>make_last_layers(darknet.output, 512, num_anchors*(num_classes+5))</code></h5><p>这个函数先把 yolo3 的输出分成两个：y1 和不是 y1，源码结构清晰，一目了然，其中参数<code>arknet.output</code> 是提取前面已经封装成模型的 <code>darknet</code> 的输出，把前一个模型的输出作为这个模型的输入， 以前后顺序衔接两个模型。<code>512</code> 是中间 DBL 的卷积和数目，<code>num_anchors*(num_classes+5)</code> 是最终生成的特征图的深度，5 是指 4 个坐标信息 + 置信度。</p><h5 id="yolo-body-inputs-num-anchors-num-classes"><a href="#yolo-body-inputs-num-anchors-num-classes" class="headerlink" title="yolo_body(inputs, num_anchors, num_classes)"></a><code>yolo_body(inputs, num_anchors, num_classes)</code></h5><p>构建 YOLO3 网络，通过 <code>UpSampling2D(2))(x)</code> 、 <code>darknet.layers[]</code>  、和 <code>Concatenate()</code> 实现特征图拼接 darknet 中间某层的输出的操作。</p><h5 id="UpSampling2D-2-x"><a href="#UpSampling2D-2-x" class="headerlink" title="UpSampling2D(2))(x)"></a><code>UpSampling2D(2))(x)</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.keras.layers.UpSampling2D(</span><br><span class="line">    size=(<span class="number">2</span>, <span class="number">2</span>), data_format=<span class="literal">None</span>, interpolation=<span class="string">'nearest'</span>, **kwargs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>2D 输入的上采样层。</p><p>沿着数据的行和列分别重复 <code>size[0]</code> 和 <code>size[1]</code> 次。</p><p><strong>参数</strong></p><ul><li><strong>size</strong>: 整数，或 2 个整数的元组。 行和列的上采样因子。</li><li><strong>data_format</strong>: 字符串， <code>channels_last</code> (默认) 或 <code>channels_first</code> 之一， 表示输入中维度的顺序。<code>channels_last</code> 对应输入尺寸为  <code>(batch, height, width, channels)</code>， <code>channels_first</code> 对应输入尺寸为  <code>(batch, channels, height, width)</code>。</li><li><strong>interpolation</strong>: 字符串，<code>nearest</code> 或 <code>bilinear</code> 之一。  </li></ul><p><strong>输入尺寸</strong></p><ul><li>如果 <code>data_format</code> 为 <code>&quot;channels_last&quot;</code>， 输入 4D 张量，尺寸为  <code>(batch, rows, cols, channels)</code>。</li><li>如果 <code>data_format</code> 为 <code>&quot;channels_first&quot;</code>， 输入 4D 张量，尺寸为  <code>(batch, channels, rows, cols)</code>。</li></ul><p><strong>输出尺寸</strong></p><ul><li>如果 <code>data_format</code> 为 <code>&quot;channels_last&quot;</code>， 输出 4D 张量，尺寸为  <code>(batch, upsampled_rows, upsampled_cols, channels)</code>。</li><li>如果 <code>data_format</code> 为 <code>&quot;channels_first&quot;</code>， 输出 4D 张量，尺寸为  <code>(batch, channels, upsampled_rows, upsampled_cols)</code>。</li></ul><p>上采用就是下采样的逆操作，这里是每个元素重复4次变成一个 4*4 区域，使整个特征图尺寸扩大 4 倍（高扩 2 倍，宽扩 2 倍）</p><h5 id="darknet-layers"><a href="#darknet-layers" class="headerlink" title="darknet.layers[]"></a><code>darknet.layers[]</code></h5><p><code>layers</code> 是 <code>tf.keras.Model</code> 类的属性，可以通过 <code>[]</code> 提取特定的层，也可以用<code>Model.get_layer()</code> 方法替代。</p><h5 id="x-Concatenate-x-darknet-layers-152-output"><a href="#x-Concatenate-x-darknet-layers-152-output" class="headerlink" title="x = Concatenate()([x,darknet.layers[152].output])"></a><code>x = Concatenate()([x,darknet.layers[152].output])</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tf.keras.layers.Concatenate(</span><br><span class="line">    axis=<span class="number">-1</span>, **kwargs</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>连接一个输入张量的列表。</p><p>它接受一个张量的列表， 除了连接轴之外，其他的尺寸都必须相同， 然后返回一个由所有输入张量连接起来的输出张量。</p><p><strong>参数</strong></p><ul><li><strong>axis</strong>: 连接的轴。</li><li><strong><em>\</em>kwargs</strong>: 层关键字参数。</li></ul><p><strong>输入</strong></p><ul><li>张量列表，要求除了连接轴之外，其他的尺寸都必须相同</li></ul><p>注意区分于 <code>Add()</code> 一个是对应元素相加，一个把一个轴上的数据前后连接在一起。</p><h2 id="Tiny-YOLO-的网络结构"><a href="#Tiny-YOLO-的网络结构" class="headerlink" title="Tiny YOLO 的网络结构"></a>Tiny YOLO 的网络结构</h2><p>通过对前面逐层代码的学习，Tiny YOLO 的结构一目了然，Tiny YOLO 缩减了 Darknet-52，并且只输出 y1 和 y2，它有更快的收敛速度，但是相对的精度没有 YOLO 高，它的源码在 <code>\yolo3\model.py</code> 文件中：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tiny_yolo_body</span><span class="params">(inputs, num_anchors, num_classes)</span>:</span></span><br><span class="line">    <span class="string">'''Create Tiny YOLO_v3 model CNN body in keras.'''</span></span><br><span class="line">    x1 = compose(</span><br><span class="line">            DarknetConv2D_BN_Leaky(<span class="number">16</span>, (<span class="number">3</span>,<span class="number">3</span>)),</span><br><span class="line">            MaxPooling2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>), strides=(<span class="number">2</span>,<span class="number">2</span>), padding=<span class="string">'same'</span>),</span><br><span class="line">            DarknetConv2D_BN_Leaky(<span class="number">32</span>, (<span class="number">3</span>,<span class="number">3</span>)),</span><br><span class="line">            MaxPooling2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>), strides=(<span class="number">2</span>,<span class="number">2</span>), padding=<span class="string">'same'</span>),</span><br><span class="line">            DarknetConv2D_BN_Leaky(<span class="number">64</span>, (<span class="number">3</span>,<span class="number">3</span>)),</span><br><span class="line">            MaxPooling2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>), strides=(<span class="number">2</span>,<span class="number">2</span>), padding=<span class="string">'same'</span>),</span><br><span class="line">            DarknetConv2D_BN_Leaky(<span class="number">128</span>, (<span class="number">3</span>,<span class="number">3</span>)),</span><br><span class="line">            MaxPooling2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>), strides=(<span class="number">2</span>,<span class="number">2</span>), padding=<span class="string">'same'</span>),</span><br><span class="line">            DarknetConv2D_BN_Leaky(<span class="number">256</span>, (<span class="number">3</span>,<span class="number">3</span>)))(inputs)</span><br><span class="line">    x2 = compose(</span><br><span class="line">            MaxPooling2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>), strides=(<span class="number">2</span>,<span class="number">2</span>), padding=<span class="string">'same'</span>),</span><br><span class="line">            DarknetConv2D_BN_Leaky(<span class="number">512</span>, (<span class="number">3</span>,<span class="number">3</span>)),</span><br><span class="line">            MaxPooling2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>), strides=(<span class="number">1</span>,<span class="number">1</span>), padding=<span class="string">'same'</span>),</span><br><span class="line">            DarknetConv2D_BN_Leaky(<span class="number">1024</span>, (<span class="number">3</span>,<span class="number">3</span>)),</span><br><span class="line">            DarknetConv2D_BN_Leaky(<span class="number">256</span>, (<span class="number">1</span>,<span class="number">1</span>)))(x1)</span><br><span class="line">    y1 = compose(</span><br><span class="line">            DarknetConv2D_BN_Leaky(<span class="number">512</span>, (<span class="number">3</span>,<span class="number">3</span>)),</span><br><span class="line">            DarknetConv2D(num_anchors*(num_classes+<span class="number">5</span>), (<span class="number">1</span>,<span class="number">1</span>)))(x2)</span><br><span class="line"></span><br><span class="line">    x2 = compose(</span><br><span class="line">            DarknetConv2D_BN_Leaky(<span class="number">128</span>, (<span class="number">1</span>,<span class="number">1</span>)),</span><br><span class="line">            UpSampling2D(<span class="number">2</span>))(x2)</span><br><span class="line">    y2 = compose(</span><br><span class="line">            Concatenate(),</span><br><span class="line">            DarknetConv2D_BN_Leaky(<span class="number">256</span>, (<span class="number">3</span>,<span class="number">3</span>)),</span><br><span class="line">            DarknetConv2D(num_anchors*(num_classes+<span class="number">5</span>), (<span class="number">1</span>,<span class="number">1</span>)))([x2,x1])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Model(inputs, [y1,y2])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> YOLO3 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> YOLO3 </tag>
            
            <tag> Keras </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YOLO3 数据处理与数据加载 Keras源码分析</title>
      <link href="/2020/04/04/YOLO3%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2020/04/04/YOLO3%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>YOLO3 Keras 源码：<a href="https://github.com/qqwweee/keras-yolo3" target="_blank" rel="noopener">https://github.com/qqwweee/keras-yolo3</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文从主要是从源码层面对 YOLO3 的数据处理相关内容进行分析与讲解。通常，一个功能的实现需要多个函数配合，所以我将每个功能的实现函数分为两部分，<strong>基础函数</strong> 和 <strong>实现函数</strong> ：</p><ul><li>基础函数：被实现函数所依赖，是实现函数的一部分</li><li>实现函数：通过调用基础函数实现功能</li></ul><p>源码内容比较多，通过目录索引看感兴趣的地方即可。</p><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><h3 id="数据集转换"><a href="#数据集转换" class="headerlink" title="数据集转换"></a>数据集转换</h3><p>YOLO3 Keras 源码所需要的数据集应该在一个<code>.txt</code> ( 文本文件 )内，文件中的一行代表一个张图片和它的标签，其中每行的格式为：</p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">image_file_path</span> <span class="keyword">box1 </span><span class="keyword">box2 </span>... <span class="keyword">boxN</span></span><br></pre></td></tr></table></figure><p><code>box*</code> 是该图片的标签，即真实框，不同box之间用空格隔开，其中每个box的格式为</p><figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"><span class="built_in">x_min,</span>y_min,x_max,y_max,class_id</span><br></pre></td></tr></table></figure><p>所以总的来说，训练用的数据集应该大体是这个样子的：</p><a id="more"></a><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">path/to/img1.jpg <span class="number">50</span>,<span class="number">100</span>,<span class="number">150</span>,<span class="number">200</span>,<span class="number">0</span> <span class="number">30</span>,<span class="number">50</span>,<span class="number">200</span>,<span class="number">120</span>,<span class="number">3</span></span><br><span class="line">path/to/img2.jpg <span class="number">120</span>,<span class="number">300</span>,<span class="number">250</span>,<span class="number">600</span>,<span class="number">2</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>对于 VOC 数据集，Keras 源码的作者给出了脚本 <code>voc_annotation.py</code> 可以将 VOC 数据集转化成上述格式。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> getcwd</span><br><span class="line"></span><br><span class="line">sets=[(<span class="string">'2007'</span>, <span class="string">'train'</span>), (<span class="string">'2007'</span>, <span class="string">'val'</span>), (<span class="string">'2007'</span>, <span class="string">'test'</span>)]</span><br><span class="line"></span><br><span class="line">classes = [<span class="string">"aeroplane"</span>, <span class="string">"bicycle"</span>, <span class="string">"bird"</span>, <span class="string">"boat"</span>, <span class="string">"bottle"</span>, <span class="string">"bus"</span>, <span class="string">"car"</span>, <span class="string">"cat"</span>, <span class="string">"chair"</span>, <span class="string">"cow"</span>, <span class="string">"diningtable"</span>, <span class="string">"dog"</span>, <span class="string">"horse"</span>, <span class="string">"motorbike"</span>, <span class="string">"person"</span>, <span class="string">"pottedplant"</span>, <span class="string">"sheep"</span>, <span class="string">"sofa"</span>, <span class="string">"train"</span>, <span class="string">"tvmonitor"</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_annotation</span><span class="params">(year, image_id, list_file)</span>:</span></span><br><span class="line">    in_file = open(<span class="string">'VOCdevkit/VOC%s/Annotations/%s.xml'</span>%(year, image_id))</span><br><span class="line">    tree=ET.parse(in_file)</span><br><span class="line">    root = tree.getroot()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> root.iter(<span class="string">'object'</span>):</span><br><span class="line">        difficult = obj.find(<span class="string">'difficult'</span>).text</span><br><span class="line">        cls = obj.find(<span class="string">'name'</span>).text</span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> classes <span class="keyword">or</span> int(difficult)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        cls_id = classes.index(cls)</span><br><span class="line">        xmlbox = obj.find(<span class="string">'bndbox'</span>)</span><br><span class="line">        b = (int(xmlbox.find(<span class="string">'xmin'</span>).text), int(xmlbox.find(<span class="string">'ymin'</span>).text), int(xmlbox.find(<span class="string">'xmax'</span>).text), int(xmlbox.find(<span class="string">'ymax'</span>).text))</span><br><span class="line">        list_file.write(<span class="string">" "</span> + <span class="string">","</span>.join([str(a) <span class="keyword">for</span> a <span class="keyword">in</span> b]) + <span class="string">','</span> + str(cls_id))</span><br><span class="line"></span><br><span class="line">wd = getcwd()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> year, image_set <span class="keyword">in</span> sets:</span><br><span class="line">    image_ids = open(<span class="string">'VOCdevkit/VOC%s/ImageSets/Main/%s.txt'</span>%(year, image_set)).read().strip().split()</span><br><span class="line">    list_file = open(<span class="string">'%s_%s.txt'</span>%(year, image_set), <span class="string">'w'</span>)</span><br><span class="line">    <span class="keyword">for</span> image_id <span class="keyword">in</span> image_ids:</span><br><span class="line">        list_file.write(<span class="string">'%s/VOCdevkit/VOC%s/JPEGImages/%s.jpg'</span>%(wd, year, image_id))</span><br><span class="line">        convert_annotation(year, image_id, list_file)</span><br><span class="line">        list_file.write(<span class="string">'\n'</span>)</span><br><span class="line">    list_file.close()</span><br></pre></td></tr></table></figure><h4 id="基础函数："><a href="#基础函数：" class="headerlink" title="基础函数："></a>基础函数：</h4><h5 id="convert-annotation-year-image-id-list-file"><a href="#convert-annotation-year-image-id-list-file" class="headerlink" title="convert_annotation(year, image_id, list_file)"></a><code>convert_annotation(year, image_id, list_file)</code></h5><p>参数：</p><ul><li><strong>year</strong>：整型，年代 , VOC2007 的 2007 </li><li><strong>image_id</strong> ：图像序号</li><li><strong>list_file</strong> ： 文件对象</li></ul><p>功能：</p><ul><li>通过 <code>year</code> 和 <code>image_id</code>找到 VOC 数据集里的 xml 文件，通过 ElementTree 找到这个 XML 里的每一个 <code>object</code> 标签，获取该标签内的 <code>xmin,ymin,xmax,ymax</code>，和列表序号<code>class_id</code> ，把它们写入到 list_file 所打开的文件对象中。</li><li>总之，这个函数是在将 <code>.xml</code> 中的标注信息转化为 YOLO3 所需要标注格式，并写入文件。</li></ul><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><h5 id="脚本主内容"><a href="#脚本主内容" class="headerlink" title="脚本主内容"></a>脚本主内容</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> year, image_set <span class="keyword">in</span> sets:</span><br><span class="line">    image_ids = open(<span class="string">'VOCdevkit/VOC%s/ImageSets/Main/%s.txt'</span>%(year, image_set)).read().strip().split()</span><br><span class="line">    list_file = open(<span class="string">'%s_%s.txt'</span>%(year, image_set), <span class="string">'w'</span>)</span><br><span class="line">    <span class="keyword">for</span> image_id <span class="keyword">in</span> image_ids:</span><br><span class="line">        list_file.write(<span class="string">'%s/VOCdevkit/VOC%s/JPEGImages/%s.jpg'</span>%(wd, year, image_id))</span><br><span class="line">        convert_annotation(year, image_id, list_file)</span><br><span class="line">        list_file.write(<span class="string">'\n'</span>)</span><br><span class="line">    list_file.close()</span><br></pre></td></tr></table></figure><p><code>year, image_set</code> 是从 <code>sets</code> 提取而来，这个 for 循环的目的是操作 <code>sets</code> 中对应的每一个文件。</p><p>即打开<code>train.txt</code> 、<code>val.txt</code> 、<code>test.txt</code> ，它们里面内容长这个样：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">1000</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>这其中每一行都是图片的序号。</p><p>如打开<code>train.txt</code> ，脚本通过 <code>.read().strip().split()</code> ，把 <code>train.txt</code> 中一行一行的图片序号变成一个列表 <code>image_ids</code> ，创建一个文件对象 <code>list_file</code> 随后对列表内每一个元素进行操作：</p><ul><li>根据文件路径和图片序号的映射关系，把图片路劲写入到 <code>list_file</code>  文件对象对应的文件中。</li><li>通过 <code>convert_annotation</code> 把图片的标注信息（已转化为 YOLO3 所需格式），紧接着路径信息写在后面</li><li>写入换行符</li></ul><p>所以元素操作完事，关闭文件对象。</p><p>通过上述流程对 <code>train.txt</code> 、<code>val.txt</code> 、<code>test.txt</code> 都操作完，就把 VOC 数据集转化为 YOLO3 所需要的格式了。</p><h3 id="使用-K-means-生成锚框"><a href="#使用-K-means-生成锚框" class="headerlink" title="使用 K-means 生成锚框"></a>使用 K-means 生成锚框</h3><p>YOLO2 开始，锚框的生成使用 K-means 算法，这种倚靠训练数据自动生成的锚框，比人为设定的锚框更加符合特定场景的业务需求，所以会提高模型的准确度。</p><p>介绍 K-means 之前，需要先了解它是用于什么学习任务的，K-means 是解决聚类问题的一个算法。</p><h4 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h4><p><strong>聚类和簇</strong></p><p>聚类任务是一种无监督学习任务，聚类试图将样本划分为若干个不相交的子集，每个子集成为<strong>簇</strong>，通过这样的划分，每个簇对应一个潜在类别，具体是什么类别，对于聚类算法而言是未知，都是在聚类结束后，人为的判断一个簇对应的什么类别。聚类常用于寻找数据内部的分布结构，或用于对其他分类学习任务进行粗略的预先处理。比如自从 YOLO2 后，聚类算法就被用于预先为图像划定锚框。</p><p><strong>距离计算</strong></p><p>聚类任务说到底是让”簇内相似度高“且”簇间相似度低“，那么就需要一个衡量相似度的指标，两个样本间的距离可以反映样本之间的相似度，所以定义 $dist(\cdot,\cdot)$ 为两个样本的距离。距离的计算有诸多算法，比如“闵可夫斯基距离”</p><script type="math/tex; mode=display">dist_{mk}(x_i,x_j)=(\sum_{u=1}^n|x_{i,u}-x_{j,x}|^p)^{\frac{1}{p}}</script><p>在 YOLO2 和 YOLO3 中，距离计算是借助两个 box 的 IOU：</p><script type="math/tex; mode=display">dist(b_i,b_j)=1-IOU(b_i,b_j)</script><p><strong>K-means 算法</strong></p><p>K-means 的思想是，对所划分的所有簇 $C=\{C_1,C_2,\dots,C_k\}$ 使</p><script type="math/tex; mode=display">E=\sum_{i=1}^k\sum_{x\in C_i}dist(x,\mu_i)</script><p>最小，其中 $\mu_i=\frac{1}{|C_i|}\sum_{x\in C_i}x$ ，即 $\mu_i$ 是 $C_i$ 的均指向量。</p><p>为了达到这个目的，K-means 采用贪心策略，最开始随机指定 K 个向量作为 $(\mu_1,\dots,\mu_k)$ 对于每一个 $\mu_i$ ，计算每一个向量 $x$ 与 $\mu_i$ 的距离，即 $dist(x,\mu_i)$ 将距离值最小的向量，归到 $C_i$ 然后更新  $\mu_i$ ，重复这个过程，直到 $(\mu_1,\dots,\mu_k)$ 都不再更新。</p><p><img src="/2020/04/04/YOLO3%20%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/20200322031027706.png" alt></p><h4 id="基础函数"><a href="#基础函数" class="headerlink" title="基础函数"></a>基础函数</h4><h5 id="YOLO-Kmeans-init"><a href="#YOLO-Kmeans-init" class="headerlink" title="YOLO_Kmeans.__init__"></a><code>YOLO_Kmeans.__init__</code></h5><p><code>YOLO_Kmeans</code> 是一个类，它的初始化函数如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, cluster_number, filename)</span>:</span></span><br><span class="line">    self.cluster_number = cluster_number</span><br><span class="line">    self.filename = filename</span><br></pre></td></tr></table></figure><p>其作用仅是将参数保留到类内</p><h5 id="YOLO-Kmeans-txt2boxes"><a href="#YOLO-Kmeans-txt2boxes" class="headerlink" title="YOLO_Kmeans.txt2boxes"></a><code>YOLO_Kmeans.txt2boxes</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">txt2boxes</span><span class="params">(self)</span>:</span></span><br><span class="line">    f = open(self.filename, <span class="string">'r'</span>)</span><br><span class="line">    dataSet = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        infos = line.split(<span class="string">" "</span>)</span><br><span class="line">        length = len(infos)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length):</span><br><span class="line">            width = int(infos[i].split(<span class="string">","</span>)[<span class="number">2</span>]) - \</span><br><span class="line">                int(infos[i].split(<span class="string">","</span>)[<span class="number">0</span>])</span><br><span class="line">            height = int(infos[i].split(<span class="string">","</span>)[<span class="number">3</span>]) - \</span><br><span class="line">                int(infos[i].split(<span class="string">","</span>)[<span class="number">1</span>])</span><br><span class="line">            dataSet.append([width, height])</span><br><span class="line">    result = np.array(dataSet)</span><br><span class="line">    f.close()</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>该方法的作用是将 YOLO 标注文件内的 box 信息转化为列表</p><p>YOLO 标注文件格式如下：</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">path/to/img1.jpg <span class="number">50</span>,<span class="number">100</span>,<span class="number">150</span>,<span class="number">200</span>,<span class="number">0</span> <span class="number">30</span>,<span class="number">50</span>,<span class="number">200</span>,<span class="number">120</span>,<span class="number">3</span></span><br><span class="line">path/to/img2.jpg <span class="number">120</span>,<span class="number">300</span>,<span class="number">250</span>,<span class="number">600</span>,<span class="number">2</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>f</code> 是一个文件对象，文件对象可迭代，每次读取文件的一行，最外层的 for 是指对文件内的每一行操作。</p><p>对文件内的每一行，以空格为分隔符，将其划分为列表 <code>infos</code> ：</p><p>对 <code>infos[1]</code> 到 <code>infors[length-1]</code> 中的每一个元素 <code>infos[i]</code> 而言，每一个 <code>infos[i]</code> 代表一组 box 信息。<code>infos[i].split(&quot;,&quot;)[0]</code> 、<code>infos[i].split(&quot;,&quot;)[1]</code> 、<code>infos[i].split(&quot;,&quot;)[2]</code> 、<code>infos[i].split(&quot;,&quot;)[3]</code>   、<code>infos[i].split(&quot;,&quot;)[4]</code>分别对应 box 信息里的 <code>x_min,y_min,x_max,y_max,class_id</code> ，由这些信息就可以计算出 box 的宽和高，记为<code>[width, height]</code> ，将每组 box 的 <code>[width, height]</code> 追加到 <code>dataSet</code> 列表内，将 <code>dataSet</code>  转化为 <code>np.array</code> 并返回。</p><h5 id="YOLO-Kmeans-iou"><a href="#YOLO-Kmeans-iou" class="headerlink" title="YOLO_Kmeans.iou"></a><code>YOLO_Kmeans.iou</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">iou</span><span class="params">(self, boxes, clusters)</span>:</span>  <span class="comment"># 1 box -&gt; k clusters</span></span><br><span class="line">    n = boxes.shape[<span class="number">0</span>]</span><br><span class="line">    k = self.cluster_number</span><br><span class="line"></span><br><span class="line">    box_area = boxes[:, <span class="number">0</span>] * boxes[:, <span class="number">1</span>]</span><br><span class="line">    box_area = box_area.repeat(k)</span><br><span class="line">    box_area = np.reshape(box_area, (n, k))</span><br><span class="line"></span><br><span class="line">    cluster_area = clusters[:, <span class="number">0</span>] * clusters[:, <span class="number">1</span>]</span><br><span class="line">    cluster_area = np.tile(cluster_area, [<span class="number">1</span>, n])</span><br><span class="line">    cluster_area = np.reshape(cluster_area, (n, k))</span><br><span class="line"></span><br><span class="line">    box_w_matrix = np.reshape(boxes[:, <span class="number">0</span>].repeat(k), (n, k))</span><br><span class="line">    cluster_w_matrix = np.reshape(np.tile(clusters[:, <span class="number">0</span>], (<span class="number">1</span>, n)), (n, k))</span><br><span class="line">    min_w_matrix = np.minimum(cluster_w_matrix, box_w_matrix)</span><br><span class="line"></span><br><span class="line">    box_h_matrix = np.reshape(boxes[:, <span class="number">1</span>].repeat(k), (n, k))</span><br><span class="line">    cluster_h_matrix = np.reshape(np.tile(clusters[:, <span class="number">1</span>], (<span class="number">1</span>, n)), (n, k))</span><br><span class="line">    min_h_matrix = np.minimum(cluster_h_matrix, box_h_matrix)</span><br><span class="line">    inter_area = np.multiply(min_w_matrix, min_h_matrix)</span><br><span class="line"></span><br><span class="line">    result = inter_area / (box_area + cluster_area - inter_area)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>boxes ： 盒子信息，结构为<code>[[w1,h1],[w2,h2]...]</code></li><li>clusters：簇点信息，内含 k 个 <code>[w,h]</code> 结构为 <code>[[w1,h1],...,[wk,hk]]</code></li></ul><p>执行过程：</p><ul><li>求每个盒子的面积，重复 k 次，得到 n*k 矩阵 <code>box_area</code> , n 是总盒子数，k 是簇数</li><li>求每个簇点的面积，所有簇点面积集合记为 <code>cluster_area</code> , 一开始，<code>cluster_area</code> 是 <code>shape=(1,k)</code> 的 np 数组，经过 <code>np.tile</code> 变成 <code>shape=(1,k*n)</code>，<code>np.reshape</code> 成 <code>shape=(n,k)</code></li><li>用相似的维度变化，求盒子的 w 矩阵 <code>box_w_matrix</code>，与簇点的 w 矩阵 <code>cluster_w_matrix</code> ，用 <code>np.minimum</code> 取宽最小矩阵 <code>min_w_matrix</code></li><li>同理求高最小矩阵 <code>min_h_matrix</code></li><li>盒子与簇在假设左上角对齐的情况下，最小的宽*最小的高就是他们相交的区域的面积，相交面积 <code>inter_area = np.multiply(min_w_matrix, min_h_matrix)</code></li><li>最终返回 IOU 值 IOU = 相交面积/相并面积 = 相交面积/( 盒子面积 + 簇点面积 - 相交面积 )，最红返回的 result 的形状 <code>shape=(n,k)</code></li></ul><h5 id="YOLO-Kmeans-kmeans"><a href="#YOLO-Kmeans-kmeans" class="headerlink" title="YOLO_Kmeans.kmeans"></a><code>YOLO_Kmeans.kmeans</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kmeans</span><span class="params">(self, boxes, k, dist=np.median)</span>:</span></span><br><span class="line">    box_number = boxes.shape[<span class="number">0</span>]</span><br><span class="line">    distances = np.empty((box_number, k))</span><br><span class="line">    last_nearest = np.zeros((box_number,))</span><br><span class="line">    np.random.seed()</span><br><span class="line">    clusters = boxes[np.random.choice(</span><br><span class="line">        box_number, k, replace=<span class="literal">False</span>)]  <span class="comment"># init k clusters</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">        distances = <span class="number">1</span> - self.iou(boxes, clusters)</span><br><span class="line"></span><br><span class="line">        current_nearest = np.argmin(distances, axis=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (last_nearest == current_nearest).all():</span><br><span class="line">            <span class="keyword">break</span>  <span class="comment"># clusters won't change</span></span><br><span class="line">        <span class="keyword">for</span> cluster <span class="keyword">in</span> range(k):</span><br><span class="line">            clusters[cluster] = dist(  <span class="comment"># update clusters</span></span><br><span class="line">                boxes[current_nearest == cluster], axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        last_nearest = current_nearest</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clusters</span><br></pre></td></tr></table></figure><p>参数 :</p><ul><li>boxes : 前面通过 <code>txt2boxes</code> 处理后得到的 np 数组，结构为<code>[[w1,h1],[w2,h2]...]</code></li><li>k : 整型，簇数</li><li>dist : 均值向量生成策略，这里用的中位数（那应该叫中位数向量hhhh）</li></ul><p>执行过程：</p><ul><li><p>得到 <code>boxes</code> 中的盒子数 <code>box_number</code>，用 <code>np.empty</code> 创建一个 <code>shape=(box_number, k)</code> 的空 np 数组 <code>distances</code>，用储存 boxes 中的每个盒子和每个簇的距离；用 <code>np.zeros</code> 创建一个长度为 <code>box_number</code> 的一维全零 np 数组，用于存储每个盒子距离最近的簇的索引值。</p></li><li><p>通过 <code>clusters = boxes[np.random.choice(box_number, k, replace=False)]</code> 从 <code>boxes</code>  中随机进行不放回抽样，选出 k 个 盒子信息作为初始的簇点。</p><p>  这里采用的是高级索引，<code>boxes[[1,2,3]]==[boxes[1],boxes[2],boxes[3]]</code> ，<code>numpy.random.choice(a, size=None, replace=True, p=None)</code> 它的参数从左到右依次表示候选列表、抽烟个数、是否放回、列表中各元素被抽中的概率。</p></li><li><p>进行循环直到 break 才终止：</p><ul><li><p>计算boxes 中的每个盒子和每个簇的距离，结果存放入 <code>distances</code>， <code>self.iou(boxes, clusters)</code> 后面讲解。</p></li><li><p>通过 <code>np.argmin(distances, axis=1)</code> 返回每个盒子距离最近的簇的索引值，结果存入<code>current_nearest</code>；<code>np.argmin(a, axis=None, out=None)</code> 可以沿 <code>axis</code>轴，在数组 <code>a</code> 中寻找最小值，并返回该值在 <code>axis</code> 轴内的索引。</p></li><li><p>如果上一轮循环中每个盒子距离最近的簇的索引 <code>last_nearest</code> 和这一轮的 <code>current_nearest</code>  中每一个元素都相同，那么说明算法已经收敛，跳出循环。</p><p>  其中 <code>last_nearest == current_nearest</code> 由于双等号两边都是同型 np 数组，所以这个表达式返回的也是同型 np 数组，数组内元素类型是布尔型，表示对应元素是否相同，<code>np.np.array.all()</code> 表示若数组内元素都为 True 则返回 True，否则返回 False</p></li><li><p>如果存在不同元素，就对 K 个簇点进行遍历， 让每个簇点等于该簇内向量的中位数。</p><p>  通过<code>boxes[current_nearest == cluster]</code> 找出所有”相对于其他簇点，与第<code>cluster</code> 个簇距离最近”的盒子，得到一个列表，列表结构为<code>[[w1,h1],[w2,h2]...]</code></p><p>  通过 <code>dist</code> 即 <code>np.median</code> 对上述列表，沿第一个轴求中位数，最终得到结构为<code>[w,h]</code>的一维二元列表。</p></li><li><p>更新结束，把当前状态 <code>current_nearest</code>  赋值给 <code>last_nearest</code> 开始下一轮循环。</p></li></ul></li><li><p>循环结束，将簇点列表 <code>clusters</code> 返回，在 YOLO3 中，各簇点就是预设的锚框信息。</p></li></ul><h5 id="YOLO-Kmeans-txt2clusters"><a href="#YOLO-Kmeans-txt2clusters" class="headerlink" title="YOLO_Kmeans.txt2clusters"></a><code>YOLO_Kmeans.txt2clusters</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">txt2clusters</span><span class="params">(self)</span>:</span></span><br><span class="line">      = self.txt2boxes()</span><br><span class="line">    result = self.kmeans(all_boxes, k=self.cluster_number)</span><br><span class="line">    result = result[np.lexsort(result.T[<span class="number">0</span>, <span class="literal">None</span>])]</span><br><span class="line">    self.result2txt(result)</span><br><span class="line">    print(<span class="string">"K anchors:\n &#123;&#125;"</span>.format(result))</span><br><span class="line">    print(<span class="string">"Accuracy: &#123;:.2f&#125;%"</span>.format(</span><br><span class="line">    self.avg_iou(all_boxes, result) * <span class="number">100</span>))</span><br></pre></td></tr></table></figure><p><code>txt2clusters</code> 是脚本的执行函数，求kmeans就是从这个函数入手，这个函数主要过程就是：</p><ul><li><p><code>txt2boxes</code> 将文本信息划分并提取成列表信息 <code>all_boxes</code> , <code>all_boxes</code> 内各个盒子的信息，结构为 <code>[[w1,h1],[w2,h2]...]</code></p></li><li><p>使用 <code>kmeans</code> 求盒子列表的聚类，返回的是 k 个簇点，结构也为 <code>[[w1,h1],[w2,h2]...]</code> j结果保存到 <code>result</code></p></li><li><p>通过 <code>result[np.lexsort(result.T[0, None])]</code> 对 <code>result</code> 进行排序，排序规则是宽度小的在前面</p><p>  <code>result.T</code> 会对 <code>result</code> 转置，转置后结构为 <code>[[w1,...,wk],[h1...hk]]</code></p><p>  <code>result.T[0,None]</code> 是只取宽度数据，并且扩充一维，变成<code>[[w1,...,wk]]</code></p><p>  <code>lexsort(keys, axis=None)</code> ：返回一个整数数组（返回数组的元素是索引值）。<code>keys</code> 是一个序列的序列，要求内部序列形状相同，默认情况外部序列 <code>keys</code> 中的最后一个序列元素将作为主排序序列，倒数第二个序列元素作为第二排序序列….当主排序序列中元素大小相同时，就依照第二排序系列进行排序。</p><p>  <code>np.lexsort(result.T[0, None])</code> 输出结果是 <code>w1,...,wk</code> 依照升序排序后的顺序输出原索引值，是有 K 个元素的一维数组</p></li><li><p>使用 <code>result2txt</code> 将结果输出为文本文件</p></li><li><p>使用 <code>avg_iou</code> 评价聚类的结果</p></li></ul><h5 id="YOLO-Kmeans-result2txt"><a href="#YOLO-Kmeans-result2txt" class="headerlink" title="YOLO_Kmeans.result2txt"></a><code>YOLO_Kmeans.result2txt</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">result2txt</span><span class="params">(self, data)</span>:</span></span><br><span class="line">    f = open(<span class="string">"yolo_anchors.txt"</span>, <span class="string">'w'</span>)</span><br><span class="line">    row = np.shape(data)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            x_y = <span class="string">"%d,%d"</span> % (data[i][<span class="number">0</span>], data[i][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x_y = <span class="string">", %d,%d"</span> % (data[i][<span class="number">0</span>], data[i][<span class="number">1</span>])</span><br><span class="line">        f.write(x_y)</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure><p>将每一个簇点信息，写入 <code>yolo_anchors.txt</code> 文件，文件格式是：</p><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">w1</span></span>,h1 w2,h2 ... wk,hk</span><br></pre></td></tr></table></figure><h5 id="YOLO-Kmeans-avg-iou"><a href="#YOLO-Kmeans-avg-iou" class="headerlink" title="YOLO_Kmeans.avg_iou"></a><code>YOLO_Kmeans.avg_iou</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">avg_iou</span><span class="params">(self, boxes, clusters)</span>:</span></span><br><span class="line">    accuracy = np.mean([np.max(self.iou(boxes, clusters), axis=<span class="number">1</span>)])</span><br><span class="line">    <span class="keyword">return</span> accuracy</span><br></pre></td></tr></table></figure><p>用于评价聚类效果，这里的准确率是 n 个盒子的平均最大交并比。对于每个盒子来说，与盒子 IOU 最大的簇，一定是这个盒子所属的簇，所以 acc 可以理解为是 n 个盒子和它所属的簇的 IOU 的均值。acc 越大，说明簇分布的越好。</p><p>具体算法是</p><script type="math/tex; mode=display">Accuracy=\frac{\sum_{i=1}^n IOU_{max}(Box_i)}{n}</script><p>其中，</p><script type="math/tex; mode=display">IOU_{max}(Box_i)=\max_{i}\{ IOU(Box_i,C_j) \}</script><p>即 n 个盒子和 k 个簇进行 IOU 运算，对于每个盒子选择 IOU 最大的值作为代表，最终求 n 个 IOU 的均值作为准确率。</p><h4 id="实现函数"><a href="#实现函数" class="headerlink" title="实现函数"></a>实现函数</h4><p>在 <code>\kmeans.py</code> 文件中：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    cluster_number = <span class="number">9</span></span><br><span class="line">    filename = <span class="string">"2007_train.txt"</span></span><br><span class="line">    kmeans = YOLO_Kmeans(cluster_number, filename)</span><br><span class="line">    kmeans.txt2clusters()</span><br></pre></td></tr></table></figure><p>整体来说，这个脚本干了两件事，一个是求符合 YOLO 要求的 Kmeans，一个是把这个结果保存成文本。</p><h2 id="读入数据"><a href="#读入数据" class="headerlink" title="读入数据"></a>读入数据</h2><p>YOLO3 需要将训练数据载入后进行一些处理才能用于训练，这部分代码主要位于 <code>train.py</code> 文件。</p><h4 id="基础函数-1"><a href="#基础函数-1" class="headerlink" title="基础函数"></a>基础函数</h4><h5 id="get-random-data"><a href="#get-random-data" class="headerlink" title="get_random_data"></a><code>get_random_data</code></h5><p>在<code>yolo3\utils.py</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_random_data</span><span class="params">(annotation_line, input_shape, random=True, max_boxes=<span class="number">20</span>, jitter=<span class="number">.3</span>, hue=<span class="number">.1</span>, sat=<span class="number">1.5</span>, val=<span class="number">1.5</span>, proc_img=True)</span>:</span></span><br><span class="line">    <span class="string">'''为实现实时数据增强的随机预处理'''</span></span><br><span class="line">    line = annotation_line.split()</span><br><span class="line">    <span class="comment"># 打开图片</span></span><br><span class="line">    image = Image.open(line[<span class="number">0</span>])</span><br><span class="line">    iw, ih = image.size</span><br><span class="line">    h, w = input_shape</span><br><span class="line">    box = np.array([np.array(list(map(int,box.split(<span class="string">','</span>)))) <span class="keyword">for</span> box <span class="keyword">in</span> line[<span class="number">1</span>:]]) <span class="comment">#box = [[x_min,y_min,x_max,y_max,class_id],..]</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> random:</span><br><span class="line">        <span class="comment"># 调整图像尺寸,使其与input_shape一致</span></span><br><span class="line">        scale = min(w/iw, h/ih)</span><br><span class="line">        nw = int(iw*scale)</span><br><span class="line">        nh = int(ih*scale)</span><br><span class="line">        dx = (w-nw)//<span class="number">2</span></span><br><span class="line">        dy = (h-nh)//<span class="number">2</span></span><br><span class="line">        image_data=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> proc_img:</span><br><span class="line">            image = image.resize((nw,nh), Image.BICUBIC)</span><br><span class="line">            new_image = Image.new(<span class="string">'RGB'</span>, (w,h), (<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>))</span><br><span class="line">            new_image.paste(image, (dx, dy))</span><br><span class="line">            image_data = np.array(new_image)/<span class="number">255.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 修正 boxes</span></span><br><span class="line">        box_data = np.zeros((max_boxes,<span class="number">5</span>))</span><br><span class="line">        <span class="keyword">if</span> len(box)&gt;<span class="number">0</span>:</span><br><span class="line">            np.random.shuffle(box)</span><br><span class="line">            <span class="keyword">if</span> len(box)&gt;max_boxes: box = box[:max_boxes]</span><br><span class="line">            box[:, [<span class="number">0</span>,<span class="number">2</span>]] = box[:, [<span class="number">0</span>,<span class="number">2</span>]]*scale + dx</span><br><span class="line">            box[:, [<span class="number">1</span>,<span class="number">3</span>]] = box[:, [<span class="number">1</span>,<span class="number">3</span>]]*scale + dy</span><br><span class="line">            box_data[:len(box)] = box</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> image_data, box_data</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 随机调整图像长宽比，长宽比改变范围由 jitter 参数控制</span></span><br><span class="line">    new_ar = w/h * rand(<span class="number">1</span>-jitter,<span class="number">1</span>+jitter)/rand(<span class="number">1</span>-jitter,<span class="number">1</span>+jitter)</span><br><span class="line">    <span class="comment">#随机缩放图像，缩放范围为（0.25，2）</span></span><br><span class="line">    scale = rand(<span class="number">.25</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> new_ar &lt; <span class="number">1</span>:</span><br><span class="line">        nh = int(scale*h)</span><br><span class="line">        nw = int(nh*new_ar)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        nw = int(scale*w)</span><br><span class="line">        nh = int(nw/new_ar)</span><br><span class="line">    image = image.resize((nw,nh), Image.BICUBIC)</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="comment"># 图像随机平移</span></span><br><span class="line">    <span class="comment"># 调整图像尺寸,使其与input_shape一致，多的裁掉，少的用灰色填空</span></span><br><span class="line">    dx = int(rand(<span class="number">0</span>, w-nw))</span><br><span class="line">    dy = int(rand(<span class="number">0</span>, h-nh))</span><br><span class="line">    new_image = Image.new(<span class="string">'RGB'</span>, (w,h), (<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>))</span><br><span class="line">    new_image.paste(image, (dx, dy))</span><br><span class="line">    image = new_image</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 随机左右翻转，翻转概率 0.5</span></span><br><span class="line">    flip = rand()&lt;<span class="number">.5</span></span><br><span class="line">    <span class="keyword">if</span> flip: image = image.transpose(Image.FLIP_LEFT_RIGHT)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对图像的色调、饱和度、明度进行随机调整   </span></span><br><span class="line">    hue = rand(-hue, hue)</span><br><span class="line">    sat = rand(<span class="number">1</span>, sat) <span class="keyword">if</span> rand()&lt;<span class="number">.5</span> <span class="keyword">else</span> <span class="number">1</span>/rand(<span class="number">1</span>, sat) </span><br><span class="line">    val = rand(<span class="number">1</span>, val) <span class="keyword">if</span> rand()&lt;<span class="number">.5</span> <span class="keyword">else</span> <span class="number">1</span>/rand(<span class="number">1</span>, val)</span><br><span class="line">    <span class="comment"># HUE 色调; Saturation 饱和度; Value 明度</span></span><br><span class="line">    x = rgb_to_hsv(np.array(image)/<span class="number">255.</span>)</span><br><span class="line">    x[..., <span class="number">0</span>] += hue</span><br><span class="line">    x[..., <span class="number">0</span>][x[..., <span class="number">0</span>]&gt;<span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line">    x[..., <span class="number">0</span>][x[..., <span class="number">0</span>]&lt;<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">    x[..., <span class="number">1</span>] *= sat</span><br><span class="line">    x[..., <span class="number">2</span>] *= val</span><br><span class="line">    x[x&gt;<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    x[x&lt;<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    image_data = hsv_to_rgb(x) <span class="comment"># numpy array, 0 to 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修正盒子信息</span></span><br><span class="line">    box_data = np.zeros((max_boxes,<span class="number">5</span>))</span><br><span class="line">    <span class="keyword">if</span> len(box)&gt;<span class="number">0</span>:</span><br><span class="line">        np.random.shuffle(box)</span><br><span class="line">        <span class="comment"># box 缩放与位移</span></span><br><span class="line">        box[:, [<span class="number">0</span>,<span class="number">2</span>]] = box[:, [<span class="number">0</span>,<span class="number">2</span>]]*nw/iw + dx</span><br><span class="line">        box[:, [<span class="number">1</span>,<span class="number">3</span>]] = box[:, [<span class="number">1</span>,<span class="number">3</span>]]*nh/ih + dy</span><br><span class="line">        <span class="comment"># box 反转</span></span><br><span class="line">        <span class="keyword">if</span> flip: box[:, [<span class="number">0</span>,<span class="number">2</span>]] = w - box[:, [<span class="number">2</span>,<span class="number">0</span>]]</span><br><span class="line">        <span class="comment"># box 截掉超出边界的</span></span><br><span class="line">        box[:, <span class="number">0</span>:<span class="number">2</span>][box[:, <span class="number">0</span>:<span class="number">2</span>]&lt;<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        box[:, <span class="number">2</span>][box[:, <span class="number">2</span>]&gt;w] = w</span><br><span class="line">        box[:, <span class="number">3</span>][box[:, <span class="number">3</span>]&gt;h] = h</span><br><span class="line">        <span class="comment"># box 丢弃过小的</span></span><br><span class="line">        box_w = box[:, <span class="number">2</span>] - box[:, <span class="number">0</span>]</span><br><span class="line">        box_h = box[:, <span class="number">3</span>] - box[:, <span class="number">1</span>]</span><br><span class="line">        box = box[np.logical_and(box_w&gt;<span class="number">1</span>, box_h&gt;<span class="number">1</span>)] <span class="comment"># discard invalid box</span></span><br><span class="line">        <span class="keyword">if</span> len(box)&gt;max_boxes: box = box[:max_boxes]</span><br><span class="line">        box_data[:len(box)] = box</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> image_data, box_data</span><br></pre></td></tr></table></figure><p><code>get_random_data</code> 函数用于从 YOLO3 的标注文件生成训练所需的图像信息，同时还提供了对图像的随机数据增强。具体实现看注释吧。</p><p>参数：</p><ul><li><strong>annotation_line</strong>：标注文件中某一行的文本信息，通过这一行文本来获取图片路径和盒子信息。</li><li><strong>input_shape</strong>：指网络的输入尺寸，最终图像会被调整到这个尺寸</li><li><strong>random=True</strong>：是否开启随机数据增强，默认开启，如果不开启就是单纯的缩放个尺寸</li><li><strong>max_boxes=20</strong>：最大盒子数，默认20</li><li><strong>jitter=.3</strong>：开启随机数据增强时，这个参数影响长宽比变化范围</li><li><strong>hue=.1</strong>：开启随机数据增强时，这个参数影响色调变化范围</li><li><strong>sat=1.5</strong>：开启随机数据增强时，这个参数影响饱和度变化范围</li><li><strong>val=1.5</strong>：开启随机数据增强时，这个参数影响明度变化范围</li><li><strong>proc_img=True</strong>：没整明白存在的意义，True 就完事了</li></ul><p>返回值：</p><ul><li>返回一个元组，<code>(image_data, box_data)</code></li><li><code>image_data</code> 形如 <code>(h,w,3)</code>，值域 0 到 1</li><li><code>box_data</code> 二维数组，结构类似 <code>[[x_min,y_min,x_max,y_max,class_id],..]</code>，它的形状为 <code>shape=(max_boxes,5)</code>，5 是指相对于输入尺寸的绝对坐标 <code>x_min, y_min, x_max, y_max,</code> 和类别号  <code>class_id</code></li></ul><h5 id="preprocess-true-boxes"><a href="#preprocess-true-boxes" class="headerlink" title="preprocess_true_boxes"></a><code>preprocess_true_boxes</code></h5><p>在<code>yolo3\model.py</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess_true_boxes</span><span class="params">(true_boxes, input_shape, anchors, num_classes)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> (true_boxes[..., <span class="number">4</span>]&lt;num_classes).all(), <span class="string">'class id must be less than num_classes'</span></span><br><span class="line">    num_layers = len(anchors)//<span class="number">3</span> <span class="comment"># default setting</span></span><br><span class="line">    anchor_mask = [[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]] <span class="keyword">if</span> num_layers==<span class="number">3</span> <span class="keyword">else</span> [[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line">    true_boxes = np.array(true_boxes, dtype=<span class="string">'float32'</span>)</span><br><span class="line">    input_shape = np.array(input_shape, dtype=<span class="string">'int32'</span>)</span><br><span class="line">    boxes_xy = (true_boxes[..., <span class="number">0</span>:<span class="number">2</span>] + true_boxes[..., <span class="number">2</span>:<span class="number">4</span>]) // <span class="number">2</span></span><br><span class="line">    boxes_wh = true_boxes[..., <span class="number">2</span>:<span class="number">4</span>] - true_boxes[..., <span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    true_boxes[..., <span class="number">0</span>:<span class="number">2</span>] = boxes_xy/input_shape[::<span class="number">-1</span>]</span><br><span class="line">    true_boxes[..., <span class="number">2</span>:<span class="number">4</span>] = boxes_wh/input_shape[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    m = true_boxes.shape[<span class="number">0</span>]</span><br><span class="line">    grid_shapes = [input_shape//&#123;<span class="number">0</span>:<span class="number">32</span>, <span class="number">1</span>:<span class="number">16</span>, <span class="number">2</span>:<span class="number">8</span>&#125;[l] <span class="keyword">for</span> l <span class="keyword">in</span> range(num_layers)]</span><br><span class="line">    y_true = [np.zeros((m,grid_shapes[l][<span class="number">0</span>],grid_shapes[l][<span class="number">1</span>],len(anchor_mask[l]),<span class="number">5</span>+num_classes),</span><br><span class="line">        dtype=<span class="string">'float32'</span>) <span class="keyword">for</span> l <span class="keyword">in</span> range(num_layers)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Expand dim to apply broadcasting.</span></span><br><span class="line">    anchors = np.expand_dims(anchors, <span class="number">0</span>)</span><br><span class="line">    anchor_maxes = anchors / <span class="number">2.</span></span><br><span class="line">    anchor_mins = -anchor_maxes</span><br><span class="line">    valid_mask = boxes_wh[..., <span class="number">0</span>]&gt;<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="comment"># Discard zero rows.</span></span><br><span class="line">        wh = boxes_wh[b, valid_mask[b]]</span><br><span class="line">        <span class="keyword">if</span> len(wh)==<span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># Expand dim to apply broadcasting.</span></span><br><span class="line">        wh = np.expand_dims(wh, <span class="number">-2</span>)</span><br><span class="line">        box_maxes = wh / <span class="number">2.</span></span><br><span class="line">        box_mins = -box_maxes</span><br><span class="line"></span><br><span class="line">        intersect_mins = np.maximum(box_mins, anchor_mins)</span><br><span class="line">        intersect_maxes = np.minimum(box_maxes, anchor_maxes)</span><br><span class="line">        intersect_wh = np.maximum(intersect_maxes - intersect_mins, <span class="number">0.</span>)</span><br><span class="line">        intersect_area = intersect_wh[..., <span class="number">0</span>] * intersect_wh[..., <span class="number">1</span>]</span><br><span class="line">        box_area = wh[..., <span class="number">0</span>] * wh[..., <span class="number">1</span>]</span><br><span class="line">        anchor_area = anchors[..., <span class="number">0</span>] * anchors[..., <span class="number">1</span>]</span><br><span class="line">        iou = intersect_area / (box_area + anchor_area - intersect_area)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Find best anchor for each true box</span></span><br><span class="line">        best_anchor = np.argmax(iou, axis=<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> t, n <span class="keyword">in</span> enumerate(best_anchor):</span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> range(num_layers):</span><br><span class="line">                <span class="keyword">if</span> n <span class="keyword">in</span> anchor_mask[l]:</span><br><span class="line">                    i = np.floor(true_boxes[b,t,<span class="number">0</span>]*grid_shapes[l][<span class="number">1</span>]).astype(<span class="string">'int32'</span>)</span><br><span class="line">                    j = np.floor(true_boxes[b,t,<span class="number">1</span>]*grid_shapes[l][<span class="number">0</span>]).astype(<span class="string">'int32'</span>)</span><br><span class="line">                    k = anchor_mask[l].index(n)</span><br><span class="line">                    c = true_boxes[b,t, <span class="number">4</span>].astype(<span class="string">'int32'</span>)</span><br><span class="line">                    y_true[l][b, j, i, k, <span class="number">0</span>:<span class="number">4</span>] = true_boxes[b,t, <span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">                    y_true[l][b, j, i, k, <span class="number">4</span>] = <span class="number">1</span></span><br><span class="line">                    y_true[l][b, j, i, k, <span class="number">5</span>+c] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y_true</span><br></pre></td></tr></table></figure><p>该函数用于将真实盒子信息转化成训练所需要的格式。</p><p>参数：</p><ul><li><strong>true_boxes</strong>: 多维数组，要求形状为 <code>(batch_size,boxes_number,5)</code> 由 <code>get_random_data</code> 生成</li><li><strong>input_shape</strong>: 网络的输入尺寸应该是32的倍数，注意这里的尺寸是 <strong>高在前、宽在后</strong></li><li><strong>anchors</strong>: 锚框，形状为<code>(k,2)</code> k是锚框个数; 2 是<code>(w,h)</code></li><li><strong>num_classes</strong>: 整型,总类别数</li></ul><p>返回：</p><ul><li><strong>y_true</strong> ：和 yolo3 网络输出的数据同型的数组，此时的 wxyh 已经换为相对路径</li></ul><p>执行过程：</p><ul><li><p>计算 YOLO3 网络输出的特征图数目，这里认为输出的特征图数目与锚框数目有关，经典 YOLO3 输出三个特征图，每个特征图 3 个锚框，共 9 个。tiny-YOLO 则输出 2 个特征图，每个特征图 3 个锚框，所以可由锚框数目求 YOLO3 输出的特征图数目，并分辨网络类型。其中：</p><ul><li><code>num_layers</code> 表示输出特征图数目</li><li><p><code>anchor_mask</code> 是锚框掩码，用于规定每个特征图用哪几个锚框</p><p>之后均以 <strong>YOLO3 输出三个特征图，每个特征图 3 个锚框</strong> 为例。</p></li></ul></li><li><p>对于参数 <code>true_boxes</code> 和 <code>input_shape</code> 进行类型转换</p></li><li><p>求出每个盒子的中心点坐标 <code>boxes_xy</code> 与宽高信息 <code>boxes_wh</code> 这两个参数形状为 <code>(batch_size,boxes_number,2)</code> </p></li><li><p>对  <code>true_boxes</code>  中的位置和宽高进行修改，将其改为相对于原图的比例数值，称新的 <code>true_boxes[..., 0:4]</code> 为<strong>最小横坐标比例、最小纵坐标比例、最大横坐标比例、最大纵坐标比例</strong></p></li><li><p>求 <code>grid_shapes</code> ,  <code>grid_shapes</code> 表示每个输出的特征图的两个方向各自分布多少网格。对于最终输出的特诊图而言，特征图上的一个点对应原图的一个区域，这个区域被称为网格，所以可以理解为这个变量表示的是输出的每个特征图的宽和高，经典 YOLO3 输出三个特征图，每个特征图大小别为原图宽高分别除 32、原图宽高分别除 16 、原图宽高分别除 8，最终 <code>grid_shapes</code> 的结构是 np 数组的列表：<br>  <code>[np.array([f1_w,f1_h]),np.array([f2_w,f2_h]),np.array([f3_w,f3_h])]</code> ，其中 <code>f1_w,f1_h</code> 表示最终输出的特征图里第一个特征图的宽和高。</p></li><li><p>创建 <code>y_true</code> ，此时只是先把 <code>y_true</code> 的结构定下来，其值用 0 填充，具体数值后面再填，<code>y_true</code> 的结构也是 np 数组的列表 ，它的结构为 <code>[y_true_1,y_true_2,y_true_3]</code> 。其中 <code>y_true_*</code> 是 np 数组，表示一个特征图中包含的真实信息，它的<code>shape=(批数,特征图高,特征图宽,3,5+类别数)</code></p></li><li><p>之后的代码是针对每批数据而言，故之后的代码 <strong>假设处理下标为 <code>b</code> 的一批数据</strong></p></li><li><p>对 <code>b</code>  批数据的对每个盒子对预设的锚框进行 IOU 运算，这里是假设中心点重合的 IOU，最终目的是求 <code>best_anchor</code> 。<code>best_anchor</code> 表示对于每个盒子而言，参数 <code>anchors</code> 里的哪个锚框和这个盒子重合度最高，它的 <code>shape=(valid_boxes_number,)</code> ，即长度为<code>valid_boxes_number</code> 的向量，其中 <code>valid_boxes_number</code> 为有效盒子数，有效盒子被定义为宽度大于 0 的盒子。</p><blockquote><p>这里的实现有个细节，就是 <code>anchors</code> 被扩充维度成 <code>shape=(1,k,2)</code> 而<code>wh</code>被扩充维度为 <code>shape=(boxes_number,1,2)</code> 所以最终他们的运算结果由 <code>broadcasting</code> 变成 <code>shape=(boxes_number,k,2)</code></p></blockquote></li><li><p>之后是一个二层循环，分别表示遍历<code>best_anchor</code>，遍历每个输出特征图，变量 <code>b,t,n,l</code>  都是索引号，分别表示：<strong>第 b 号批  、第 t 号盒子 、第t 号盒子的最大重合 anchor 索引号为 n 、第 l 号特征图</strong></p></li><li><p>如果第 t 号盒子的最大索引号 n，在第 l 号特征图的锚框掩码中，则说明，第l 号特征图内有锚框负责这个盒子，此时：</p><ul><li><p>令 <code>i</code> 等于第 b 号批里第 t 号盒子的最大横坐标比例*第 l 号特征图的宽，并向下取整</p></li><li><p>令 <code>j</code> 等于第 b 号批里第 t 号盒子的最小纵坐标比例*第 l 号特征图的高，并向下取整</p><blockquote><p>此时 <code>j,i</code> 表示第 l 号特征图中，负责这个物体的网格坐标。</p></blockquote></li><li><p>令 <code>k</code> 等于第 n 号锚框在第 l 号特征的索引号，<code>k</code> 只能取 0,1,2</p></li><li><p>令 <code>c</code> 等于第 b 号批里第 t 号盒子的类别号</p></li><li><p>最后填充，第 l 号特征图中的，第 b 号批数据里，第 j 行 、第 i 列，第 k 号锚框，使其坐标信息等于 b 号批里第 t 号盒子的坐标信息、置信度等于 1、类别信息等于 c （即令 <code>y_true[l][..,5+c] = 1</code> )</p></li></ul></li><li><p>上述过程把 <code>y_true</code> 该填的完，负责物体的锚框有对应值，不负责物体的锚框的值为 0，最后强调，<code>y_true</code> 是一个三元素列表，每个元素的 <code>shape=(批数,特征图高,特征图宽,3,5+类别数)</code> ，每个元素的元素可视为长度为 <code>5+类别数</code> 的特征向量，特征向量中的位置信息是<strong>相对于原图</strong>的最小横坐标比例、最小纵坐标比例、最大横坐标比例、最大纵坐标比例。</p></li></ul><h4 id="实现函数-1"><a href="#实现函数-1" class="headerlink" title="实现函数"></a>实现函数</h4><p>训练数据是由 <code>data_generator_wrapper</code> 生成：</p><h5 id="data-generator-wrapper"><a href="#data-generator-wrapper" class="headerlink" title="data_generator_wrapper"></a><code>data_generator_wrapper</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_generator_wrapper(annotation_lines, batch_size, input_shape, anchors, num_classes):</span><br><span class="line">    n = len(annotation_lines)</span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span> <span class="keyword">or</span> batch_size&lt;=<span class="number">0</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> data_generator(annotation_lines, batch_size, input_shape, anchors, num_classes)</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><strong>annotation_lines</strong>：yolo3 标注文件的行数，也就是总训练样本数</li><li><strong>batch_size</strong> ：批大小</li><li><strong>input_shape</strong> ：二维元组，输入张量的形状，要求32的倍数，YOLO3 设置为 (416,416)</li><li><strong>anchors</strong> ：锚框列表，<code>get_anchors</code> 函数得到，形如<code>[[w1,h1],[w2,h2]...]</code></li><li><strong>num_classes</strong> ：类别数目，由 <code>len(get_classes(classes_path))</code> 得到</li></ul><p><code>data_generator_wrapper</code> 只是对参数进行简单的检验，最终数据由 <code>data_generator</code> 生成</p><h5 id="data-generator"><a href="#data-generator" class="headerlink" title="data_generator"></a><code>data_generator</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_generator</span><span class="params">(annotation_lines, batch_size, input_shape, anchors, num_classes)</span>:</span></span><br><span class="line">    <span class="string">'''data generator for fit_generator'''</span></span><br><span class="line">    n = len(annotation_lines)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        image_data = []</span><br><span class="line">        box_data = []</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> range(batch_size):</span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">0</span>:</span><br><span class="line">                np.random.shuffle(annotation_lines)</span><br><span class="line">            image, box = get_random_data(annotation_lines[i], input_shape, random=<span class="literal">True</span>)</span><br><span class="line">            image_data.append(image)</span><br><span class="line">            box_data.append(box)</span><br><span class="line">            i = (i+<span class="number">1</span>) % n</span><br><span class="line">        image_data = np.array(image_data)</span><br><span class="line">        box_data = np.array(box_data)</span><br><span class="line">        y_true = preprocess_true_boxes(box_data, input_shape, anchors, num_classes)</span><br><span class="line">        <span class="keyword">yield</span> [image_data, *y_true], np.zeros(batch_size)</span><br></pre></td></tr></table></figure><p><code>data_generator</code> 是一个生成器，所以用 <code>yield</code> 替代 <code>return</code> ，这生成器直接作用于 <code>model.fit_generator</code> ，所以生成器生成的数据，就是每一<code>epoch</code> 训练的数据。</p><p>生成器的参数和 <code>data_generator_wrapper</code> 参数一致。</p><p><code>model.fit_generator</code> 要求 <code>data_generator</code>  返回一个下面任意一个元组：</p><ul><li>a tuple <code>(inputs, targets)</code></li><li>a tuple <code>(inputs, targets, sample_weights)</code></li></ul><p>这里 <code>data_generator</code>   返回的是 <code>(inputs, targets)</code> 它的 inputs 是 <code>[image_data, *y_true]</code> , 它的 targets 是长为 <code>batch_size</code> 的全 0 向量。</p><p>执行过程：</p><ul><li>统计样本总数 <code>n = len(annotation_lines)</code> , 设置计数变量 <code>i = 0</code> </li><li>通过 while-yield 结构设计生成器 </li><li>每次生成数据的时候 , 执行 <code>batch_size</code> 次循环<ul><li>如果 <code>i==0</code> 说明第一次生成数据 , 或者所有样本都已经被生成一遍了 , 此时用 <code>np.random.shuffle(annotation_lines)</code> 将样本打乱</li><li>通过 <code>get_random_data(annotation_lines[i], input_shape, random=True)</code> 获得第 i 个样本的图片信息和图片上的盒子信息 <code>image, box</code></li><li>将图片信息和标注信息分布追加到<code>image_data, box_data</code></li><li><code>i = (i+1) % n</code> 表示该读下一个样本了</li></ul></li><li>将 <code>image_data, box_data</code> 包装为 np 数据</li><li>通过 <code>preprocess_true_boxes(box_data, input_shape, anchors, num_classes)</code> 由盒子信息获取 loss 函数所需的目标信息 <code>y_true</code></li><li>返回 <code>[image_data, *y_true], np.zeros(batch_size)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> YOLO3 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> YOLO3 </tag>
            
            <tag> Keras </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YOLO3 目标检测与性能评价 Keras源码分析</title>
      <link href="/2020/04/04/YOLO3%20%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2020/04/04/YOLO3%20%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7%20Keras%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-YOLO3"><a href="#使用-YOLO3" class="headerlink" title="使用 YOLO3"></a>使用 YOLO3</h2><h3 id="配置-yolo-py"><a href="#配置-yolo-py" class="headerlink" title="配置 yolo.py"></a>配置 yolo.py</h3><p>修改 <code>yolo.py</code> 的 <code>_defaults</code>，主要是把自己训练好的权重文件路径、锚框文件路径、类别文件路径配置上。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_defaults = &#123;</span><br><span class="line">      <span class="string">"model_path"</span>: <span class="string">'trained_weights_final.h5'</span>,</span><br><span class="line">      <span class="string">"anchors_path"</span>: <span class="string">'yolo_anchors.txt'</span>,</span><br><span class="line">      <span class="string">"classes_path"</span>: <span class="string">'voc_classes.txt'</span>,</span><br><span class="line">      <span class="string">"score"</span> : <span class="number">0.3</span>,</span><br><span class="line">      <span class="string">"iou"</span> : <span class="number">0.45</span>,</span><br><span class="line">      <span class="string">"model_image_size"</span> : (<span class="number">416</span>, <span class="number">416</span>),</span><br><span class="line">      <span class="string">"gpu_num"</span> : <span class="number">1</span>,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="运行-yolo-video-py"><a href="#运行-yolo-video-py" class="headerlink" title="运行 yolo_video.py"></a>运行 yolo_video.py</h3><p><code>python yolo_video.py --image</code> 对单张图片进行测试，<code>python yolo_video.py --video</code> 对视频进行测试。</p><a id="more"></a><h3 id="图片检测源码分析"><a href="#图片检测源码分析" class="headerlink" title="图片检测源码分析"></a>图片检测源码分析</h3><h4 id="基础函数"><a href="#基础函数" class="headerlink" title="基础函数"></a>基础函数</h4><h5 id="letterbox-image"><a href="#letterbox-image" class="headerlink" title="letterbox_image"></a><code>letterbox_image</code></h5><p>位于 <code>\utils.py</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">letterbox_image</span><span class="params">(image, size)</span>:</span></span><br><span class="line">    <span class="string">'''resize image with unchanged aspect ratio using padding'''</span></span><br><span class="line">    iw, ih = image.size</span><br><span class="line">    w, h = size</span><br><span class="line">    scale = min(w/iw, h/ih)</span><br><span class="line">    nw = int(iw*scale)</span><br><span class="line">    nh = int(ih*scale)</span><br><span class="line"></span><br><span class="line">    image = image.resize((nw,nh), Image.BICUBIC)</span><br><span class="line">    new_image = Image.new(<span class="string">'RGB'</span>, size, (<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>))</span><br><span class="line">    new_image.paste(image, ((w-nw)//<span class="number">2</span>, (h-nh)//<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> new_image</span><br></pre></td></tr></table></figure><p>使用填充调整图像大小，保持纵横比不变 </p><p>参数：</p><ul><li>image： <code>Image</code> 对象</li><li>size：目标大小。</li></ul><p>返回：</p><ul><li>返回已经调整过大小的新的 <code>Image</code> 对象</li></ul><p>执行过程：</p><ul><li>获取原图的宽和高，<code>iw, ih</code></li><li>获取目标的宽和高，<code>w, h</code></li><li>取 <code>w/iw, h/ih</code> 中最小的比例作为缩放比例 <code>scale</code> </li><li>按照缩放比例计算新的宽和高，<code>nw = iw*scale, nh=ih*scale</code></li><li>将 <code>Image</code> 对象按照新的宽高进行调整，仍命名为 <code>image</code></li><li>创建一个尺寸为 <code>size</code> 颜色为灰色的  <code>Image</code> 对象，命名为 <code>new_image</code></li><li>将 <code>image</code> 贴到 <code>new_image</code>  中间</li><li>返回 <code>new_image</code></li></ul><h5 id="YOLO-init-self-kwargs"><a href="#YOLO-init-self-kwargs" class="headerlink" title="YOLO.__init__(self, **kwargs)"></a><code>YOLO.__init__(self, **kwargs)</code></h5><p>位于 <code>\yolo.py</code></p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">def __init__(self, **kwargs):</span><br><span class="line">    self.__dict__.update(self._defaults) # <span class="builtin-name">set</span> up<span class="built_in"> default </span>values</span><br><span class="line">    self.__dict__.update(kwargs) # <span class="keyword">and</span> update with<span class="built_in"> user </span>overrides</span><br><span class="line">    self.class_names = self._get_class()</span><br><span class="line">    self.anchors = self._get_anchors()</span><br><span class="line">    self.sess = K.get_session()</span><br><span class="line">    self.boxes, self.scores, self.classes = self.generate()</span><br></pre></td></tr></table></figure><p>YOLO 类的初始化，主要完成以下任务：</p><ul><li>通过 <code>self._get_anchors()</code> 获得类别名</li><li>通过 <code>self._get_anchors()</code> 获取锚框数组，并记为 <code>self.anchors</code></li><li>通过 <code>K.get_session()</code> 获得 session，记为 <code>self.sess</code></li><li>通过 <code>self.generate()</code> 得到 <code>self.boxes, self.scores, self.classes</code>，这一步并不会得到具体的值，只是在 YOLO 网络模型的运算图后衔接 <code>yolo_eval</code> 定义的运算图。</li></ul><h5 id="YOLO-get-class"><a href="#YOLO-get-class" class="headerlink" title="YOLO._get_class()"></a><code>YOLO._get_class()</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_class</span><span class="params">(self)</span>:</span></span><br><span class="line">    classes_path = os.path.expanduser(self.classes_path)</span><br><span class="line">    <span class="keyword">with</span> open(classes_path) <span class="keyword">as</span> f:</span><br><span class="line">        class_names = f.readlines()</span><br><span class="line">    class_names = [c.strip() <span class="keyword">for</span> c <span class="keyword">in</span> class_names]</span><br><span class="line">    <span class="keyword">return</span> class_names</span><br></pre></td></tr></table></figure><ul><li>通过 <code>self.classes_path</code> 的路径，读取类别文件，获得类别名数组</li></ul><h5 id="YOLO-get-anchors"><a href="#YOLO-get-anchors" class="headerlink" title="YOLO._get_anchors()"></a><code>YOLO._get_anchors()</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_anchors</span><span class="params">(self)</span>:</span></span><br><span class="line">    anchors_path = os.path.expanduser(self.anchors_path)</span><br><span class="line">    <span class="keyword">with</span> open(anchors_path) <span class="keyword">as</span> f:</span><br><span class="line">        anchors = f.readline()</span><br><span class="line">    anchors = [float(x) <span class="keyword">for</span> x <span class="keyword">in</span> anchors.split(<span class="string">','</span>)]</span><br><span class="line">    <span class="keyword">return</span> np.array(anchors).reshape(<span class="number">-1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li>通过 <code>self.anchors_path)</code> 路径，读取锚框文件，获得锚框数组</li></ul><h5 id="YOLO-generate"><a href="#YOLO-generate" class="headerlink" title="YOLO.generate()"></a><code>YOLO.generate()</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self)</span>:</span></span><br><span class="line">    model_path = os.path.expanduser(self.model_path)</span><br><span class="line">    <span class="keyword">assert</span> model_path.endswith(<span class="string">'.h5'</span>), <span class="string">'Keras model or weights must be a .h5 file.'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load model, or construct model and load weights.</span></span><br><span class="line">    num_anchors = len(self.anchors)</span><br><span class="line">    num_classes = len(self.class_names)</span><br><span class="line">    is_tiny_version = num_anchors==<span class="number">6</span> <span class="comment"># default setting</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        self.yolo_model = load_model(model_path, compile=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        self.yolo_model = tiny_yolo_body(Input(shape=(<span class="literal">None</span>,<span class="literal">None</span>,<span class="number">3</span>)), num_anchors//<span class="number">2</span>, num_classes) \</span><br><span class="line">            <span class="keyword">if</span> is_tiny_version <span class="keyword">else</span> yolo_body(Input(shape=(<span class="literal">None</span>,<span class="literal">None</span>,<span class="number">3</span>)), num_anchors//<span class="number">3</span>, num_classes)</span><br><span class="line">        self.yolo_model.load_weights(self.model_path) <span class="comment"># make sure model, anchors and classes match</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">assert</span> self.yolo_model.layers[<span class="number">-1</span>].output_shape[<span class="number">-1</span>] == \</span><br><span class="line">            num_anchors/len(self.yolo_model.output) * (num_classes + <span class="number">5</span>), \</span><br><span class="line">            <span class="string">'Mismatch between model and given anchor and class sizes'</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">'&#123;&#125; model, anchors, and classes loaded.'</span>.format(model_path))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Generate colors for drawing bounding boxes.</span></span><br><span class="line">    hsv_tuples = [(x / len(self.class_names), <span class="number">1.</span>, <span class="number">1.</span>)</span><br><span class="line">                    <span class="keyword">for</span> x <span class="keyword">in</span> range(len(self.class_names))]</span><br><span class="line">    self.colors = list(map(<span class="keyword">lambda</span> x: colorsys.hsv_to_rgb(*x), hsv_tuples))</span><br><span class="line">    self.colors = list(</span><br><span class="line">        map(<span class="keyword">lambda</span> x: (int(x[<span class="number">0</span>] * <span class="number">255</span>), int(x[<span class="number">1</span>] * <span class="number">255</span>), int(x[<span class="number">2</span>] * <span class="number">255</span>)),</span><br><span class="line">            self.colors))</span><br><span class="line">    np.random.seed(<span class="number">10101</span>)  <span class="comment"># Fixed seed for consistent colors across runs.</span></span><br><span class="line">    np.random.shuffle(self.colors)  <span class="comment"># Shuffle colors to decorrelate adjacent classes.</span></span><br><span class="line">    np.random.seed(<span class="literal">None</span>)  <span class="comment"># Reset seed to default.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Generate output tensor targets for filtered bounding boxes.</span></span><br><span class="line">    self.input_image_shape = K.placeholder(shape=(<span class="number">2</span>, ))</span><br><span class="line">    <span class="keyword">if</span> self.gpu_num&gt;=<span class="number">2</span>:</span><br><span class="line">        self.yolo_model = multi_gpu_model(self.yolo_model, gpus=self.gpu_num)</span><br><span class="line">    boxes, scores, classes = yolo_eval(self.yolo_model.output, self.anchors,</span><br><span class="line">            len(self.class_names), self.input_image_shape,</span><br><span class="line">            score_threshold=self.score, iou_threshold=self.iou)</span><br><span class="line">    <span class="keyword">return</span> boxes, scores, classes</span><br></pre></td></tr></table></figure><p><code>generate()</code> 函数主要干了三件事，加载模型、生成类别颜色框，完善模型的运算图。</p><p>执行过程：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model_path = os.path.expanduser(self.model_path)</span><br><span class="line"><span class="keyword">assert</span> model_path.endswith(<span class="string">'.h5'</span>), <span class="string">'Keras model or weights must be a .h5 file.'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load model, or construct model and load weights.</span></span><br><span class="line">num_anchors = len(self.anchors)</span><br><span class="line">num_classes = len(self.class_names)</span><br><span class="line">is_tiny_version = num_anchors==<span class="number">6</span> <span class="comment"># default setting</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">self.yolo_model = load_model(model_path, compile=<span class="literal">False</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    self.yolo_model = tiny_yolo_body(Input(shape=(<span class="literal">None</span>,<span class="literal">None</span>,<span class="number">3</span>)), num_anchors//<span class="number">2</span>, num_classes) \</span><br><span class="line">    <span class="keyword">if</span> is_tiny_version <span class="keyword">else</span> yolo_body(Input(shape=(<span class="literal">None</span>,<span class="literal">None</span>,<span class="number">3</span>)), num_anchors//<span class="number">3</span>, num_classes)</span><br><span class="line">    self.yolo_model.load_weights(self.model_path) <span class="comment"># make sure model, anchors and classes match</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">assert</span> self.yolo_model.layers[<span class="number">-1</span>].output_shape[<span class="number">-1</span>] == \</span><br><span class="line">    num_anchors/len(self.yolo_model.output) * (num_classes + <span class="number">5</span>), \</span><br><span class="line">    <span class="string">'Mismatch between model and given anchor and class sizes'</span></span><br></pre></td></tr></table></figure><ul><li>通过锚框数目判断是否为 tiny 版本</li><li>尝试直接加载模型，如果 .h5 文件本身带有模型结构的话。</li><li>如果 .h5 文件本身不带有模型结构，就先根据是否是 tiny 版本，创造对应的模型，然后再加载权重</li><li>最终 <code>self.yolo_model</code> 储存着 yolo3 的模型</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Generate colors for drawing bounding boxes.</span></span><br><span class="line">hsv_tuples = [(x / len(self.class_names), <span class="number">1.</span>, <span class="number">1.</span>)</span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> range(len(self.class_names))]</span><br><span class="line">self.colors = list(map(<span class="keyword">lambda</span> x: colorsys.hsv_to_rgb(*x), hsv_tuples))</span><br><span class="line">self.colors = list(</span><br><span class="line">    map(<span class="keyword">lambda</span> x: (int(x[<span class="number">0</span>] * <span class="number">255</span>), int(x[<span class="number">1</span>] * <span class="number">255</span>), int(x[<span class="number">2</span>] * <span class="number">255</span>)),</span><br><span class="line">        self.colors))</span><br><span class="line">np.random.seed(<span class="number">10101</span>)  <span class="comment"># Fixed seed for consistent colors across runs.</span></span><br><span class="line">np.random.shuffle(self.colors)  <span class="comment"># Shuffle colors to decorrelate adjacent classes.</span></span><br><span class="line">np.random.seed(<span class="literal">None</span>)  <span class="comment"># Reset seed to default.</span></span><br></pre></td></tr></table></figure><ul><li>随机生成不同类别的预测框的颜色</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Generate output tensor targets for filtered bounding boxes.</span></span><br><span class="line">self.input_image_shape = K.placeholder(shape=(<span class="number">2</span>, ))</span><br><span class="line"><span class="keyword">if</span> self.gpu_num&gt;=<span class="number">2</span>:</span><br><span class="line">    self.yolo_model = multi_gpu_model(self.yolo_model, gpus=self.gpu_num)</span><br><span class="line">boxes, scores, classes = yolo_eval(self.yolo_model.output, self.anchors,</span><br><span class="line">        len(self.class_names), self.input_image_shape,</span><br><span class="line">        score_threshold=self.score, iou_threshold=self.iou)</span><br><span class="line"><span class="keyword">return</span> boxes, scores, classes</span><br></pre></td></tr></table></figure><ul><li>判断 GPU 数目，如果 GPU 数目大于 2 则将模型升级为多 GPU 模型</li><li>在 <code>self.yolo_model.output</code> 衔接 <code>yolo_eval</code> 定义的运算图， 通过 <code>yolo_eval</code>  可过滤大部分无效的预测框。</li></ul><h5 id="yolo-eval"><a href="#yolo-eval" class="headerlink" title="yolo_eval()"></a><code>yolo_eval()</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">yolo_eval</span><span class="params">(yolo_outputs,</span></span></span><br><span class="line"><span class="function"><span class="params">              anchors,</span></span></span><br><span class="line"><span class="function"><span class="params">              num_classes,</span></span></span><br><span class="line"><span class="function"><span class="params">              image_shape,</span></span></span><br><span class="line"><span class="function"><span class="params">              max_boxes=<span class="number">20</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              score_threshold=<span class="number">.6</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">              iou_threshold=<span class="number">.5</span>)</span>:</span></span><br><span class="line">    <span class="string">"""Evaluate YOLO model on given input and return filtered boxes."""</span></span><br><span class="line">    num_layers = len(yolo_outputs)</span><br><span class="line">    anchor_mask = [[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]] <span class="keyword">if</span> num_layers==<span class="number">3</span> <span class="keyword">else</span> [[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]] <span class="comment"># default setting</span></span><br><span class="line">    input_shape = K.shape(yolo_outputs[<span class="number">0</span>])[<span class="number">1</span>:<span class="number">3</span>] * <span class="number">32</span></span><br><span class="line">    boxes = []</span><br><span class="line">    box_scores = []</span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> range(num_layers):</span><br><span class="line">        _boxes, _box_scores = yolo_boxes_and_scores(yolo_outputs[l],</span><br><span class="line">            anchors[anchor_mask[l]], num_classes, input_shape, image_shape)</span><br><span class="line">        boxes.append(_boxes)</span><br><span class="line">        box_scores.append(_box_scores)</span><br><span class="line">    boxes = K.concatenate(boxes, axis=<span class="number">0</span>)</span><br><span class="line">    box_scores = K.concatenate(box_scores, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    mask = box_scores &gt;= score_threshold</span><br><span class="line">    max_boxes_tensor = K.constant(max_boxes, dtype=<span class="string">'int32'</span>)</span><br><span class="line">    boxes_ = []</span><br><span class="line">    scores_ = []</span><br><span class="line">    classes_ = []</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> range(num_classes):</span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> use keras backend instead of tf.</span></span><br><span class="line">        class_boxes = tf.boolean_mask(boxes, mask[:, c])</span><br><span class="line">        class_box_scores = tf.boolean_mask(box_scores[:, c], mask[:, c])</span><br><span class="line">        nms_index = tf.image.non_max_suppression(</span><br><span class="line">            class_boxes, class_box_scores, max_boxes_tensor, iou_threshold=iou_threshold)</span><br><span class="line">        class_boxes = K.gather(class_boxes, nms_index)</span><br><span class="line">        class_box_scores = K.gather(class_box_scores, nms_index)</span><br><span class="line">        classes = K.ones_like(class_box_scores, <span class="string">'int32'</span>) * c</span><br><span class="line">        boxes_.append(class_boxes)</span><br><span class="line">        scores_.append(class_box_scores)</span><br><span class="line">        classes_.append(classes)</span><br><span class="line">    boxes_ = K.concatenate(boxes_, axis=<span class="number">0</span>)</span><br><span class="line">    scores_ = K.concatenate(scores_, axis=<span class="number">0</span>)</span><br><span class="line">    classes_ = K.concatenate(classes_, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> boxes_, scores_, classes_</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>yolo_outputs：<code>yolo_body</code> 模型的输出</li><li>anchors：锚框数组</li><li>num_classes：类别数目</li><li>image_shape： 图片尺寸</li><li>max_boxes：一张图片中，最多出现的预测框数目，默认 20</li><li>score_threshold：预测框分数阈值，默认 0.6，预测框分数指预测框置信度与类别可能性的积。</li><li>iou_threshold：IOU 阈值，默认 0.5</li></ul><p>返回：</p><ul><li>boxex_ ：预测框列表，每个预测框用绝对四边坐标表示。</li><li>scores_：预测框分数列表，上述预测框对应于的分数。</li><li>classes_：类别列表，上述预测框对应的类别独热码。</li></ul><p>执行过程：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_layers = len(yolo_outputs)</span><br><span class="line">anchor_mask = [[<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>], [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]] <span class="keyword">if</span> num_layers==<span class="number">3</span> <span class="keyword">else</span> [[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]] <span class="comment"># default setting</span></span><br><span class="line">input_shape = K.shape(yolo_outputs[<span class="number">0</span>])[<span class="number">1</span>:<span class="number">3</span>] * <span class="number">32</span></span><br><span class="line">boxes = []</span><br><span class="line">box_scores = []</span><br><span class="line"><span class="keyword">for</span> l <span class="keyword">in</span> range(num_layers):</span><br><span class="line">    _boxes, _box_scores = yolo_boxes_and_scores(yolo_outputs[l],</span><br><span class="line">        anchors[anchor_mask[l]], num_classes, input_shape, image_shape)</span><br><span class="line">    boxes.append(_boxes)</span><br><span class="line">    box_scores.append(_box_scores)</span><br><span class="line">boxes = K.concatenate(boxes, axis=<span class="number">0</span>)</span><br><span class="line">box_scores = K.concatenate(box_scores, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>先获取 <code>yolo_outputs</code> 中有多少特征图的输出，记为 <code>num_layers</code></li><li><code>anchor_mask</code> 为锚框掩码，为每一个特征图分配锚框列表中的锚框</li><li><code>input_shape</code> 是指 <code>yolo_body</code> 的输入尺寸，用第一个特征图的尺寸乘 32 即可</li><li>创建预测框列表 <code>boxes</code> 、预测框分数列表 <code>box_scores</code></li><li>循环遍历每个输出的特征图，操作是假设建立在第 <code>l</code> 号特征图上</li><li>通过 <code>yolo_boxes_and_scores</code> 函数，<code>l</code> 号特征图中的预测框信息，和预测框分数信息。</li><li>将分离出来的盒子信息追加到预测框列表 <code>boxes</code> ，预测框分数追加到预测框分数列表 <code>box_scores</code></li><li>按第一维度（不同特征图）连接 <code>boxes</code> 和 <code>box_scores</code> 中的张量，也就是说将多特征图的结果组合成在一起。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mask = box_scores &gt;= score_threshold</span><br><span class="line">max_boxes_tensor = K.constant(max_boxes, dtype=<span class="string">'int32'</span>)</span><br><span class="line">boxes_ = []</span><br><span class="line">scores_ = []</span><br><span class="line">classes_ = []</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> range(num_classes):</span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> use keras backend instead of tf.</span></span><br><span class="line">    class_boxes = tf.boolean_mask(boxes, mask[:, c])</span><br><span class="line">    class_box_scores = tf.boolean_mask(box_scores[:, c], mask[:, c])</span><br><span class="line">    nms_index = tf.image.non_max_suppression(</span><br><span class="line">        class_boxes, class_box_scores, max_boxes_tensor, iou_threshold=iou_threshold)</span><br><span class="line">    class_boxes = K.gather(class_boxes, nms_index)</span><br><span class="line">    class_box_scores = K.gather(class_box_scores, nms_index)</span><br><span class="line">    classes = K.ones_like(class_box_scores, <span class="string">'int32'</span>) * c</span><br><span class="line">    boxes_.append(class_boxes)</span><br><span class="line">    scores_.append(class_box_scores)</span><br><span class="line">    classes_.append(classes)</span><br><span class="line">boxes_ = K.concatenate(boxes_, axis=<span class="number">0</span>)</span><br><span class="line">scores_ = K.concatenate(scores_, axis=<span class="number">0</span>)</span><br><span class="line">classes_ = K.concatenate(classes_, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> boxes_, scores_, classes_</span><br></pre></td></tr></table></figure><ul><li>设置预测框分数掩码 <code>mask</code> 要求预测框分数大于等于预测框分数阈值  <code>score_threshold</code>    </li><li>设置代表最大预测框数目的张量，<code>max_boxes_tensor</code></li><li>建立最终返回的预测框列表 <code>boxes_</code> ，最终返回的预测框分数列表 <code>scores_</code>，最终返回的类别列表 <code>classes_</code></li><li>遍历每一个类别，以下操作第 <code>c</code> 号类别</li><li>使用 <code>tf.boolean_mask</code> 从 <code>boxes</code>  中提取预测框分数大于阈值且预测类别为 <code>c</code> 号类的预测框，将结果记为 <code>class_boxes</code></li><li>使用 <code>tf.boolean_mask</code> 从 <code>c</code>  号类的预测框分数列表 <code>box_scores[:, c]</code> 中，提取预测框分数大于阈值且预测类别为 <code>c</code> 号类的分数值，记为 <code>class_box_scores</code> ，显然 <code>class_boxes</code> 与 <code>class_box_scores</code>  具有对应关系。</li><li>使用 TensorFlow 的 nms 方法 <code>tf.image.non_max_suppression</code> ，获取 nms 后剩余的预测框的索引 <code>nms_index</code> 。</li><li>使用 <code>K.gather</code> 按照索引再提取从 <code>class_boxes</code> 与  <code>class_box_scores</code> 中提取预测框与预测框分数，得到新的 <code>class_boxes</code> 与  <code>class_box_scores</code> </li><li>通过 <code>K.ones_like(class_box_scores, &#39;int32&#39;) * c</code> 得到新的类别独热码</li><li><code>class_boxes</code> 、<code>class_box_scores</code> 、<code>classes</code> 分别追加到 <code>boxes_</code> 、<code>scores_</code>、<code>classes_</code> 中</li><li>最后将 <code>boxes_</code> 、<code>scores_</code>、<code>classes_</code>  中每个类别的结果，通过 <code>K.concatenate</code> 合并在一起。</li><li>返回 <code>boxes_</code> 、<code>scores_</code>、<code>classes_</code> </li></ul><h5 id="yolo-boxes-and-scores"><a href="#yolo-boxes-and-scores" class="headerlink" title="yolo_boxes_and_scores"></a><code>yolo_boxes_and_scores</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">yolo_boxes_and_scores</span><span class="params">(feats, anchors, num_classes, input_shape, image_shape)</span>:</span></span><br><span class="line">    <span class="string">'''Process Conv layer output'''</span></span><br><span class="line">    box_xy, box_wh, box_confidence, box_class_probs = yolo_head(feats,</span><br><span class="line">        anchors, num_classes, input_shape)</span><br><span class="line">    boxes = yolo_correct_boxes(box_xy, box_wh, input_shape, image_shape)</span><br><span class="line">    boxes = K.reshape(boxes, [<span class="number">-1</span>, <span class="number">4</span>])</span><br><span class="line">    box_scores = box_confidence * box_class_probs</span><br><span class="line">    box_scores = K.reshape(box_scores, [<span class="number">-1</span>, num_classes])</span><br><span class="line">    <span class="keyword">return</span> boxes, box_scores</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>feats：特征图</li><li>anchors：锚框数目</li><li>num_classes：类别数目</li><li>input_shape：网络输入尺寸</li><li>image_shape：实际输入的图片尺寸</li></ul><p>返回：</p><ul><li>预测框数组 <code>boxes</code> 与预测框分数数组 <code>box_scores</code></li></ul><p>执行过程：</p><ul><li>先使用 <code>yolo_head</code> 将特诊图的输出划分为 <code>box_xy, box_wh, box_confidence, box_class_probs</code> ，<code>yolo_head</code> 在前面的博文介绍过</li><li>再使用 <code>yolo_correct_boxes</code> 函数，将 <code>box_xy, box_wh</code> 依据网络的输入尺寸和实际图片的尺寸进行修正，并将它们合并在一起。把输出结果记为 <code>boxes</code> ，<code>boxes</code> 内储存着每个预测框在图片上的绝对四边坐标。</li><li>对 <code>boxes</code> 的 shape 进行更改，使之变成 <code>[预测框数目，4]</code> </li><li><code>box_scores</code> 预测框分数，它值等于置信度 * 属于某个的类别可能性</li><li>对 <code>box_scores</code> 的 shape 进行更改，使之变成 <code>[预测框数目，类别数目]</code> </li><li>返回 <code>boxes</code>  和 <code>box_scores</code> </li></ul><h5 id="yolo-correct-boxes"><a href="#yolo-correct-boxes" class="headerlink" title="yolo_correct_boxes"></a><code>yolo_correct_boxes</code></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">yolo_correct_boxes</span><span class="params">(box_xy, box_wh, input_shape, image_shape)</span>:</span></span><br><span class="line">    <span class="string">'''Get corrected boxes'''</span></span><br><span class="line">    box_yx = box_xy[..., ::<span class="number">-1</span>]</span><br><span class="line">    box_hw = box_wh[..., ::<span class="number">-1</span>]</span><br><span class="line">    input_shape = K.cast(input_shape, K.dtype(box_yx))</span><br><span class="line">    image_shape = K.cast(image_shape, K.dtype(box_yx))</span><br><span class="line">    new_shape = K.round(image_shape * K.min(input_shape/image_shape))</span><br><span class="line">    offset = (input_shape-new_shape)/<span class="number">2.</span>/input_shape</span><br><span class="line">    scale = input_shape/new_shape</span><br><span class="line">    box_yx = (box_yx - offset) * scale</span><br><span class="line">    box_hw *= scale</span><br><span class="line"></span><br><span class="line">    box_mins = box_yx - (box_hw / <span class="number">2.</span>)</span><br><span class="line">    box_maxes = box_yx + (box_hw / <span class="number">2.</span>)</span><br><span class="line">    boxes =  K.concatenate([</span><br><span class="line">        box_mins[..., <span class="number">0</span>:<span class="number">1</span>],  <span class="comment"># y_min</span></span><br><span class="line">        box_mins[..., <span class="number">1</span>:<span class="number">2</span>],  <span class="comment"># x_min</span></span><br><span class="line">        box_maxes[..., <span class="number">0</span>:<span class="number">1</span>],  <span class="comment"># y_max</span></span><br><span class="line">        box_maxes[..., <span class="number">1</span>:<span class="number">2</span>]  <span class="comment"># x_max</span></span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Scale boxes back to original image shape.</span></span><br><span class="line">    boxes *= K.concatenate([image_shape, image_shape])</span><br><span class="line">    <span class="keyword">return</span> boxes</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>box_xy：预测框中心点坐标</li><li>box_wh：预测框的宽高信息</li><li>input_shape：模型的输入尺寸</li><li>image_shape：实际图片尺寸</li></ul><p>返回：</p><ul><li>boxes：<code>shape=[...,4]</code> 4 分别代表 <code>y_min,x_min,y_max,x_max</code> 是在原图上的绝对坐标</li></ul><p>执行过程：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">box_yx = box_xy[..., ::<span class="number">-1</span>]</span><br><span class="line">box_hw = box_wh[..., ::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><ul><li>转置最后两个维度</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input_shape = K.cast(input_shape, K.dtype(box_yx))</span><br><span class="line">image_shape = K.cast(image_shape, K.dtype(box_yx))</span><br><span class="line">new_shape = K.round(image_shape * K.min(input_shape/image_shape))</span><br><span class="line">offset = (input_shape-new_shape)/<span class="number">2.</span>/input_shape</span><br><span class="line">scale = input_shape/new_shape</span><br><span class="line">box_yx = (box_yx - offset) * scale</span><br><span class="line">box_hw *= scale</span><br></pre></td></tr></table></figure><ul><li>获得输入尺寸张量 <code>input_shape</code>，图片尺寸张量 <code>image_shape</code></li><li>通过 <code>K.min(input_shape/image_shape)</code> 得到 <code>input_shape</code> 与 <code>image_shape</code> 之间的最小比例</li><li><code>image_shape</code> 去乘这个最小比例，结果是将 <code>image_shape</code>  所表示的尺寸进行缩放，这个尺寸恰好能放到 <code>input_shape</code> 尺寸的图片内。</li><li>使用 <code>K.round</code> 对上述尺寸进行四舍五入，得到整数的尺寸值，将结果保存到 <code>new_shape</code> 中</li><li>计算图像偏移比例  <code>offset</code>  等于（输入尺寸-新尺寸 / 2）/ 输入尺寸</li><li>计算缩放比例 <code>scale</code> 等于输入尺寸 / 新尺寸</li><li>根据偏移比例和缩放比例，计算新的 <code>box_yx</code> 和 <code>box_hw</code></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">box_mins = box_yx - (box_hw / <span class="number">2.</span>)</span><br><span class="line">box_maxes = box_yx + (box_hw / <span class="number">2.</span>)</span><br><span class="line">boxes =  K.concatenate([</span><br><span class="line">box_mins[..., <span class="number">0</span>:<span class="number">1</span>],  <span class="comment"># y_min</span></span><br><span class="line">    box_mins[..., <span class="number">1</span>:<span class="number">2</span>],  <span class="comment"># x_min</span></span><br><span class="line">    box_maxes[..., <span class="number">0</span>:<span class="number">1</span>],  <span class="comment"># y_max</span></span><br><span class="line">    box_maxes[..., <span class="number">1</span>:<span class="number">2</span>]  <span class="comment"># x_max</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">boxes *= K.concatenate([image_shape, image_shape])</span><br><span class="line"><span class="keyword">return</span> boxes</span><br></pre></td></tr></table></figure><ul><li>计算预测框的四边坐标在图中的比例 <code>y_min,x_min,y_max,x_max</code></li><li>将四边坐标比例合并在 <code>boxes</code> 变量内</li><li>四边坐标比例乘输入图片尺寸，得到四边坐标在输入的图片中的真实尺寸，结果保存在 <code>boxes</code> 变量内</li><li>返回 <code>boxes</code> </li></ul><h4 id="实现函数"><a href="#实现函数" class="headerlink" title="实现函数"></a>实现函数</h4><h5 id="detect-img-yolo"><a href="#detect-img-yolo" class="headerlink" title="detect_img(yolo)"></a><code>detect_img(yolo)</code></h5><p>位于 <code>\yolo_video.py</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detect_img</span><span class="params">(yolo)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        img = input(<span class="string">'Input image filename:'</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            image = Image.open(img)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            print(<span class="string">'Open Error! Try again!'</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r_image = yolo.detect_image(image)</span><br><span class="line">            r_image.show()</span><br><span class="line">    yolo.close_session()</span><br></pre></td></tr></table></figure><p>参数和返回值：</p><ul><li>参数 <code>yolo</code> 是一个 YOLO 实例，YOLO 类被定义在 <code>\yolo.py</code> 中</li></ul><p>执行过程：</p><ul><li>通过 <code>input()</code> 内置函数读取图片路径</li><li>使用 <code>PIL</code> 的 <code>Image</code> 从这个路径上读取图片到变量，<code>image</code></li><li>调用 YOLO 对象的 <code>detect_image</code> 方法，该方法返回一个 <code>Image</code> 对象 ，记为 <code>r_image</code></li><li>展示 <code>r_image</code>，并关闭 <code>session</code></li></ul><h5 id="YOLO-detect-image-self-image"><a href="#YOLO-detect-image-self-image" class="headerlink" title="YOLO.detect_image(self, image)"></a><code>YOLO.detect_image(self, image)</code></h5><p>位于 <code>\yolo.py</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detect_image</span><span class="params">(self, image)</span>:</span></span><br><span class="line">    start = timer()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.model_image_size != (<span class="literal">None</span>, <span class="literal">None</span>):</span><br><span class="line">        <span class="keyword">assert</span> self.model_image_size[<span class="number">0</span>]%<span class="number">32</span> == <span class="number">0</span>, <span class="string">'Multiples of 32 required'</span></span><br><span class="line">        <span class="keyword">assert</span> self.model_image_size[<span class="number">1</span>]%<span class="number">32</span> == <span class="number">0</span>, <span class="string">'Multiples of 32 required'</span></span><br><span class="line">        boxed_image = letterbox_image(image, tuple(reversed(self.model_image_size)))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        new_image_size = (image.width - (image.width % <span class="number">32</span>),</span><br><span class="line">                            image.height - (image.height % <span class="number">32</span>))</span><br><span class="line">        boxed_image = letterbox_image(image, new_image_size)</span><br><span class="line">    image_data = np.array(boxed_image, dtype=<span class="string">'float32'</span>)</span><br><span class="line"></span><br><span class="line">    print(image_data.shape)</span><br><span class="line">    image_data /= <span class="number">255.</span></span><br><span class="line">    image_data = np.expand_dims(image_data, <span class="number">0</span>)  <span class="comment"># Add batch dimension.</span></span><br><span class="line"></span><br><span class="line">    out_boxes, out_scores, out_classes = self.sess.run(</span><br><span class="line">        [self.boxes, self.scores, self.classes],</span><br><span class="line">        feed_dict=&#123;</span><br><span class="line">            self.yolo_model.input: image_data,</span><br><span class="line">            self.input_image_shape: [image.size[<span class="number">1</span>], image.size[<span class="number">0</span>]],</span><br><span class="line">            K.learning_phase(): <span class="number">0</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'Found &#123;&#125; boxes for &#123;&#125;'</span>.format(len(out_boxes), <span class="string">'img'</span>))</span><br><span class="line"></span><br><span class="line">    font = ImageFont.truetype(font=<span class="string">'font/FiraMono-Medium.otf'</span>,</span><br><span class="line">                size=np.floor(<span class="number">3e-2</span> * image.size[<span class="number">1</span>] + <span class="number">0.5</span>).astype(<span class="string">'int32'</span>))</span><br><span class="line">    thickness = (image.size[<span class="number">0</span>] + image.size[<span class="number">1</span>]) // <span class="number">300</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, c <span class="keyword">in</span> reversed(list(enumerate(out_classes))):</span><br><span class="line">        predicted_class = self.class_names[c]</span><br><span class="line">        box = out_boxes[i]</span><br><span class="line">        score = out_scores[i]</span><br><span class="line"></span><br><span class="line">        label = <span class="string">'&#123;&#125; &#123;:.2f&#125;'</span>.format(predicted_class, score)</span><br><span class="line">        draw = ImageDraw.Draw(image)</span><br><span class="line">        label_size = draw.textsize(label, font)</span><br><span class="line"></span><br><span class="line">        top, left, bottom, right = box</span><br><span class="line">        top = max(<span class="number">0</span>, np.floor(top + <span class="number">0.5</span>).astype(<span class="string">'int32'</span>))</span><br><span class="line">        left = max(<span class="number">0</span>, np.floor(left + <span class="number">0.5</span>).astype(<span class="string">'int32'</span>))</span><br><span class="line">        bottom = min(image.size[<span class="number">1</span>], np.floor(bottom + <span class="number">0.5</span>).astype(<span class="string">'int32'</span>))</span><br><span class="line">        right = min(image.size[<span class="number">0</span>], np.floor(right + <span class="number">0.5</span>).astype(<span class="string">'int32'</span>))</span><br><span class="line">        print(label, (left, top), (right, bottom))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> top - label_size[<span class="number">1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">            text_origin = np.array([left, top - label_size[<span class="number">1</span>]])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            text_origin = np.array([left, top + <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># My kingdom for a good redistributable image drawing library.</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(thickness):</span><br><span class="line">            draw.rectangle(</span><br><span class="line">                [left + i, top + i, right - i, bottom - i],</span><br><span class="line">                outline=self.colors[c])</span><br><span class="line">        draw.rectangle(</span><br><span class="line">            [tuple(text_origin), tuple(text_origin + label_size)],</span><br><span class="line">            fill=self.colors[c])</span><br><span class="line">        draw.text(text_origin, label, fill=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), font=font)</span><br><span class="line">        <span class="keyword">del</span> draw</span><br><span class="line"></span><br><span class="line">    end = timer()</span><br><span class="line">    print(end - start)</span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure><p>参数和返回值：</p><ul><li>参数是一个 <code>Image</code>  对象，返回一个 <code>Image</code> 对象。</li></ul><p>执行过程：</p><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">start</span> = timer()</span><br></pre></td></tr></table></figure><ul><li><code>timer()</code> 定义于 <code>from timeit import default_timer as timer</code> 用户获取当前时间，变量 <code>start</code> 将配合变量 <code>end</code> 实现度量单张图片处理所用时长。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> self.model_image_size != (<span class="literal">None</span>, <span class="literal">None</span>):</span><br><span class="line">    <span class="keyword">assert</span> self.model_image_size[<span class="number">0</span>]%<span class="number">32</span> == <span class="number">0</span>, <span class="string">'Multiples of 32 required'</span></span><br><span class="line">    <span class="keyword">assert</span> self.model_image_size[<span class="number">1</span>]%<span class="number">32</span> == <span class="number">0</span>, <span class="string">'Multiples of 32 required'</span></span><br><span class="line">    boxed_image = letterbox_image(image, tuple(reversed(self.model_image_size)))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    new_image_size = (image.width - (image.width % <span class="number">32</span>),</span><br><span class="line">    image.height - (image.height % <span class="number">32</span>))</span><br><span class="line">    boxed_image = letterbox_image(image, new_image_size)</span><br><span class="line">image_data = np.array(boxed_image, dtype=<span class="string">'float32'</span>)</span><br></pre></td></tr></table></figure><ul><li>将从参数传入的 <code>Image</code> 对象重新调整大小，调整到 <code>self.model_image_size</code> 规定的大小，并转换成 np 数组，记为 <code>image_data</code> 。</li></ul><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(image_data.shape)</span><br><span class="line">image_data /= <span class="number">255</span>.</span><br><span class="line">image_data = <span class="built_in">np</span>.expand_dims(image_data, <span class="number">0</span>)  # Add <span class="built_in">batch</span> <span class="built_in">dimension</span>.</span><br></pre></td></tr></table></figure><ul><li>对 <code>image_data</code> 进行处理，首先使它的值缩放到 0 到 1 ，其次对它增加批维度</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">out_boxes, out_scores, out_classes = self.sess.run(</span><br><span class="line">[self.boxes, self.scores, self.classes],</span><br><span class="line">    feed_dict=&#123;</span><br><span class="line">        self.yolo_model.input: image_data,</span><br><span class="line">        self.input_image_shape: [image.size[<span class="number">1</span>], image.size[<span class="number">0</span>]],</span><br><span class="line">        K.learning_phase(): <span class="number">0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>在类初始化阶段，已经调用  <code>self.generate()</code> 得到 <code>self.boxes, self.scores, self.classes</code> 这其实是在原有模型的计算图后，衔接了新的运算图。通过 <code>self.sess.run()</code> 可以得到，当给一下结点规定指定值时：</p>  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">self</span><span class="selector-class">.yolo_model</span><span class="selector-class">.input</span>: <span class="selector-tag">image_data</span>,</span><br><span class="line"><span class="selector-tag">self</span><span class="selector-class">.input_image_shape</span>: <span class="selector-attr">[image.size[1]</span>, <span class="selector-tag">image</span><span class="selector-class">.size</span><span class="selector-attr">[0]</span>],</span><br><span class="line"><span class="selector-tag">K</span><span class="selector-class">.learning_phase</span>(): 0</span><br></pre></td></tr></table></figure><p>  计算图中 <code>[self.boxes, self.scores, self.classes]</code> 变量的值，将返回值保存为<code>out_boxes, out_scores, out_classes</code></p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">font = ImageFont.truetype(font=<span class="string">'font/FiraMono-Medium.otf'</span>,</span><br><span class="line">            size=np.floor(<span class="number">3e-2</span> * image.size[<span class="number">1</span>] + <span class="number">0.5</span>).astype(<span class="string">'int32'</span>))</span><br><span class="line">thickness = (image.size[<span class="number">0</span>] + image.size[<span class="number">1</span>]) // <span class="number">300</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, c <span class="keyword">in</span> reversed(list(enumerate(out_classes))):</span><br><span class="line">    predicted_class = self.class_names[c]</span><br><span class="line">    box = out_boxes[i]</span><br><span class="line">    score = out_scores[i]</span><br><span class="line"></span><br><span class="line">    label = <span class="string">'&#123;&#125; &#123;:.2f&#125;'</span>.format(predicted_class, score)</span><br><span class="line">    draw = ImageDraw.Draw(image)</span><br><span class="line">    label_size = draw.textsize(label, font)</span><br><span class="line"></span><br><span class="line">    top, left, bottom, right = box</span><br><span class="line">    top = max(<span class="number">0</span>, np.floor(top + <span class="number">0.5</span>).astype(<span class="string">'int32'</span>))</span><br><span class="line">    left = max(<span class="number">0</span>, np.floor(left + <span class="number">0.5</span>).astype(<span class="string">'int32'</span>))</span><br><span class="line">    bottom = min(image.size[<span class="number">1</span>], np.floor(bottom + <span class="number">0.5</span>).astype(<span class="string">'int32'</span>))</span><br><span class="line">    right = min(image.size[<span class="number">0</span>], np.floor(right + <span class="number">0.5</span>).astype(<span class="string">'int32'</span>))</span><br><span class="line">    print(label, (left, top), (right, bottom))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> top - label_size[<span class="number">1</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">        text_origin = np.array([left, top - label_size[<span class="number">1</span>]])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        text_origin = np.array([left, top + <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># My kingdom for a good redistributable image drawing library.</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(thickness):</span><br><span class="line">        draw.rectangle(</span><br><span class="line">            [left + i, top + i, right - i, bottom - i],</span><br><span class="line">            outline=self.colors[c])</span><br><span class="line">    draw.rectangle(</span><br><span class="line">        [tuple(text_origin), tuple(text_origin + label_size)],</span><br><span class="line">        fill=self.colors[c])</span><br><span class="line">    draw.text(text_origin, label, fill=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), font=font)</span><br><span class="line">    <span class="keyword">del</span> draw</span><br></pre></td></tr></table></figure><ul><li>根据 <code>out_boxes, out_scores, out_classes</code> 在原图上绘制预测框，绘制完预测框后的图像，保存在 <code>image</code> 中</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">end = timer()</span><br><span class="line">print(end - start)</span><br><span class="line"><span class="keyword">return</span> image</span><br></pre></td></tr></table></figure><ul><li>记录结束时间，并打印总耗时</li><li>返回 <code>image</code> 变量</li></ul><h3 id="视频检测源码分析"><a href="#视频检测源码分析" class="headerlink" title="视频检测源码分析"></a>视频检测源码分析</h3><h4 id="实现函数-1"><a href="#实现函数-1" class="headerlink" title="实现函数"></a>实现函数</h4><h5 id="detect-video"><a href="#detect-video" class="headerlink" title="detect_video"></a><code>detect_video</code></h5><p>位于 <code>\yolo.py</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detect_video</span><span class="params">(yolo, video_path, output_path=<span class="string">""</span>)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> cv2</span><br><span class="line">    vid = cv2.VideoCapture(video_path)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> vid.isOpened():</span><br><span class="line">        <span class="keyword">raise</span> IOError(<span class="string">"Couldn't open webcam or video"</span>)</span><br><span class="line">    video_FourCC    = int(vid.get(cv2.CAP_PROP_FOURCC))</span><br><span class="line">    video_fps       = vid.get(cv2.CAP_PROP_FPS)</span><br><span class="line">    video_size      = (int(vid.get(cv2.CAP_PROP_FRAME_WIDTH)),</span><br><span class="line">                        int(vid.get(cv2.CAP_PROP_FRAME_HEIGHT)))</span><br><span class="line">    isOutput = <span class="literal">True</span> <span class="keyword">if</span> output_path != <span class="string">""</span> <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> isOutput:</span><br><span class="line">        print(<span class="string">"!!! TYPE:"</span>, type(output_path), type(video_FourCC), type(video_fps), type(video_size))</span><br><span class="line">        out = cv2.VideoWriter(output_path, video_FourCC, video_fps, video_size)</span><br><span class="line">    accum_time = <span class="number">0</span></span><br><span class="line">    curr_fps = <span class="number">0</span></span><br><span class="line">    fps = <span class="string">"FPS: ??"</span></span><br><span class="line">    prev_time = timer()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        return_value, frame = vid.read()</span><br><span class="line">        image = Image.fromarray(frame)</span><br><span class="line">        image = yolo.detect_image(image)</span><br><span class="line">        result = np.asarray(image)</span><br><span class="line">        curr_time = timer()</span><br><span class="line">        exec_time = curr_time - prev_time</span><br><span class="line">        prev_time = curr_time</span><br><span class="line">        accum_time = accum_time + exec_time</span><br><span class="line">        curr_fps = curr_fps + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> accum_time &gt; <span class="number">1</span>:</span><br><span class="line">            accum_time = accum_time - <span class="number">1</span></span><br><span class="line">            fps = <span class="string">"FPS: "</span> + str(curr_fps)</span><br><span class="line">            curr_fps = <span class="number">0</span></span><br><span class="line">        cv2.putText(result, text=fps, org=(<span class="number">3</span>, <span class="number">15</span>), fontFace=cv2.FONT_HERSHEY_SIMPLEX,</span><br><span class="line">                    fontScale=<span class="number">0.50</span>, color=(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), thickness=<span class="number">2</span>)</span><br><span class="line">        cv2.namedWindow(<span class="string">"result"</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">        cv2.imshow(<span class="string">"result"</span>, result)</span><br><span class="line">        <span class="keyword">if</span> isOutput:</span><br><span class="line">            out.write(result)</span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == ord(<span class="string">'q'</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    yolo.close_session()</span><br></pre></td></tr></table></figure><ul><li>原理就是用 cv2 截视频里的每一帧，然后调用 <code>image = yolo.detect_image(image)</code> 对每一帧进行识别和输出。</li></ul><h2 id="性能评价"><a href="#性能评价" class="headerlink" title="性能评价"></a>性能评价</h2><h3 id="TP-TN-FP-FN-的定义"><a href="#TP-TN-FP-FN-的定义" class="headerlink" title="TP TN FP FN 的定义"></a>TP TN FP FN 的定义</h3><p>从样本角度分类，可分为两类：</p><ul><li>正例（Positives）</li><li>负例（Negatives）</li></ul><p>从分类器的结果正确与否，可以为两类：</p><ul><li>分类正确（True ）</li><li>分类错误（False ）</li></ul><p>那么结合上述两种划分，可以得到四类：</p><ul><li>分类正确的正例（True Positives，<strong>TP</strong>）</li><li>分类正确的负例（True  Negatives，<strong>TN</strong>）</li><li>分类错误的正例（False Positives，<strong>FP</strong>）</li><li>分类错误的负例（False Negatives，<strong>FN</strong>）</li></ul><h3 id="查准率（Precision）"><a href="#查准率（Precision）" class="headerlink" title="查准率（Precision）"></a>查准率（Precision）</h3><p>查准率（Precision）表示在所有分类为正例的情况下（包括真正例和假反例），分类正确的正例占了多少比例。</p><script type="math/tex; mode=display">Precision=\frac{TP}{TP+FN}</script><h3 id="召回率（Recall，又称为-TPR）"><a href="#召回率（Recall，又称为-TPR）" class="headerlink" title="召回率（Recall，又称为 TPR）"></a>召回率（Recall，又称为 TPR）</h3><p>召回率（Recall, 又称为 TPR）表示在所有正例中（包括真正例和假正例），分类正确的正例占了多少比例。</p><script type="math/tex; mode=display">Recall=\frac{TP}{TP+FP}</script><h3 id="交并比（Intersection-over-Union，IOU）"><a href="#交并比（Intersection-over-Union，IOU）" class="headerlink" title="交并比（Intersection over Union，IOU）"></a>交并比（Intersection over Union，IOU）</h3><p>IOU (intersection over union) 为检测结果（预测框）与真实框 Ground Truth 的交集面积比上它们的并集面积。</p><p>设 A , B 为表示平面的集合，S 为求面积的函数，则：</p><script type="math/tex; mode=display">IOU(A,B)=\frac{S(A\cap B)}{S(A\cup B)}</script><h3 id="目标检测任务中的-TP-FP"><a href="#目标检测任务中的-TP-FP" class="headerlink" title="目标检测任务中的 TP FP"></a>目标检测任务中的 TP FP</h3><p>将预测框以分数为依据，按照某一顺序进行排序。若预测框的分数大于某一阈值（Score threshold），则被视为预测为正例（Positives）。</p><p>同时，设立一个 IOU 阈值（IOU threshold），如果一个被视为正例的预测框与真实框的 IOU 大于该 IOU 阈值，则表示这是一个正确的预测，即 TP；小于该阈值，则说明这是一个错误的预测，记为 FP。</p><p>如果对于同一个真实框有多个预测框满足 IOU 大于阈值，此时<strong>只将 IOU 最大的作为 TP</strong>，其余作为FP。</p><p>在 yolo3 网络中，预测框的分数，等于预测框的置信度与类别概率的积。</p><h3 id="目标检测任务中的查准率（Precision）与召回率（Recall）"><a href="#目标检测任务中的查准率（Precision）与召回率（Recall）" class="headerlink" title="目标检测任务中的查准率（Precision）与召回率（Recall）"></a>目标检测任务中的查准率（Precision）与召回率（Recall）</h3><p>当给定一组分数阈值和 IOU 阈值，便可以求出一个类别中的 TP 与 FN，<strong>TP+FN 等于该类别的预测框总数</strong> 。同时 <strong>TP+FP 等于该类别的真实框总数</strong>，也是已知数据。所以给定两个阈值便可由 $Precision=\frac{TP}{TP+FN}$ 与 $Recall=\frac{TP}{TP+FP}$ 求得一组数据 $(r,p)$ 。</p><h3 id="AP-与-mAP"><a href="#AP-与-mAP" class="headerlink" title="AP 与 mAP"></a>AP 与 mAP</h3><p>通常 IOU 阈值不变，被设定为 0.5 ，所以对于某一个类别而言，不同的分数阈值将对应不同的 $(r,p)$ ，给定 n 个分数阈值则可求出 n 个 $(r,p)$ 。将召回率（Recall）作为横轴，查准率（Precision）作为纵轴，n 个 $(r,p)$ 呈现的图像被称为 P-R 图，一个类别的 AP 就是 P-R 图上各点横纵坐标之积的和，为简化运算通常先将 P-R 图变化为单调递减再计算 AP</p><p><strong>如何得到 n 个  $(r,p)$  点</strong></p><ol><li>将总数为 N 的预测框按照分数进行降序排序，判断每个预测框是 TP 还是 FP</li><li>取前 k 个预测框为一组，求这一组预测框的召回率（Recall）和查准率（Precision），k取 （1，2，…，N），得到 N 个 $(r,p)$  点</li></ol><p><strong>如何计算 P-R 图上的 AP</strong></p><ol><li><p>补全区间，添加 $(0,1),(1,0)$ 两个  $(r,p)$  点</p></li><li><p>将 P-R 图像变成单调递减的图像，参考以下代码：</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(mpre)<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    mpre[i] = max(mpre[i], mpre[i+<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p> 即，如果后一项比前一项大，则令前一项等于后一项。通过这种方式保证只能前一项大于等于后一项。</p></li><li><p>计算 AP，参考以下代码：</p> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(mrec)):</span><br><span class="line">    <span class="keyword">if</span> mrec[i] != mrec[i<span class="number">-1</span>]:</span><br><span class="line">    i_list.append(i)</span><br><span class="line"></span><br><span class="line">ap = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> i_list:</span><br><span class="line">ap += ((mrec[i]-mrec[i<span class="number">-1</span>])*mpre[i])</span><br></pre></td></tr></table></figure><p> 即，如果rec的某项与前一项相比变化了，则记录该项索引，构建一个索引列表，最后根据索引列表，计算 AP</p></li></ol><p><strong>如何计算 mAP</strong></p><p>mAP 是所有类别 AP 的平均值。</p><p><strong>参考链接</strong></p><p><a href="https://blog.csdn.net/qq_35916487/article/details/89076570?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/qq_35916487/article/details/89076570?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></p><p><a href="https://blog.csdn.net/zdh2010xyz/article/details/54293298?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/zdh2010xyz/article/details/54293298?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></p><p><a href="https://blog.csdn.net/weixin_38106878/article/details/89199961" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38106878/article/details/89199961</a></p><p><a href="https://blog.csdn.net/plsong_csdn/article/details/89502117" target="_blank" rel="noopener">https://blog.csdn.net/plsong_csdn/article/details/89502117</a></p>]]></content>
      
      
      <categories>
          
          <category> YOLO3 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> YOLO3 </tag>
            
            <tag> Keras </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
